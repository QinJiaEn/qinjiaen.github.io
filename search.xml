<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>换新笔记本了需要下载的软件</title>
      <link href="/posts/345213/"/>
      <url>/posts/345213/</url>
      
        <content type="html"><![CDATA[<h2 id="便捷软件"><a href="#便捷软件" class="headerlink" title="便捷软件"></a>便捷软件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">步骤如下：</span><br><span class="line">1.修改配置文件</span><br><span class="line">修改_config.yml 里的 post_asset_folder: 这个选项设置为True</span><br><span class="line">2.在_post的同级目录下创建download的文件夹。</span><br><span class="line">3.在文章里引用文件，通过如[点击下载](/download/xx.zip)这样的链接。</span><br><span class="line">4.在文章中引用图片，通过 ![pic](/download/image-20191211200232715.png)这样写入。</span><br></pre></td></tr></table></figure><p><a href="/download/Bypass_1.14.98.zip">bypass</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个typora的激活插件</span><br></pre></td></tr></table></figure><p><a href="/download/NavicatCrack.zip">NavicatCrack下载链接</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个Navicat破解的软件</span><br></pre></td></tr></table></figure><p><img src="/posts/345213/2-1684200807297-1.png" alt="pic"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigeMap 获取行政区域</title>
      <link href="/posts/e627e35/"/>
      <url>/posts/e627e35/</url>
      
        <content type="html"><![CDATA[<h2 id="如何在BigeMap中获取行政区域的json方法"><a href="#如何在BigeMap中获取行政区域的json方法" class="headerlink" title="如何在BigeMap中获取行政区域的json方法"></a>如何在BigeMap中获取行政区域的json方法</h2><h3 id="配置地图资源"><a href="#配置地图资源" class="headerlink" title="###配置地图资源"></a>###配置地图资源</h3><p><a href="/download/%E5%9C%B0%E5%9B%BE%E9%85%8D%E7%BD%AE.zip">资源下载</a></p><p><img src="/posts/e627e35/image-20230907113811526.png" alt="image-20230907113811526"></p><h4 id="1-打开软件，地图左上角选择地图"><a href="#1-打开软件，地图左上角选择地图" class="headerlink" title="1.打开软件，地图左上角选择地图"></a>1.打开软件，地图左上角选择地图</h4><p><img src="/posts/e627e35/image-20230907113952794.png" alt="image-20230907113952794"></p><h4 id="2-配置资源文件"><a href="#2-配置资源文件" class="headerlink" title="2.配置资源文件"></a>2.配置资源文件</h4><p><img src="/posts/e627e35/image-20230907114056444.png" alt="image-20230907114056444"></p><h2 id="详细步骤配截图"><a href="#详细步骤配截图" class="headerlink" title="详细步骤配截图"></a>详细步骤配截图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目前为止，直接导出kml数据开始收费了，无法使用。需要迂回一下，先导出bmv格式数据，再通过此软件转换，得到每个街道或者乡、镇的kml数据，步骤如下：</span><br></pre></td></tr></table></figure><h3 id="1-在BigeMap中选择需要的行政区域，并导出该区所有街道的bmv格式数据，保存好。"><a href="#1-在BigeMap中选择需要的行政区域，并导出该区所有街道的bmv格式数据，保存好。" class="headerlink" title="1.在BigeMap中选择需要的行政区域，并导出该区所有街道的bmv格式数据，保存好。"></a>1.在BigeMap中选择需要的行政区域，并导出该区所有街道的bmv格式数据，保存好。</h3><p><img src="/posts/e627e35/image-20230907114307768.png" alt="image-20230907114307768"></p><h3 id="2-将第一步导出的bmv格式数据，用Bigemap-GIS打开"><a href="#2-将第一步导出的bmv格式数据，用Bigemap-GIS打开" class="headerlink" title="2. 将第一步导出的bmv格式数据，用Bigemap GIS打开"></a>2. 将第一步导出的bmv格式数据，用Bigemap GIS打开</h3><p><img src="/posts/e627e35/image-20230907114441172-1694058281617-1.png" alt="image-20230907114441172"></p><h3 id="3-打开bmv格式文件后，在左侧图层管理里面，找到该bmv文件对应的边界。"><a href="#3-打开bmv格式文件后，在左侧图层管理里面，找到该bmv文件对应的边界。" class="headerlink" title="3. 打开bmv格式文件后，在左侧图层管理里面，找到该bmv文件对应的边界。"></a>3. 打开bmv格式文件后，在左侧图层管理里面，找到该bmv文件对应的边界。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“我的图层”--&gt; 新建图层 --&gt; Xxx。右键点击下载地图。</span><br></pre></td></tr></table></figure><p><img src="/posts/e627e35/image-20230907114607404.png" alt="image-20230907114607404"></p><p><img src="/posts/e627e35/image-20230907114658666.png" alt="image-20230907114658666"></p><h3 id="4-打开下载的地图，得到一个文件夹"><a href="#4-打开下载的地图，得到一个文件夹" class="headerlink" title="4. 打开下载的地图，得到一个文件夹"></a>4. 打开下载的地图，得到一个文件夹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件夹里**.kml**文件就是我们想要的边界数据。</span><br></pre></td></tr></table></figure><p><img src="/posts/e627e35/image-20230907114800183.png" alt="image-20230907114800183"></p><h3 id="5-打开-geojson-io"><a href="#5-打开-geojson-io" class="headerlink" title="5.打开 geojson.io"></a>5.打开 geojson.io</h3><h6 id="http-geojson-io-（https-geojson-io-map）"><a href="#http-geojson-io-（https-geojson-io-map）" class="headerlink" title="http://geojson.io （https://geojson.io/#map）"></a><a href="https://link.zhihu.com/?target=http://geojson.io">http://geojson.io</a> （<a href="https://link.zhihu.com/?target=https://geojson.io/%23map">https://geojson.io/#map</a>）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在界面中逐一打开所有kml数据，至此获得对应行政区域的边界json</span><br></pre></td></tr></table></figure><p><img src="/posts/e627e35/image-20230907115202353.png" alt="image-20230907114800183"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文-多线程篇</title>
      <link href="/posts/51401971/"/>
      <url>/posts/51401971/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程篇"><a href="#多线程篇" class="headerlink" title="多线程篇"></a>多线程篇</h1><h2 id="线程的基础知识"><a href="#线程的基础知识" class="headerlink" title="线程的基础知识"></a>线程的基础知识</h2><h3 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h3><pre><code>二者对比：    进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务    不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间    线程更轻量，线程上下文切换成本一般上要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）</code></pre><h3 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">并发：</span><br><span class="line">同一时间应对多件事情的能力（轮流交替执行）【多个线程轮流使用一个或多个 CPU 】</span><br><span class="line">并行：</span><br><span class="line">同一时间动手做多件事情的能力（一起执行）【4核 CPU 同时执行4个线程】</span><br></pre></td></tr></table></figure><h3 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a>创建线程的方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承 Thread 类</span><br><span class="line">实现 runnable 接口</span><br><span class="line">实现 Callable 接口</span><br><span class="line">线程池创建线程</span><br></pre></td></tr></table></figure><p><img src="/posts/51401971/image-20230729175351086.png" alt="image-20230729175351086"></p><p><img src="/posts/51401971/image-20230729175326764.png" alt="image-20230729175326764"></p><p><img src="/posts/51401971/image-20230729175508967.png" alt="image-20230729175508967"></p><p><img src="/posts/51401971/image-20230729175559633.png" alt="image-20230729175559633"></p><h3 id="runnable和Callable有什么区别"><a href="#runnable和Callable有什么区别" class="headerlink" title="runnable和Callable有什么区别"></a>runnable和Callable有什么区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.runnable 接口 run 方法没有返回值</span><br><span class="line">2.Callable 接口 call() 方法有返回值,是个泛型,和 Future\FutureTask 配合可以用来获取异步执行结果</span><br><span class="line">3.Callable 接口 call() 方法允许抛出异常，而 Runnable 接口的 run() 方法的异常只能内部消化，不允许上抛</span><br></pre></td></tr></table></figure><h3 id="在启动线程的时候可以使用-run-方法嘛？run-和-start-有什么区别？"><a href="#在启动线程的时候可以使用-run-方法嘛？run-和-start-有什么区别？" class="headerlink" title="在启动线程的时候可以使用 run 方法嘛？run 和 start 有什么区别？"></a>在启动线程的时候可以使用 run 方法嘛？run 和 start 有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start():</span><br><span class="line">用来启动线程，通过该线程调用 run 方法执行 run 方法中所定义的逻辑代码，start 方法只能被调用一次</span><br><span class="line">run():</span><br><span class="line">封装了要被线程执行的代码，可以被调用多次</span><br></pre></td></tr></table></figure><h3 id="线程包括那些状态，状态之间是如何变化的？"><a href="#线程包括那些状态，状态之间是如何变化的？" class="headerlink" title="线程包括那些状态，状态之间是如何变化的？"></a>线程包括那些状态，状态之间是如何变化的？</h3><p><img src="/posts/51401971/image-20230730101644568.png" alt="image-20230730101644568"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.创建线程对象的时候是新建状态</span><br><span class="line">2.调用 start() 方法后转变为可执行状态</span><br><span class="line">3.线程获得 CPU 执行权，执行结束是终止状态</span><br><span class="line">4.在可执行状态的过程中，如果没有获取 CPU 的执行权，可能会切换到其他状态</span><br><span class="line">4.1如果没有获取锁（ synchronized 或者 lock ）进入阻塞状态，获得锁切换为可执行状态</span><br><span class="line">4.2如果线程调用了 wait() 方法进入等待状态，其他线程调用 notify() 唤醒后可切换为可执行状态</span><br><span class="line">4.3如果线程调用了 sleep(50) 方法，进入计时状态，到时间后切换为可执行状态</span><br></pre></td></tr></table></figure><h3 id="新建T1、T2、T3三个线程，如何保证它们按照顺序执行？"><a href="#新建T1、T2、T3三个线程，如何保证它们按照顺序执行？" class="headerlink" title="新建T1、T2、T3三个线程，如何保证它们按照顺序执行？"></a>新建T1、T2、T3三个线程，如何保证它们按照顺序执行？</h3><p><strong>可使用线程中的join方法解决</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果在 T2 线程中加入如下方法</span><br><span class="line">T1.join();// 那么 T2 线程阻塞，进入计时等待状态，等 T1 线程执行完，那么 T2 线程继续执行</span><br></pre></td></tr></table></figure><h3 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll() 有什么区别？"></a>notify() 和 notifyAll() 有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">notifyAll()：</span><br><span class="line">唤醒所有 wait 的线程</span><br><span class="line">notify：</span><br><span class="line">只随机唤醒一个 wait 线程</span><br></pre></td></tr></table></figure><h3 id="Java-中-wait-和-sleep-方法的不同？"><a href="#Java-中-wait-和-sleep-方法的不同？" class="headerlink" title="Java 中 wait 和 sleep 方法的不同？"></a>Java 中 wait 和 sleep 方法的不同？</h3><p><strong>共同点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait(), wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</span><br></pre></td></tr></table></figure><p><strong>不同点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.方法归属不同</span><br><span class="line">sleep(long) 是 Thread 的静态方法</span><br><span class="line">wait(),wait(long) 是 Object 的成员方法，每个对象都有</span><br><span class="line">2.醒来时机不同</span><br><span class="line">执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</span><br><span class="line">wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</span><br><span class="line">它们都可以被打断唤醒</span><br><span class="line">3.锁特性不同（重点）</span><br><span class="line">wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则没有这样的限制</span><br><span class="line">wait 方法执行后会释放对象锁，允许其他线程获得该对象锁，也就是说（我放弃 CPU，但是你们还可以使用）</span><br><span class="line">sleep 如果在 synchronized 代码块中执行，并不会释放对象锁，也就是说（我放弃了 CPU，但是你们也用不了）</span><br></pre></td></tr></table></figure><h2 id="线程中的并发安全"><a href="#线程中的并发安全" class="headerlink" title="线程中的并发安全"></a>线程中的并发安全</h2><h3 id="synchronized-关键字底层原理"><a href="#synchronized-关键字底层原理" class="headerlink" title="synchronized 关键字底层原理"></a>synchronized 关键字底层原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Synchronized 【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</span><br><span class="line">它底层是由 Monitor 实现的， Monitor 是 JVM 级别的对象（C++实现的）线程获得锁需要使用对象锁来关联 Monitor</span><br><span class="line">在 Monitor 内部有三个属性，分别是 owner、entryList、waiset</span><br><span class="line">其中 owner 是关联的获得锁线程，并且只能关联一个线程、entry 关联的是处于阻塞状态的线程，外套 set 关联的是处于 Waiting 状态的线程 </span><br></pre></td></tr></table></figure><p><strong>Monitor重量级锁</strong><img src="/posts/51401971/image-20230730151902018.png" alt="image-20230730151902018"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个线程进入 synchronized 代码块中，会让对象锁和 Monitor 进行关联，检查一下 Monitor 中的 Owner 是否为 null ，如果为 null，则让当前线程持有，如果不为 null 则让线程去 EntryList 中进行等待，也就是阻塞，最后如果线程执行了 wait() 方法，则会进入 WaitSet 中</span><br></pre></td></tr></table></figure><h3 id="谈谈JMM（Java内存模型）"><a href="#谈谈JMM（Java内存模型）" class="headerlink" title="谈谈JMM（Java内存模型）"></a>谈谈JMM（Java内存模型）</h3><p><strong>Java内存模型</strong> <img src="/posts/51401971/image-20230730195405751.png" alt="image-20230730195405751"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JMM（Java Memory Model）Java内存模型，定义了 共享内存 中 多线程程序读写操作 的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</span><br><span class="line">JMM 把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</span><br><span class="line">线程跟线程之间是相互隔离，线程跟线程交互需要通过主线程</span><br></pre></td></tr></table></figure><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CAS 是基于乐观锁的思想：</span><br><span class="line">最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点在重试呗</span><br><span class="line">Synchronized 是基于悲观锁的思想：</span><br><span class="line">最悲观的估计，得防着其他线程来修改共享变量，我上锁了你们都别想改，我改完了解开锁，你们才有机会。</span><br></pre></td></tr></table></figure><h3 id="CAS-你知道嘛？"><a href="#CAS-你知道嘛？" class="headerlink" title="CAS 你知道嘛？"></a>CAS 你知道嘛？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CAS全程是：</span><br><span class="line">Compare And Swap （比较在交换）；它体现的是一种乐观锁的思想，在无所状态下保证线程操作数据的原子性</span><br><span class="line">Cas 使用到的地方很多： AQS框架 AtomicXxx类</span><br><span class="line">在操作共享变量的时候使用的自旋锁，效率上更高一些</span><br><span class="line">CAS 的底层是调用的 Unsafe 类中的方法，都是操作系统提供的，其他语言实现的</span><br></pre></td></tr></table></figure><h3 id="请谈谈你对-volatile-的理解"><a href="#请谈谈你对-volatile-的理解" class="headerlink" title="请谈谈你对 volatile 的理解"></a>请谈谈你对 volatile 的理解</h3><p><img src="/posts/51401971/image-20230731112245241.png" alt="image-20230731112245241"></p><p><img src="/posts/51401971/image-20230731112001825.png" alt="image-20230731112001825"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后</span><br><span class="line"></span><br><span class="line">1.保证线程间的可见性</span><br><span class="line">用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有可能线程读到的变量没有共享到，是因为   JVM   虚拟机中有一个  JIT（即时编译器）给代码做了优化</span><br><span class="line">解决方案一：</span><br><span class="line">在程序运行的时候加入 vm 参数 -Xint 表示禁用即时编译器，不推荐</span><br><span class="line">解决方案二：</span><br><span class="line">在修饰  计划共享变量的时候  加上  volatile  ，告诉 jit，不要对 volatile修饰的变量做优化</span><br><span class="line"></span><br><span class="line">2.禁止进行指令重排序</span><br><span class="line"> 指令重排：</span><br><span class="line"> 用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</span><br></pre></td></tr></table></figure><h3 id="什么是-AQS"><a href="#什么是-AQS" class="headerlink" title="什么是 AQS"></a>什么是 AQS</h3><pre><code>全程是 Abstract Queued Synchronized ，即抽象队列同步器。它是构建锁或者其他同步组件的基础框架</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文-集合篇</title>
      <link href="/posts/724f0833/"/>
      <url>/posts/724f0833/</url>
      
        <content type="html"><![CDATA[<h1 id="集合篇"><a href="#集合篇" class="headerlink" title="集合篇"></a>集合篇</h1><p><strong><img src="/posts/724f0833/image-20230728194105302.png" alt="image-20230728194105302"></strong></p><p><strong>数组</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组是一种 用连续的内存空间 存储  相同数据类型  数据的线性数据结构</span><br></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="ArrayList的底层的实现原理是什么"><a href="#ArrayList的底层的实现原理是什么" class="headerlink" title="ArrayList的底层的实现原理是什么"></a>ArrayList的底层的实现原理是什么</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList底层是用动态数组实现的</span><br><span class="line">ArrayList初始容量是0，当第一次添加元素的时候才会初始化容量为10</span><br><span class="line">ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组（a &gt;&gt; 1）就是除2操作</span><br><span class="line">ArrayList在添加数据的时候</span><br><span class="line">确保数组已使用长度加1之后足够存下 下一个数据</span><br><span class="line">计算数组的容量，如果当前数组已使用长度加1后的大于当前数组长度，则调用grow方法扩容（原来的1.5倍）</span><br><span class="line">确保新增的数据有地方存储后，则将新元素添加到位于size的位置上</span><br><span class="line">返回添加成功布尔值</span><br></pre></td></tr></table></figure><h3 id="Array-List和LinkedList的区别是什么"><a href="#Array-List和LinkedList的区别是什么" class="headerlink" title="Array List和LinkedList的区别是什么"></a>Array List和LinkedList的区别是什么</h3><ul><li><p>底层数据结构</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList是基于动态数组的数据结构</span><br><span class="line">LinkedList是基于双向链表的数据结构</span><br></pre></td></tr></table></figure></li><li><p>效率</p></li><li><p>空间</p></li><li><p>线程是否安全</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList和LinkedList都不是线程安全的</span><br><span class="line">  如果要保证线程安全，有两种方案：</span><br><span class="line">  在方法内部使用，也就是说局部变量，局部变量是线程安全的</span><br><span class="line">  使用线程安全的ArrayList和LinkedList</span><br><span class="line">  Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">  Collections.synchronizedList(new LinkedList&lt;&gt;());</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><strong>散列表</strong></h4><pre><code>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</code></pre><h4 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a><strong>HashMap实现原理</strong></h4><p><img src="/posts/724f0833/image-20230729111016097.png" alt="image-20230729111016097"></p><p><strong>HashMap的put流程</strong></p><p><img src="/posts/724f0833/image-20230729115750891.png" alt="image-20230729115750891"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.判断键值对数组table是否为空或者为null，不是空的话执行resize()进行扩容（初始化）</span><br><span class="line">2.根据键值key计算hash值得到数组索引</span><br><span class="line">3.判断table[i] == null条件成立，直接新建节点添加</span><br><span class="line">4.如果table[i] == null不成立</span><br><span class="line">4.1判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</span><br><span class="line">4.2判断table[i]是否为红黑树，如果是红黑树，则直接在树上插入键值对</span><br><span class="line">4.3遍历table[i]链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转化为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</span><br><span class="line">5.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshol（数组长度*0.75）如果超过，进行扩容</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文-Redis篇</title>
      <link href="/posts/5d16a534/"/>
      <url>/posts/5d16a534/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-篇"><a href="#Redis-篇" class="headerlink" title="Redis 篇"></a>Redis 篇</h1><p><img src="/posts/5d16a534/image-20230721115118730.png" alt="image-20230721115118730"></p><p><img src="/posts/5d16a534/image-20230721120007468.png" alt="image-20230721120007468"></p><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><img src="/posts/5d16a534/image-20230721115131432.png" alt="image-20230721115131432"></p><h4 id="方案一：缓存空数据"><a href="#方案一：缓存空数据" class="headerlink" title="方案一：缓存空数据"></a>方案一：缓存空数据</h4><p><img src="/posts/5d16a534/image-20230721114538562.png" alt="image-20230721114538562"></p><h4 id="方案二：布隆过滤器"><a href="#方案二：布隆过滤器" class="headerlink" title="方案二：布隆过滤器"></a>方案二：布隆过滤器</h4><p><img src="/posts/5d16a534/image-20230721114924136.png" alt="image-20230721114924136"></p><h4 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h4><p><img src="/posts/5d16a534/image-20230721115220031.png" alt="image-20230721115220031"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong><img src="/posts/5d16a534/image-20230721114214034.png" alt="image-20230721114214034"></strong><img src="/posts/5d16a534/image-20230721114447532.png" alt="image-20230721114447532"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中互斥锁：强一致、性能差</span><br><span class="line">逻辑过期：  高可用、性能优</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><img src="/posts/5d16a534/image-20230721115635567.png" alt="image-20230721115635567"></p><p><img src="/posts/5d16a534/image-20230721115506034.png" alt="image-20230721115506034"></p><h2 id="双写一致"><a href="#双写一致" class="headerlink" title="双写一致"></a>双写一致</h2><p><img src="/posts/5d16a534/image-20230721120215526.png" alt="image-20230721120215526"></p><p><img src="/posts/5d16a534/image-20230721120455765.png" alt="image-20230721120455765"></p><h3 id="问题？是先删除缓存还是先修改数据库？"><a href="#问题？是先删除缓存还是先修改数据库？" class="headerlink" title="问题？是先删除缓存还是先修改数据库？"></a>问题？是先删除缓存还是先修改数据库？</h3><h4 id="先删除缓存，在操作数据库有两种情况"><a href="#先删除缓存，在操作数据库有两种情况" class="headerlink" title="先删除缓存，在操作数据库有两种情况"></a>先删除缓存，在操作数据库有两种情况</h4><p><img src="/posts/5d16a534/image-20230721120928537.png" alt="image-20230721120928537"></p><p><img src="/posts/5d16a534/image-20230721121028252.png" alt="image-20230721121028252"></p><h4 id="先修改数据库，在删除缓存"><a href="#先修改数据库，在删除缓存" class="headerlink" title="先修改数据库，在删除缓存"></a>先修改数据库，在删除缓存</h4><p><img src="/posts/5d16a534/image-20230721121132314.png" alt="image-20230721121132314"></p><p><img src="/posts/5d16a534/image-20230721121729727.png" alt="image-20230721121729727"></p><h3 id="如果要保持强一致，加锁"><a href="#如果要保持强一致，加锁" class="headerlink" title="如果要保持强一致，加锁"></a>如果要保持强一致，加锁</h3><p><img src="/posts/5d16a534/image-20230721122141511.png" alt="image-20230721122141511"></p><h3 id="允许延迟"><a href="#允许延迟" class="headerlink" title="允许延迟"></a>允许延迟</h3><h4 id="基于MQ"><a href="#基于MQ" class="headerlink" title="基于MQ"></a>基于MQ</h4><p><img src="/posts/5d16a534/image-20230721122301976.png" alt="image-20230721122301976"></p><h4 id="基于-Canal"><a href="#基于-Canal" class="headerlink" title="基于 Canal"></a>基于 Canal</h4><p><img src="/posts/5d16a534/image-20230721122334453.png" alt="image-20230721122334453"></p><h4 id="e-g"><a href="#e-g" class="headerlink" title="e.g"></a>e.g</h4><p><img src="/posts/5d16a534/image-20230721122613562.png" alt="image-20230721122613562"></p><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><img src="/posts/5d16a534/image-20230721152708702.png" alt="image-20230721152708702"></p><h4 id="RDB的执行原理"><a href="#RDB的执行原理" class="headerlink" title="RDB的执行原理"></a>RDB的执行原理</h4><p><img src="/posts/5d16a534/image-20230721153130474.png" alt="image-20230721153130474"></p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><img src="/posts/5d16a534/image-20230721153307831.png" alt="image-20230721153307831"></p><p><img src="/posts/5d16a534/image-20230721153342444.png" alt="image-20230721153342444"></p><p><img src="/posts/5d16a534/image-20230721153628006.png" alt="image-20230721153628006"></p><h4 id="RDB和AOF的对比"><a href="#RDB和AOF的对比" class="headerlink" title="RDB和AOF的对比"></a>RDB和AOF的对比</h4><p><img src="/posts/5d16a534/image-20230721153850193.png" alt="image-20230721153850193"></p><h2 id="Redis-的数据过期策略"><a href="#Redis-的数据过期策略" class="headerlink" title="Redis 的数据过期策略"></a>Redis 的数据过期策略</h2><p><img src="/posts/5d16a534/image-20230721154024992.png" alt="image-20230721154024992"></p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p><img src="/posts/5d16a534/image-20230721154901642.png" alt="image-20230721154901642"></p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p><img src="/posts/5d16a534/image-20230721155134720.png" alt="image-20230721155134720"></p><h3 id="e-g-1"><a href="#e-g-1" class="headerlink" title="e.g"></a>e.g</h3><p><img src="/posts/5d16a534/image-20230721155429708.png" alt="image-20230721155429708"></p><h2 id="Redis-的数据淘汰策略"><a href="#Redis-的数据淘汰策略" class="headerlink" title="Redis 的数据淘汰策略"></a>Redis 的数据淘汰策略</h2><p><img src="/posts/5d16a534/image-20230721155812984.png" alt="image-20230721155812984"></p><h4 id="e-g-2"><a href="#e-g-2" class="headerlink" title="e.g"></a>e.g</h4><p><img src="/posts/5d16a534/image-20230721160432401.png" alt="image-20230721160432401"></p><p><img src="/posts/5d16a534/image-20230721160448534.png" alt="image-20230721160448534"></p><h2 id="Redis-的分布式锁"><a href="#Redis-的分布式锁" class="headerlink" title="Redis 的分布式锁"></a>Redis 的分布式锁</h2><p><img src="/posts/5d16a534/image-20230721175254947.png" alt="image-20230721175254947"></p><h4 id="e-g-3"><a href="#e-g-3" class="headerlink" title="e.g"></a>e.g</h4><p><img src="/posts/5d16a534/image-20230721175554263.png" alt="image-20230721175554263"></p><h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p><img src="/posts/5d16a534/image-20230721175832796.png" alt="image-20230721175832796"></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="/posts/5d16a534/image-20230721180023425.png" alt="image-20230721180023425"></p><h5 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h5><p><img src="/posts/5d16a534/image-20230721182042182.png" alt="image-20230721182042182">  </p><h5 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h5><p><img src="/posts/5d16a534/image-20230721182249354.png" alt="image-20230721182249354"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/posts/5d16a534/image-20230721211412045.png" alt="image-20230721211412045"></p><h5 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h5><p><img src="/posts/5d16a534/image-20230721211929068.png" alt="image-20230721211929068"></p><h5 id="哨兵模式（脑裂）"><a href="#哨兵模式（脑裂）" class="headerlink" title="哨兵模式（脑裂）"></a>哨兵模式（脑裂）</h5><p><img src="/posts/5d16a534/image-20230721212233383.png" alt="image-20230721212233383"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master因为网络或者其他原因暂时不能和Sentinel通信，导致从节点中产生了新的master，等网络恢复之后，会产生两个master，那么之前的master会降级为slave，（那么这个过程中客户端到老master中存入的数据就会永久丢失）</span><br></pre></td></tr></table></figure><h5 id="e-g-4"><a href="#e-g-4" class="headerlink" title="e.g"></a>e.g</h5><p><img src="/posts/5d16a534/image-20230722103032370.png" alt="image-20230722102959972"></p><h3 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h3><p><img src="/posts/5d16a534/image-20230722103507730.png" alt="image-20230722103507730"></p><h5 id="分片集群结构-数据读写（哈希槽）"><a href="#分片集群结构-数据读写（哈希槽）" class="headerlink" title="分片集群结构-数据读写（哈希槽）"></a>分片集群结构-数据读写（哈希槽）</h5><p><img src="/posts/5d16a534/image-20230722104106658.png" alt="image-20230722104106658"></p><h5 id="e-g-5"><a href="#e-g-5" class="headerlink" title="e.g"></a>e.g</h5><p><img src="/posts/5d16a534/image-20230722104456988.png" alt="image-20230722104456988"></p><h2 id="Redis-单线程"><a href="#Redis-单线程" class="headerlink" title="Redis 单线程"></a>Redis 单线程</h2><p><img src="/posts/5d16a534/image-20230722104858964.png" alt="image-20230722104858964"></p><h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p><img src="/posts/5d16a534/image-20230722105348983.png" alt="image-20230722105348983"></p><h3 id="阻塞-I-x2F-O"><a href="#阻塞-I-x2F-O" class="headerlink" title="阻塞 I&#x2F;O"></a>阻塞 I&#x2F;O</h3><p><img src="/posts/5d16a534/image-20230722105633698.png" alt="image-20230722105633698"></p><h3 id="非阻塞-I-x2F-O"><a href="#非阻塞-I-x2F-O" class="headerlink" title="非阻塞 I&#x2F;O"></a>非阻塞 I&#x2F;O</h3><p><img src="/posts/5d16a534/image-20230722110334906.png" alt="image-20230722110334906"></p><h3 id="I-x2F-O-多路复用"><a href="#I-x2F-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h3><p><img src="/posts/5d16a534/image-20230722111138343.png" alt="image-20230722111138343"></p><p><img src="/posts/5d16a534/image-20230722111618596.png" alt="image-20230722111618596"></p><h3 id="Redis-的网络模型"><a href="#Redis-的网络模型" class="headerlink" title="Redis 的网络模型"></a>Redis 的网络模型</h3><p><img src="/posts/5d16a534/image-20230722112415285.png" alt="image-20230722112415285"></p><h3 id="e-g-6"><a href="#e-g-6" class="headerlink" title="e.g"></a>e.g</h3><p><img src="/posts/5d16a534/image-20230722112450017-1690452640159-54.png" alt="image-20230722112450017"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文-微服务篇</title>
      <link href="/posts/52d9fea0/"/>
      <url>/posts/52d9fea0/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务篇"><a href="#微服务篇" class="headerlink" title="微服务篇"></a>微服务篇</h1><p><img src="/posts/52d9fea0/image-20230727182142156.png" alt="image-20230727182142156"></p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p><img src="/posts/52d9fea0/image-20230727182200600.png" alt="image-20230727182200600"></p><h3 id="Spring-Cloud五大组件"><a href="#Spring-Cloud五大组件" class="headerlink" title="Spring Cloud五大组件"></a>Spring Cloud五大组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务注册：Nacos</span><br><span class="line">负载均衡：Ribbon</span><br><span class="line">远程调用：Feign</span><br><span class="line">服务熔断：Sentinel</span><br><span class="line">网关：Gateway</span><br></pre></td></tr></table></figure><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><h4 id="Nacos-amp-Eureka"><a href="#Nacos-amp-Eureka" class="headerlink" title="Nacos &amp; Eureka"></a>Nacos &amp; Eureka</h4><p><img src="/posts/52d9fea0/image-20230727194640479.png" alt="image-20230727194640479"></p><p><img src="/posts/52d9fea0/image-20230727194725590.png" alt="image-20230727194725590"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="Ribbon负载均衡策略"><a href="#Ribbon负载均衡策略" class="headerlink" title="Ribbon负载均衡策略"></a>Ribbon负载均衡策略</h4><p><img src="/posts/52d9fea0/image-20230727200238614.png" alt="image-20230727200238614"></p><p><img src="/posts/52d9fea0/image-20230727200808854.png" alt="image-20230727200808854"></p><h4 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h4><p><img src="/posts/52d9fea0/image-20230727200206252.png" alt="image-20230727200206252"></p><h3 id="熔断、降级"><a href="#熔断、降级" class="headerlink" title="熔断、降级"></a>熔断、降级</h3><p><strong>服务降级</strong></p><p><img src="/posts/52d9fea0/image-20230727202321219.png" alt="image-20230727202321219"></p><p><img src="/posts/52d9fea0/image-20230727201612176.png" alt="image-20230727201612176"></p><p><img src="/posts/52d9fea0/image-20230728150340613.png" alt="image-20230728150340613"></p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h4 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APM(分布式系统的应用程序性能监控工具)，提供了完善的链路追踪能力，appache的顶级项目</span><br></pre></td></tr></table></figure><p><img src="/posts/52d9fea0/image-20230728152002437.png" alt="image-20230728152002437"></p><h2 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><h4 id="Nginx-漏桶算法"><a href="#Nginx-漏桶算法" class="headerlink" title="Nginx 漏桶算法"></a>Nginx 漏桶算法</h4><p><strong>控制速率</strong></p><p><img src="/posts/52d9fea0/image-20230728152618493.png" alt="image-20230728152618493"></p><p><img src="/posts/52d9fea0/image-20230728155844488.png" alt="image-20230728155844488"></p><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="分布式理论CAP、BASE"><a href="#分布式理论CAP、BASE" class="headerlink" title="分布式理论CAP、BASE"></a>分布式理论CAP、BASE</h4><p><strong>CAP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consistency(一致性)：</span><br><span class="line">用户访问分布式中的任意节点，得到的结果都是一样的</span><br><span class="line">Availability(可用性)：</span><br><span class="line">用户访问集群中的任意健康节点，必须能得到响应，而不是超时或者拒绝</span><br><span class="line">Partition tolerance(分区容错性)：</span><br><span class="line">Partition：</span><br><span class="line">因为网络故障或者其他原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区</span><br><span class="line">tolerance：</span><br><span class="line">在集群出现分区时，整个系统也要持续对外提供服务</span><br><span class="line">CP:强一致</span><br><span class="line">AP:高可用</span><br></pre></td></tr></table></figure><p><strong>BASE</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Basically Available(基本可用)：</span><br><span class="line">分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</span><br><span class="line">Soft State(软状态)：</span><br><span class="line">在一定时间内，允许出现中间状态，比如临时的不一致状态</span><br><span class="line">Eventually Consistent(最终一致性)：</span><br><span class="line">虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</span><br></pre></td></tr></table></figure><p><img src="/posts/52d9fea0/image-20230728172610771.png" alt="image-20230728172610771"></p><h3 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h3><h4 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h4><p><img src="/posts/52d9fea0/image-20230728175759803.png" alt="image-20230728175759803"></p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文-框架篇</title>
      <link href="/posts/90abcb0a/"/>
      <url>/posts/90abcb0a/</url>
      
        <content type="html"><![CDATA[<h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><p><img src="/posts/90abcb0a/image-20230724174617036.png" alt="image-20230724174617036"></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring框架中的单例Bean是线程安全的吗？"><a href="#Spring框架中的单例Bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例Bean是线程安全的吗？"></a>Spring框架中的单例Bean是线程安全的吗？</h3><p><img src="/posts/90abcb0a/image-20230724175230927.png" alt="image-20230724175230927"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不是线程安全的</span><br><span class="line">Spring框架中有一个 @Scope 注解，默认的值就是 singleton 单例的，因为一般在 Spring 的 bean 中都是注入无状态的对象，没有线程安全问题，如果在 bean 中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决</span><br></pre></td></tr></table></figure><h4 id="e-g"><a href="#e-g" class="headerlink" title="e.g"></a>e.g</h4><p><img src="/posts/90abcb0a/image-20230724175410989.png" alt="image-20230724175410989"></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><img src="/posts/90abcb0a/image-20230724175759872.png" alt="image-20230724175759872"></p><p><img src="/posts/90abcb0a/image-20230724180948505.png" alt="image-20230724180948505"></p><h3 id="Spring中的事务如何实现"><a href="#Spring中的事务如何实现" class="headerlink" title="Spring中的事务如何实现"></a>Spring中的事务如何实现</h3><p><img src="/posts/90abcb0a/image-20230724180552118.png" alt="image-20230724180552118"></p><h3 id="Spring中事务失效场景"><a href="#Spring中事务失效场景" class="headerlink" title="Spring中事务失效场景"></a>Spring中事务失效场景</h3><p><strong>异常捕获处理</strong></p><p><img src="/posts/90abcb0a/image-20230724182222137.png" alt="image-20230724182222137"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原因：</span><br><span class="line">自己手动处理了异常try掉了，没有抛出异常</span><br><span class="line">解决：</span><br><span class="line">手动抛出异常</span><br></pre></td></tr></table></figure><p><strong>抛出检查异常</strong></p><p><img src="/posts/90abcb0a/image-20230724182512757.png" alt="image-20230724182512757"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原因：</span><br><span class="line">Spring默认只会回滚非检查异常</span><br><span class="line">解决:</span><br><span class="line">配置rollbackFor属性</span><br><span class="line"><span class="meta">@Transaction(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure><p><strong>非public方法</strong></p><p><img src="/posts/90abcb0a/image-20230724194544508.png" alt="image-20230724194544508"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原因：</span><br><span class="line">Spring 为方法创建代理，添加事务通知，前提条件都是该方法是public的</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line">改为public   不写默认是defult</span><br></pre></td></tr></table></figure><h3 id="Spring-中-Bean-的生命周期"><a href="#Spring-中-Bean-的生命周期" class="headerlink" title="Spring 中 Bean 的生命周期"></a>Spring 中 Bean 的生命周期</h3><p><img src="/posts/90abcb0a/image-20230724203138282.png" alt="image-20230724203138282"></p><p><img src="/posts/90abcb0a/image-20230724204637165.png" alt="image-20230724204637165"></p><h3 id="Spring-的循环引用"><a href="#Spring-的循环引用" class="headerlink" title="Spring 的循环引用"></a>Spring 的循环引用</h3><p><img src="/posts/90abcb0a/image-20230724210930952.png" alt="image-20230724210930952"></p><h4 id="三级缓存解决循环依赖"><a href="#三级缓存解决循环依赖" class="headerlink" title="三级缓存解决循环依赖"></a>三级缓存解决循环依赖</h4><p><img src="/posts/90abcb0a/image-20230724211242950.png" alt="image-20230724211242950"></p><p><img src="/posts/90abcb0a/image-20230724212156129.png" alt="image-20230724212156129"></p><p><strong>用一级缓存和二级缓存解决</strong></p><p><img src="/posts/90abcb0a/image-20230724211516842.png" alt="image-20230724211516842"></p><h4 id="构造方法出现循环依赖"><a href="#构造方法出现循环依赖" class="headerlink" title="构造方法出现循环依赖"></a>构造方法出现循环依赖</h4><p><img src="/posts/90abcb0a/image-20230724212300102.png" alt="image-20230724212300102"></p><h3 id="Spring-MVC-的执行流程"><a href="#Spring-MVC-的执行流程" class="headerlink" title="Spring MVC 的执行流程"></a>Spring MVC 的执行流程</h3><h4 id="视图阶段-JSP"><a href="#视图阶段-JSP" class="headerlink" title="视图阶段(JSP)"></a>视图阶段(JSP)</h4><p><img src="/posts/90abcb0a/image-20230727110216531.png" alt="image-20230727110216531"></p><h4 id="前后端分离阶段（接口开发，异步请求）"><a href="#前后端分离阶段（接口开发，异步请求）" class="headerlink" title="前后端分离阶段（接口开发，异步请求）"></a>前后端分离阶段（接口开发，异步请求）</h4><p><img src="/posts/90abcb0a/image-20230727110548350.png" alt="image-20230727110548350"></p><p><img src="/posts/90abcb0a/image-20230727111652765.png" alt="image-20230727111652765"></p><h3 id="Spring-Boot-自动配置原理"><a href="#Spring-Boot-自动配置原理" class="headerlink" title="Spring Boot 自动配置原理"></a>Spring Boot 自动配置原理</h3><p><img src="/posts/90abcb0a/image-20230727113821618.png" alt="image-20230727113821618"></p><p><img src="/posts/90abcb0a/image-20230727114228908.png" alt="image-20230727114228908"></p><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><h4 id="Spring中常见注解"><a href="#Spring中常见注解" class="headerlink" title="Spring中常见注解"></a>Spring中常见注解</h4><p><img src="/posts/90abcb0a/image-20230727114334823.png" alt="image-20230727114334823"></p><h4 id="SpringMVC-常见注解"><a href="#SpringMVC-常见注解" class="headerlink" title="SpringMVC 常见注解"></a>SpringMVC 常见注解</h4><p><img src="/posts/90abcb0a/image-20230727114511263.png" alt="image-20230727114511263"></p><h4 id="SpringBoot-常见注解"><a href="#SpringBoot-常见注解" class="headerlink" title="SpringBoot 常见注解"></a>SpringBoot 常见注解</h4><p><img src="/posts/90abcb0a/image-20230727114649280.png" alt="image-20230727114649280"></p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="Mybatis的执行流程"><a href="#Mybatis的执行流程" class="headerlink" title="Mybatis的执行流程"></a>Mybatis的执行流程</h3><p><img src="/posts/90abcb0a/image-20230727115716199.png" alt="image-20230727115716199"></p><p><img src="/posts/90abcb0a/image-20230727115821892.png" alt="image-20230727115821892"></p><h3 id="Mybatis延迟加载"><a href="#Mybatis延迟加载" class="headerlink" title="Mybatis延迟加载"></a>Mybatis延迟加载</h3><p><img src="/posts/90abcb0a/image-20230727121957399.png" alt="image-20230727121957399"></p><p><img src="/posts/90abcb0a/image-20230727122106946.png" alt="image-20230727122106946"></p><h3 id="Mybatis的一级缓存和二级缓存"><a href="#Mybatis的一级缓存和二级缓存" class="headerlink" title="Mybatis的一级缓存和二级缓存"></a>Mybatis的一级缓存和二级缓存</h3><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p><img src="/posts/90abcb0a/image-20230727122434434.png" alt="image-20230727122434434"></p><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p><img src="/posts/90abcb0a/image-20230727171428335.png" alt="image-20230727171428335"></p><p><img src="/posts/90abcb0a/image-20230727172538700.png" alt="image-20230727172538700"></p><p><img src="/posts/90abcb0a/image-20230727172642563.png" alt="image-20230727172642563"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文(MySQL篇)</title>
      <link href="/posts/a981c63a/"/>
      <url>/posts/a981c63a/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/posts/a981c63a/image-20230722114559967.png" alt="image-20230722114559967"></p><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p><img src="/posts/a981c63a/image-20230722114745412.png" alt="image-20230722114745412"></p><h3 id="MySQL自带慢日志"><a href="#MySQL自带慢日志" class="headerlink" title="MySQL自带慢日志"></a>MySQL自带慢日志</h3><p><img src="/posts/a981c63a/image-20230722115055809.png" alt="image-20230722115055809"></p><p><img src="/posts/a981c63a/image-20230722120440772.png" alt="image-20230722120440772"></p><h3 id="e-g"><a href="#e-g" class="headerlink" title="e.g"></a>e.g</h3><p><img src="/posts/a981c63a/image-20230722120552081.png" alt="image-20230722120552081"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><img src="/posts/a981c63a/image-20230722145956998.png" alt="image-20230722145956998"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p><img src="/posts/a981c63a/image-20230722150942267.png" alt="image-20230722150942267"></p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p><img src="/posts/a981c63a/image-20230722150900582.png" alt="image-20230722150900582"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B+ 树非叶子节点都是指针，只有叶子节点才是数据（并且叶子节点之间连接的是双向链表），所以读写速度更快，便于扫库和区间查询，</span><br><span class="line">MySQL 默认引擎 InnoDB 用的数据结构就是 B+ 树</span><br></pre></td></tr></table></figure><h3 id="e-g-1"><a href="#e-g-1" class="headerlink" title="e.g"></a>e.g</h3><p><img src="/posts/a981c63a/image-20230722151337492.png" alt="image-20230722151337492"></p><h2 id="聚簇索引，非聚簇索引（聚集索引-二级索引）"><a href="#聚簇索引，非聚簇索引（聚集索引-二级索引）" class="headerlink" title="聚簇索引，非聚簇索引（聚集索引,二级索引）"></a>聚簇索引，非聚簇索引（聚集索引,二级索引）</h2><p><img src="/posts/a981c63a/image-20230722151744402.png" alt="image-20230722151744402"></p><h3 id="什么是聚簇索引和非聚簇索引"><a href="#什么是聚簇索引和非聚簇索引" class="headerlink" title="什么是聚簇索引和非聚簇索引"></a>什么是聚簇索引和非聚簇索引</h3><p><img src="/posts/a981c63a/image-20230722152022622.png" alt="image-20230722152022622"></p><h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h3><p><img src="/posts/a981c63a/image-20230722152441013.png" alt="image-20230722152441013"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回表查询也就是说，先根据二级索引查询到要查询的主键值，然后根据聚集索引查询（因为聚集索引的叶子节点有全部的数据）数据</span><br></pre></td></tr></table></figure><h3 id="e-g-2"><a href="#e-g-2" class="headerlink" title="e.g"></a>e.g</h3><p><img src="/posts/a981c63a/image-20230722152926369.png" alt="image-20230722152926369"></p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><img src="/posts/a981c63a/image-20230722154259439.png" alt="image-20230722154259439"></p><h3 id="MySQL-超大分页处理"><a href="#MySQL-超大分页处理" class="headerlink" title="MySQL 超大分页处理"></a>MySQL 超大分页处理</h3><p><img src="/posts/a981c63a/image-20230722160021105.png" alt="image-20230722160021105"></p><h3 id="补充-（为什么实际开发不用-select-from-……）"><a href="#补充-（为什么实际开发不用-select-from-……）" class="headerlink" title="补充  （为什么实际开发不用 select * from ……）"></a>补充  （为什么实际开发不用 select * from ……）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">覆盖索引是指，查询使用了索引，返回的列，必须在索引中全部能够找到</span><br><span class="line">但是  select * from 的话必然  要进行回表查询  所以查询效率比较低</span><br></pre></td></tr></table></figure><h3 id="e-g-3"><a href="#e-g-3" class="headerlink" title="e.g"></a>e.g</h3><p><img src="/posts/a981c63a/image-20230722160318754.png" alt="image-20230722160318754"></p><h2 id="索引失效问题"><a href="#索引失效问题" class="headerlink" title="索引失效问题"></a>索引失效问题</h2><h3 id="1-违反了最左前缀法则"><a href="#1-违反了最左前缀法则" class="headerlink" title="1.违反了最左前缀法则"></a>1.<strong>违反了最左前缀法则</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最左前缀法则：</span><br><span class="line">指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则。</span><br></pre></td></tr></table></figure><p><img src="/posts/a981c63a/image-20230723121537774.png" alt="image-20230723121537774"></p><h3 id="2-范围查询右边的列，不能使用索引"><a href="#2-范围查询右边的列，不能使用索引" class="headerlink" title="2.范围查询右边的列，不能使用索引"></a>2.范围查询右边的列，不能使用索引</h3><p><img src="/posts/a981c63a/image-20230723143012977.png" alt="image-20230723143012977"></p><h3 id="3-不要在索引列上进行运算操作，索引将失效"><a href="#3-不要在索引列上进行运算操作，索引将失效" class="headerlink" title="3.不要在索引列上进行运算操作，索引将失效"></a>3.不要在索引列上进行运算操作，索引将失效</h3><p><img src="/posts/a981c63a/image-20230723143246259.png" alt="image-20230723143246259"></p><h3 id="4-字符串不加单引号，造成索引失效（类型转换）"><a href="#4-字符串不加单引号，造成索引失效（类型转换）" class="headerlink" title="4.字符串不加单引号，造成索引失效（类型转换）"></a>4.字符串不加单引号，造成索引失效（类型转换）</h3><p><img src="/posts/a981c63a/image-20230723143732614.png" alt="image-20230723143732614"></p><h3 id="5-模糊查询有可能导致索引失效（以-开头的模糊查询）"><a href="#5-模糊查询有可能导致索引失效（以-开头的模糊查询）" class="headerlink" title="5.模糊查询有可能导致索引失效（以 % 开头的模糊查询）"></a>5.模糊查询有可能导致索引失效（以 % 开头的模糊查询）</h3><p><img src="/posts/a981c63a/image-20230723143953083.png" alt="image-20230723143953083"></p><h3 id="e-g-4"><a href="#e-g-4" class="headerlink" title="e.g"></a>e.g</h3><p><img src="/posts/a981c63a/image-20230723144137791.png" alt="image-20230723144137791"></p><h2 id="SQL的优化"><a href="#SQL的优化" class="headerlink" title="SQL的优化"></a>SQL的优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表的设计优化</span><br><span class="line">索引优化</span><br><span class="line">SQL语句优化</span><br><span class="line">主从复制，读写分离</span><br><span class="line">分库分表</span><br></pre></td></tr></table></figure><h3 id="表的设计优化（参考《阿里巴巴开发手册》（嵩山版））"><a href="#表的设计优化（参考《阿里巴巴开发手册》（嵩山版））" class="headerlink" title="表的设计优化（参考《阿里巴巴开发手册》（嵩山版））"></a>表的设计优化（参考《阿里巴巴开发手册》（嵩山版））</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如设置合适的数值（tinyint int bigint）要根据实际情况选择</span><br><span class="line">比如设置合适的字符串类型（char和varChar）char定长效率高，varChar可变长度，效率稍低</span><br></pre></td></tr></table></figure><h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select语句务必指明字段名称（避免直接使用select *）</span><br><span class="line">SQL语句要避免造成索引失效的写法</span><br><span class="line">尽量用union all 代替union union会多一次过滤，效率低</span><br><span class="line">避免在where子句中对字段进行表达式操作</span><br><span class="line">Join优化能用innerjoin就不用left join  right join 如必须使用一定要小表为驱动</span><br><span class="line">内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边，left join或right join，不会重新调整顺序</span><br></pre></td></tr></table></figure><h3 id="主从复制、读写分离"><a href="#主从复制、读写分离" class="headerlink" title="主从复制、读写分离"></a>主从复制、读写分离</h3><p><img src="/posts/a981c63a/image-20230723154445552.png" alt="image-20230723154445552"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离的架构，读写分离解决的是，数据库的写入，影响了查询的效率</span><br></pre></td></tr></table></figure><h3 id="e-g-5"><a href="#e-g-5" class="headerlink" title="e.g"></a>e.g</h3><p><img src="/posts/a981c63a/image-20230723154852733.png" alt="image-20230723154852733"></p><h2 id="事务（ACID）"><a href="#事务（ACID）" class="headerlink" title="事务（ACID）"></a>事务（ACID）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事务：</span><br><span class="line">事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</span><br></pre></td></tr></table></figure><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</span><br><span class="line">一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</span><br><span class="line">隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</span><br><span class="line">持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</span><br></pre></td></tr></table></figure><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脏读：一个事务读到另一个事务还没有提交的数据。</span><br><span class="line">不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</span><br><span class="line">幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”</span><br></pre></td></tr></table></figure><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p><img src="/posts/a981c63a/image-20230723163939303.png" alt="image-20230723163939303"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务B  读（select）到了事务A还没提交的数据</span><br></pre></td></tr></table></figure><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p><img src="/posts/a981c63a/image-20230723164102215.png" alt="image-20230723164102215"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务A  第一次读（select）到一条数据</span><br><span class="line">事务B 紧接着修改（update）了这条数据并且commit了数据</span><br><span class="line">事务A又一次读到了这条数据</span><br><span class="line">但是事务A 两次查询数据不一样叫做不可重复读</span><br></pre></td></tr></table></figure><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p><img src="/posts/a981c63a/image-20230723164511393.png" alt="image-20230723164511393"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务A 首先查询id为1的数据发现数据库中没有该条数据</span><br><span class="line">事务B 插入一条数据id为1   并且提交到数据库中’</span><br><span class="line">事务A 插入一条数据id为1   但是报错   说数据库中已经有id为1的数据</span><br><span class="line">事务A 又一次查询id为1的数据 但是还是没有查到   </span><br><span class="line">（疑问？    不可重复读中，不是可以查询到事务B中提交的数据么）在幻读中我们的前提就是已经解决了不可重复读的问题</span><br></pre></td></tr></table></figure><h3 id="解决并发事务问题"><a href="#解决并发事务问题" class="headerlink" title="解决并发事务问题"></a>解决并发事务问题</h3><p><img src="/posts/a981c63a/image-20230723165007068.png" alt="image-20230723165007068"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">未提交读：什么也解决不了（不用）</span><br><span class="line">读已提交：解决了脏读</span><br><span class="line">可重复读：解决了脏读和不可重复读（MySQL默认隔离级别）</span><br><span class="line">串行化：解决了所有问题，安全级别最高，但是效率最低（不推荐使用）只有一条事务提交，另外的事务才可以进行操作</span><br></pre></td></tr></table></figure><h4 id="e-g-6"><a href="#e-g-6" class="headerlink" title="e.g"></a>e.g</h4><p><img src="/posts/a981c63a/image-20230723165737796.png" alt="image-20230723165737796"></p><h3 id="事务的隔离性是如何保证的"><a href="#事务的隔离性是如何保证的" class="headerlink" title="事务的隔离性是如何保证的"></a>事务的隔离性是如何保证的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">锁：排他锁（如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁）</span><br><span class="line">mvcc: 多版本并发控制</span><br></pre></td></tr></table></figure><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务实战</title>
      <link href="/posts/a219ce80/"/>
      <url>/posts/a219ce80/</url>
      
        <content type="html"><![CDATA[<h1 id="实战内容"><a href="#实战内容" class="headerlink" title="实战内容"></a>实战内容</h1><h2 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">搭建环境</span><br><span class="line">1.没什么好说的，导入 SQL</span><br><span class="line">2.导入项目</span><br><span class="line">3.nginx 发布前端页面</span><br><span class="line">需要注意的是在 nginx.conf 配置（如下图）</span><br><span class="line">在http&#123;</span><br><span class="line">server&#123;</span><br><span class="line">// 这里写</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">中配置server&#123;</span><br><span class="line">listen  端口号;</span><br><span class="line">server_name  localhost;</span><br><span class="line"></span><br><span class="line">location /&#123;</span><br><span class="line">   root   前端项目路径;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">4.配置 nacos</span><br><span class="line">首先引入依赖</span><br><span class="line">&lt;!--nacos服务注册发现依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">然后在 application.yml 中配置 nacos 的相关配置</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: 服务名称</span><br><span class="line">cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 # nacos地址</span><br><span class="line">5.配置网关服务</span><br><span class="line">新建 gateway 网关模块并引入依赖（同时注册进 nacos 方便拉取2服务）</span><br><span class="line">&lt;!-- Spring Cloud Gateway --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- Nacos 服务注册与发现 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">并在 application.yml 中写入 gateway 相关配置</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 10010</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      default-filters:</span><br><span class="line">        - AddRequestHeader=authorization,2  #往请求中加请求头</span><br><span class="line">      routes:</span><br><span class="line">        - id: userservice</span><br><span class="line">          uri: lb://userservice # 路由的地址，lb，负载均衡</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/user/**,/address/**</span><br><span class="line"></span><br><span class="line">      globalcors: # 全局的跨域处理</span><br><span class="line">        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题</span><br><span class="line"></span><br><span class="line">        corsConfigurations:</span><br><span class="line">          &#x27;[/**]&#x27;:</span><br><span class="line">            allowedOrigins: # 允许哪些网站的跨域请求</span><br><span class="line">              - &quot;http://localhost:9001&quot;</span><br><span class="line">              - &quot;http://localhost:9002&quot;</span><br><span class="line">            allowedMethods: # 允许的跨域ajax的请求方式</span><br><span class="line">              - &quot;GET&quot;</span><br><span class="line">              - &quot;POST&quot;</span><br><span class="line">              - &quot;DELETE&quot;</span><br><span class="line">              - &quot;PUT&quot;</span><br><span class="line">              - &quot;OPTIONS&quot;</span><br><span class="line">            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息</span><br><span class="line">            allowCredentials: true # 是否允许携带cookie</span><br><span class="line">            maxAge: 360000 # 这次跨域检测的有效期</span><br></pre></td></tr></table></figure><p><img src="/posts/a219ce80/image-20230710083244286.png" alt="image-20230710083244286"></p><p><img src="/posts/a219ce80/image-20230710083425232.png" alt="image-20230710083425232"></p><h3 id="1-1-Feign-的远程调用"><a href="#1-1-Feign-的远程调用" class="headerlink" title="1.1 Feign 的远程调用"></a>1.1 Feign 的远程调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.创建 Feign 模块</span><br><span class="line">2.引入 Feign 的依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">3.声明服务的接口 XxxFeignClient</span><br><span class="line">将服务暴露的接口写入其中 路径名、方法名、请求类型、参数类型都要相同</span><br><span class="line">4.在需要远程调用其他接口的服务中引入 Feign 的依赖</span><br><span class="line">自动注入 XxxFeignClient 然后调用方法</span><br></pre></td></tr></table></figure><p><img src="/posts/a219ce80/image-20230710092437011.png" alt="image-20230710092437011"></p><p><img src="/posts/a219ce80/image-20230710092518955.png" alt="image-20230710092518955"></p><h3 id="1-2-网关-Gateway-配置"><a href="#1-2-网关-Gateway-配置" class="headerlink" title="1.2 网关 Gateway 配置"></a>1.2 网关 Gateway 配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">1.创建Gateway模块</span><br><span class="line">2.导入依赖</span><br><span class="line">&lt;!-- Spring Cloud Gateway --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Nacos 服务注册与发现 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.配置 application.yml </span><br><span class="line">server:</span><br><span class="line">  port: 10010</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      default-filters:</span><br><span class="line">        - AddRequestHeader=authorization,2</span><br><span class="line">      routes:</span><br><span class="line">        - id: userservice</span><br><span class="line">          uri: lb://userservice # 路由的地址，lb，负载均衡</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/user/**,/address/**</span><br><span class="line">        - id: orderservice</span><br><span class="line">          uri: lb://orderservice</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/order/**,/pay/**</span><br><span class="line">        - id: itemservice</span><br><span class="line">          uri: lb://itemservice</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/item/**</span><br><span class="line">        - id: searchservice</span><br><span class="line">          uri: lb://searchservice</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/search/**</span><br><span class="line"></span><br><span class="line">      globalcors: # 全局的跨域处理</span><br><span class="line">        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题</span><br><span class="line"></span><br><span class="line">        corsConfigurations:</span><br><span class="line">          &#x27;[/**]&#x27;:</span><br><span class="line">            allowedOrigins: # 允许哪些网站的跨域请求</span><br><span class="line">              - &quot;http://localhost:9001&quot;</span><br><span class="line">              - &quot;http://localhost:9002&quot;</span><br><span class="line">            allowedMethods: # 允许的跨域ajax的请求方式</span><br><span class="line">              - &quot;GET&quot;</span><br><span class="line">              - &quot;POST&quot;</span><br><span class="line">              - &quot;DELETE&quot;</span><br><span class="line">              - &quot;PUT&quot;</span><br><span class="line">              - &quot;OPTIONS&quot;</span><br><span class="line">            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息</span><br><span class="line">            allowCredentials: true # 是否允许携带cookie</span><br><span class="line">            maxAge: 360000 # 这次跨域检测的有效期</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-配置-ES-客户端"><a href="#1-3-配置-ES-客户端" class="headerlink" title="1.3 配置 ES 客户端"></a>1.3 配置 ES 客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.引入依赖</span><br><span class="line"></span><br><span class="line">&lt;!--elasticsearch--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">2.编写配置类</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class ElasticsearchConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestHighLevelClient restHighLevelClient() &#123;</span><br><span class="line">        return new RestHighLevelClient(RestClient.builder(</span><br><span class="line">                HttpHost.create(&quot;http://192.168.150.105:9200&quot;)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后在其他地方</span><br><span class="line">@Autowired</span><br><span class="line">private RestHighLevelClient restHighLevelClient;</span><br><span class="line">注入</span><br></pre></td></tr></table></figure><h3 id="1-4-配置RabbitMQ"><a href="#1-4-配置RabbitMQ" class="headerlink" title="1.4 配置RabbitMQ"></a>1.4 配置RabbitMQ</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. 引入依赖</span><br><span class="line">&lt;!--amqp--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">2.编写MQ的监听（将交换机和队列进行绑定，基于注解方式）</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class ItemLinstter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SearchService searchService;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">            exchange = @Exchange(name = MqConstants.HMALL_EXCHANGE, type = ExchangeTypes.TOPIC),</span><br><span class="line">            value = @Queue(name = MqConstants.HMALL_INSERT_QUEUE),</span><br><span class="line">            key = &#123;MqConstants.HMALL_INSERT_KEY&#125;</span><br><span class="line">    ))</span><br><span class="line">    public void linsterIemUp(Long id) &#123;</span><br><span class="line">        searchService.saveItemById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">            value = @Queue(name = MqConstants.HMALL_DELETTE_QUEUE),</span><br><span class="line">            exchange = @Exchange(name = MqConstants.HMALL_EXCHANGE, type = ExchangeTypes.TOPIC),</span><br><span class="line">            key = &#123;MqConstants.HMALL_DELETE_KEY&#125;</span><br><span class="line">    ))</span><br><span class="line">    public void linsterIemDown(Long id) &#123;</span><br><span class="line">        searchService.deleteItemById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-商品管理服务"><a href="#2-商品管理服务" class="headerlink" title="2.商品管理服务"></a>2.商品管理服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">今天没什么好写的，因为用了 MP 框架</span><br><span class="line">对于单表的增删改查很容易</span><br><span class="line">要注意</span><br><span class="line">在 XxxMapper 的接口上要 extends BaseMapper&lt;实体类名&gt;</span><br><span class="line">（数据库的实体类映射）</span><br><span class="line">在 XxxService 的接口上是 extends IService&lt;实体类名&gt;</span><br><span class="line">在 XxxServiceImpl 的实现类上是 extends ServiceImpl&lt;XxxMapper,实体类&gt; 并且同时 implements XxxService</span><br></pre></td></tr></table></figure><p><img src="/posts/a219ce80/image-20230710084856174.png" alt="image-20230710084856174"></p><p><img src="/posts/a219ce80/image-20230710084913048.png" alt="image-20230710084913048"></p><p><img src="/posts/a219ce80/image-20230710084925142.png" alt="image-20230710084925142"></p><h2 id="3-搜索业务"><a href="#3-搜索业务" class="headerlink" title="3.搜索业务"></a>3.搜索业务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">上强度开始</span><br><span class="line">1.创建索引库</span><br><span class="line">首先根据数据库表结构设计出 ES 的索引表结构</span><br><span class="line">其中设计了后边要用的关键字搜索 </span><br><span class="line">设计了 all 字段，参与搜索</span><br><span class="line">&quot;all&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;text_analyzer&quot;,</span><br><span class="line">        &quot;search_analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    在其他字段下 写  ”copy_to“: &quot;all&quot;</span><br><span class="line">    使其他字段在查询的时候参与查询</span><br><span class="line">    同时还设置了 py 分词器，以便在搜索框搜索的时候可以使用拼音搜索</span><br><span class="line">    </span><br><span class="line">2.导入数据</span><br><span class="line">大体思路就是</span><br><span class="line">2.1将其他服务写好的查询数据库的全部数据的接口暴露给 Feign</span><br><span class="line">2.2然后在需要导入数据的服务中引入 Feign 的依赖</span><br><span class="line">2.3调用 Feign 的接口（Feign如何操作见1.1模块）</span><br><span class="line">2.4通过 RestHighLevelClient 给 ES 发送请求 （配置见1.3）</span><br><span class="line">3.关键字搜索</span><br><span class="line">// 1.创建请求对象</span><br><span class="line">    SearchRequest request = new SearchRequest(&quot;hmall&quot;);</span><br><span class="line">    // 2.多个条件判断</span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    // key健壮性判断</span><br><span class="line">    if (StringUtils.isNotEmpty(params.getKey())) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(&quot;all&quot;, params.getKey()));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125;</span><br><span class="line">   ……</span><br><span class="line">   // 其他条件的判断</span><br><span class="line">   ……</span><br><span class="line">   // 3.发送请求</span><br><span class="line">   SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">   // 4.解析数据</span><br><span class="line">   …… 固定套路（剥洋葱）……</span><br><span class="line"></span><br><span class="line">4.过滤查询</span><br><span class="line">聚合操作通常包括以下几个步骤：</span><br><span class="line">1.创建一个 SearchRequest 对象，指定要执行聚合的索引和类型。</span><br><span class="line">2.构建查询条件（如果需要），可以使用 QueryBuilders 类提供的方法创建各种类型的查询条件。</span><br><span class="line">3.创建一个 AggregationBuilder 对象，指定要执行的聚合类型和聚合字段。</span><br><span class="line">4.将聚合对象添加到 SearchRequest 对象中的 AggregationBuilder 列表中。</span><br><span class="line">5.执行搜索请求，将 SearchRequest 对象传递给 Elasticsearch 客户端的 search 方法。</span><br><span class="line">6.从 SearchResponse 对象中提取聚合结果。</span><br><span class="line">5.销量和价格排序</span><br><span class="line">// 排序</span><br><span class="line">    String sortBy = params.getSortBy();</span><br><span class="line">    if (&quot;sold&quot;.equals(sortBy))&#123;</span><br><span class="line">        request.source().sort(sortBy, SortOrder.DESC);</span><br><span class="line">    &#125;else if (&quot;price&quot;.equals(sortBy))&#123;</span><br><span class="line">        request.source().sort(sortBy, SortOrder.ASC);</span><br><span class="line">    &#125;</span><br><span class="line">    // 发送请求</span><br><span class="line">    client.search(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure><p><img src="/posts/a219ce80/image-20230710085209091.png" alt="image-20230710085209091"></p><p><img src="/posts/a219ce80/image-20230710085236250.png" alt="image-20230710085236250"></p><p><img src="/posts/a219ce80/image-20230710090109319.png" alt="image-20230710090109319"></p><h3 id="3-1数据同步"><a href="#3-1数据同步" class="headerlink" title="3.1数据同步"></a>3.1数据同步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基于 RabbitMQ 实现数据库 elasticsearch 的数据同步，要求如下：</span><br><span class="line">ES配置见1.3</span><br><span class="line">RabbitMQ配置见1.4</span><br><span class="line">- 商品上架时：search-service新增商品到elasticsearch</span><br><span class="line">- 商品下架时：search-service删除elasticsearch中的商品</span><br></pre></td></tr></table></figure><p><img src="/posts/a219ce80/image-20230710120135885.png" alt="image-20230710120135885"></p><h2 id="4-登录信息获取"><a href="#4-登录信息获取" class="headerlink" title="4.登录信息获取"></a>4.登录信息获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>网关配置(见<span class="number">1.2</span>)</span><br><span class="line"><span class="number">2.</span>在 application.yml 中添加如下配置</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      <span class="keyword">default</span>-filters:</span><br><span class="line">        - AddRequestHeader=authorization,<span class="number">2</span></span><br><span class="line"><span class="number">3.</span>在服务中编写拦截器</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 拦截器类，在WebMvc中添加了拦截规则之后，前置拦截请求，添加请求头</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span>  </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 前置拦截</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String authorizationHeader = request.getHeader(&quot;authorization&quot;);</span></span><br><span class="line">        <span class="comment">// 在这里使用authorization头进行相应的处理</span></span><br><span class="line">        String userID = request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        MyThreadLocal.setUserId(userID);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>编写拦截器配置类并将拦截器注册到容器中</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 需要将拦截器注册到MVC中</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthorizationInterceptor authorizationInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(authorizationInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-Feign-的请求头"><a href="#4-1-Feign-的请求头" class="headerlink" title="4.1 Feign 的请求头"></a>4.1 Feign 的请求头</h3><p><img src="/posts/a219ce80/image-20230710121258644.png" alt="image-20230710121258644"></p><p><img src="/posts/a219ce80/image-20230710121318486.png" alt="image-20230710121318486"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这两段代码是用于配置和添加自定义的 Feign 拦截器。</span><br><span class="line"></span><br><span class="line">首先，FeignInterceptor 是一个实现了 RequestInterceptor 接口的拦截器类。在 apply 方法中，我们可以对请求进行一些自定义操作，比如添加请求头信息。通过调用 template.header(&quot;authorization&quot;,&quot;2&quot;) 方法，向请求添加了一个名为 &quot;authorization&quot; 的请求头，值为&quot;2&quot;。</span><br><span class="line"></span><br><span class="line">接下来，FeignConfig 是一个配置类，用于配置 Feign 客户端的一些参数和属性。通过使用 @EnableFeignClients 注解指定了 Feign 客户端的基础包路径，告诉 Spring Boot 在哪些包下寻找 Feign 客户端接口进行代理。</span><br><span class="line"></span><br><span class="line">在 FeignConfig 中，通过使用 @Bean 注解来声明一个名为 feignInterceptor 的 Bean ，该 Bean 是 FeignInterceptor 类型的实例。这样，SpringBoot 会自动将该拦截器添加到 Feign 的拦截器链中，使其生效。</span><br><span class="line"></span><br><span class="line">通过这样的配置和自定义拦截器，我们可以在Feign客户端发送请求前进行一些预处理操作，比如添加认证信息、日志记录等。</span><br></pre></td></tr></table></figure><h2 id="5-用户服务"><a href="#5-用户服务" class="headerlink" title="5.用户服务"></a>5.用户服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略~~~</span><br></pre></td></tr></table></figure><h2 id="6-订单服务"><a href="#6-订单服务" class="headerlink" title="6.订单服务"></a>6.订单服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">创建订单业务比较复杂，流程如下：</span><br><span class="line"></span><br><span class="line">- 1）根据雪花算法生成订单 id</span><br><span class="line">因为导入了 MP 所以有</span><br><span class="line">    @TableId(type = IdType.ASSIGN_ID)</span><br><span class="line">或者网上搜一个雪花算法的工具类掉方法</span><br><span class="line"></span><br><span class="line">- 2）商品微服务提供 FeignClient ，实现根据 id 查询商品的接口</span><br><span class="line">将 ItemService 中的根据 id 获取对象的接口暴露给 Feign 通过(1.1 Feign 的远程调用实现)</span><br><span class="line"></span><br><span class="line">- 3）根据 itemId 查询商品信息</span><br><span class="line">// 1.根据 id 查询出商品信息</span><br><span class="line">    Item item = itemFeignClient.selectById(params.getItemId());</span><br><span class="line">    </span><br><span class="line">- 4）基于商品价格、购买数量计算商品总价：totalFee</span><br><span class="line"></span><br><span class="line">- 5）封装 Order 对象，初识 status 为未支付</span><br><span class="line">Order.setXxx();</span><br><span class="line"></span><br><span class="line">- 6）将 Order 写入数据库 tb_order 表中</span><br><span class="line">save(order);</span><br><span class="line"></span><br><span class="line">- 7）将商品信息、orderId 信息封装为 OrderDetail 对象，写入 tb_order_detail 表</span><br><span class="line">orderDetail.setXxx();</span><br><span class="line">save(orderDetail);</span><br><span class="line"></span><br><span class="line">- 8）将 user-service 的根据id查询地址接口封装为 FeignClient</span><br><span class="line">通过(1.1 Feign 的远程调用实现)</span><br><span class="line"></span><br><span class="line">- 9）根据 addressId 查询 user-service 服务，获取地址信息</span><br><span class="line">同上……</span><br><span class="line">- 10）将地址封装为 OrderLogistics 对象，写入 tb_order_logistics 表</span><br><span class="line">同上……</span><br><span class="line">- 11）在 item-service 提供减库存接口，并编写 FeignClient</span><br><span class="line">同上……</span><br><span class="line">- 12）调用 item-service 的减库存接口</span><br><span class="line">同上……</span><br></pre></td></tr></table></figure><h3 id="6-1-清理超时未支付订单"><a href="#6-1-清理超时未支付订单" class="headerlink" title="6.1 清理超时未支付订单"></a>6.1 清理超时未支付订单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>原计划用延迟队列，但是突发奇想，想看看 SpringTask 可不可以实现，以下是对 SpringTask 的尝试</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建 SpringTask 的模块</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>引入 SpringTask 的起步依赖</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>启动类上添加<span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>：启动定时任务，放在启动类的上面</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;OrderFeignClient.class&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskSpringBootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TaskSpringBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>编写业务代码(欠缺考虑增加库存数量)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScheduledTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderFeignClient orderFeignClient;</span><br><span class="line">    <span class="comment">// 优化性能 用计数器来 控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 10000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Order&gt; orderList = orderFeignClient.getOrderList();</span><br><span class="line">        Date currentTime = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">            Date createTime = order.getCreateTime();</span><br><span class="line">            Calendar calendar = Calendar.getInstance();</span><br><span class="line">            calendar.setTime(createTime);</span><br><span class="line">            calendar.add(Calendar.MINUTE, <span class="number">30</span>);</span><br><span class="line">            Date targetTime = calendar.getTime();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isPast30Minutes = currentTime.after(targetTime);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isPast30Minutes) &#123;</span><br><span class="line">                <span class="comment">// 执行支付状态更改逻辑</span></span><br><span class="line">                orderFeignClient.updateOrder(order.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counter = <span class="number">0</span>; <span class="comment">// 重置计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-贴心小贴士"><a href="#7-贴心小贴士" class="headerlink" title="7.贴心小贴士"></a>7.贴心小贴士</h2><p>(<a href="https://chat-shared2.zhile.io/shared.html?v=2">Shared Chat (zhile.io)</a> “好东西”)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP笔记</title>
      <link href="/posts/fd57f765/"/>
      <url>/posts/fd57f765/</url>
      
        <content type="html"><![CDATA[<h1 id="事务管理-amp-AOP笔记"><a href="#事务管理-amp-AOP笔记" class="headerlink" title="事务管理&amp;AOP笔记"></a>事务管理&amp;AOP笔记</h1><h2 id="Spring事务管理（-Transactional）"><a href="#Spring事务管理（-Transactional）" class="headerlink" title="Spring事务管理（@Transactional）"></a>Spring事务管理（@Transactional）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">注解：</span><br><span class="line">@Transactional</span><br><span class="line">位置：</span><br><span class="line">业务(Service)层的方法上、类上、接口上</span><br><span class="line">作用：</span><br><span class="line">将当前方法交给Spring进行事务管理、方法执行前、开启事务;</span><br><span class="line">成功执行完毕，提交事务：</span><br><span class="line">出现异常，回滚事务；</span><br><span class="line"></span><br><span class="line">开启Spring事务管理日志：</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org.springframework.jdbc.support.JdbcTransactionManager: debug</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事务属性-回滚（rollbackFor）"><a href="#事务属性-回滚（rollbackFor）" class="headerlink" title="事务属性-回滚（rollbackFor）"></a>事务属性-回滚（rollbackFor）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认情况下：</span><br><span class="line">只有出现RuntimeException才回滚异常</span><br><span class="line"></span><br><span class="line">rollbackFor属性用于控制出现何种异常类型，回滚事务</span><br><span class="line"></span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br></pre></td></tr></table></figure><h3 id="事务属性-传播（propagation）"><a href="#事务属性-传播（propagation）" class="headerlink" title="事务属性-传播（propagation）"></a>事务属性-传播（propagation）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">事务传播行为：</span><br><span class="line">值的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制</span><br><span class="line">加入：</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)  默认值需要事务，有则加入，无则创建新事务</span><br><span class="line">新建：</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRES_NEW)  需要新事务，不管有没有，总是创建新事物</span><br></pre></td></tr></table></figure><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AOP：</span><br><span class="line">Aspect Oriented Progaramming(面向切面编程)  ，就是面向特定方法进行编程</span><br></pre></td></tr></table></figure><h3 id="AOP快速入门"><a href="#AOP快速入门" class="headerlink" title="AOP快速入门"></a>AOP快速入门</h3><h4 id="1-在pom-xml中导入依赖"><a href="#1-在pom-xml中导入依赖" class="headerlink" title="1.在pom.xml中导入依赖"></a>1.在pom.xml中导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-编写AOP程序：针对于特定方法根据业务需要进行编程"><a href="#2-编写AOP程序：针对于特定方法根据业务需要进行编程" class="headerlink" title="2.编写AOP程序：针对于特定方法根据业务需要进行编程"></a>2.编写AOP程序：针对于特定方法根据业务需要进行编程</h4><h3 id="AOP使用场景及优势"><a href="#AOP使用场景及优势" class="headerlink" title="AOP使用场景及优势"></a>AOP使用场景及优势</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">场景：</span><br><span class="line">记录操作日志</span><br><span class="line">权限控制</span><br><span class="line">事务管理</span><br><span class="line"></span><br><span class="line">优势：</span><br><span class="line">代码无侵入</span><br><span class="line">减少重复代码</span><br><span class="line">提高开发效率</span><br><span class="line">维护方便</span><br></pre></td></tr></table></figure><h3 id="AOP核心概念！！！"><a href="#AOP核心概念！！！" class="headerlink" title="AOP核心概念！！！"></a>AOP核心概念！！！</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">连接点：</span><br><span class="line">JoinPoint，可以被AOP控制的方法</span><br><span class="line">通知：</span><br><span class="line">Advice，指哪些重复的逻辑，也就是共性的功能</span><br><span class="line">切入点：</span><br><span class="line">PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用</span><br><span class="line">切面：</span><br><span class="line">Aspect，通知+切入点（描述通知与切入点的对应关系）</span><br><span class="line">目标对象：</span><br><span class="line">Target，通知所应用的对象</span><br></pre></td></tr></table></figure><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Around:</span><br><span class="line">环绕通知，此注解标注的通知方法在目标方法前，后都被执行（方法的前后）</span><br><span class="line"></span><br><span class="line">@Around的注意事项：</span><br><span class="line">@Around环绕通知需要自己调用ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法执行</span><br><span class="line">@Around环绕通知方法的返回值，必须指定为object，来接受原始方法的返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Before(前置通知)</span><br><span class="line">@After(后置通知)</span><br><span class="line">@Around(环绕通知！！！重点)</span><br><span class="line">@AfterReturning(返回后通知，了解)</span><br><span class="line">@AfterThrowing(异常后通知，了解)</span><br></pre></td></tr></table></figure><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">切入点表达式：</span><br><span class="line">描述切入点方法的一种表达式</span><br><span class="line">作用：</span><br><span class="line">主要用来决定项目中的那些方法需要加入通知</span><br><span class="line">常见形式：</span><br><span class="line">execution(...):根据方法的签名来匹配</span><br><span class="line">@annotation(...):根据注解匹配</span><br></pre></td></tr></table></figure><h3 id="PointCut"><a href="#PointCut" class="headerlink" title="@PointCut"></a>@PointCut</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可</span><br><span class="line"><span class="meta">@PointCut(&quot;execution(* com.itheima.service.impl.Xxximpl.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pt</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">recordTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 记录、笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot注解总结</title>
      <link href="/posts/2d62ae04/"/>
      <url>/posts/2d62ae04/</url>
      
        <content type="html"><![CDATA[<h1 id="注解总结"><a href="#注解总结" class="headerlink" title="注解总结"></a>注解总结</h1><h2 id="1-把对象放到Spring容器中"><a href="#1-把对象放到Spring容器中" class="headerlink" title="1. 把对象放到Spring容器中"></a>1. 把对象放到Spring容器中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Controller</span><br><span class="line">@Service</span><br><span class="line">@Repository</span><br><span class="line">@Bean：管理第三方bean，把当前方法返回值放到Spring容器中</span><br><span class="line">@Scope：设置bean作用范围</span><br></pre></td></tr></table></figure><h2 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired 按类型装配</span><br><span class="line"></span><br><span class="line">@Qualifier 按名称装配，必须和@Autowired配合使用</span><br><span class="line"></span><br><span class="line">@Resource 按名称装配，如果按名称找不到就按类型</span><br></pre></td></tr></table></figure><h2 id="3-配置类注解"><a href="#3-配置类注解" class="headerlink" title="3. 配置类注解"></a>3. 配置类注解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration：表明此类是一个配置类，Spring的注解</span><br><span class="line">@Import：把配置类或bean导入Spring容器中，</span><br><span class="line">@Value：读取配置文件中的单个值</span><br><span class="line">@ConfigurationProperties(prefix=&quot;&quot;)  读取配置文件中的值到实体类中 批量读取属性</span><br><span class="line">@SpringBootApplication：Springboot核心注解</span><br><span class="line">@SpringBootConfiguration：表明此类是一个SpringBoot配置类，SpringBoot的注解</span><br><span class="line">@ComponentScan：配置路径扫描</span><br><span class="line">@EnableAutoConfiguration：自动配置</span><br></pre></td></tr></table></figure><h2 id="4-请求与响应"><a href="#4-请求与响应" class="headerlink" title="4. 请求与响应"></a>4. 请求与响应</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController = @Controller + @ResponseBody</span><br><span class="line">@RequestMapping ：请求路径</span><br><span class="line">@PostMapping：请求方式为post，并设置请求路径，用于新增操作</span><br><span class="line">@PutMapping：请求方式为put，并设置请求路径，用于修改操作</span><br><span class="line">@DeleteMapping：请求方式为delete，并设置请求路径，用于删除操作</span><br><span class="line">@GetMapping：请求方式为get，并设置请求路径，用于查询操作</span><br><span class="line">@RequestParams：请求参数和形参不一致时使用</span><br><span class="line">@RequestBody：接收json传参</span><br><span class="line">@ResponseBody：把当前方法返回值放到响应体中，如果返回值是实体类，则自动转换为json类型数据</span><br><span class="line">@DateTimeFormat：接收日期类型传参</span><br></pre></td></tr></table></figure><h2 id="5-过滤器、全局异常处理器"><a href="#5-过滤器、全局异常处理器" class="headerlink" title="5. 过滤器、全局异常处理器"></a>5. 过滤器、全局异常处理器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">过滤器</span><br><span class="line">@WebFilter(urlPatterns=&quot;&quot;)：配置过滤器过滤的路径</span><br><span class="line">@ServletComponentScan：开启Servlet组件扫描</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全局异常处理器</span><br><span class="line">@RestControllerAdvice：放在类上，标明此类是一个异常处理器类</span><br><span class="line">@ExceptionHandler(Exception.class)：放在方法上，指定当前方法捕获哪一类异常</span><br></pre></td></tr></table></figure><h2 id="6-AOP及事务"><a href="#6-AOP及事务" class="headerlink" title="6. AOP及事务"></a>6. AOP及事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AOP</span><br><span class="line">@Aspect：代表当前类是aop类</span><br><span class="line">@PointCut：切点表达式注解</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通知</span><br><span class="line">前置通知：@Before</span><br><span class="line">后置通知：@After</span><br><span class="line">环绕通知：@Around</span><br><span class="line">返回后通知：@AfterReturning</span><br><span class="line">异常后通知：@AfterThrowing</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事务</span><br><span class="line">@Transational：事务注解</span><br></pre></td></tr></table></figure><h2 id="7-Mybatis及MybatisPlus"><a href="#7-Mybatis及MybatisPlus" class="headerlink" title="7. Mybatis及MybatisPlus"></a>7. Mybatis及MybatisPlus</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Insert</span><br><span class="line">@Delete</span><br><span class="line">@Update</span><br><span class="line">@Select</span><br><span class="line"></span><br><span class="line">@TableId：设置主键生成策略</span><br><span class="line">@TableLogic：逻辑删除</span><br><span class="line">@Version：版本号</span><br><span class="line"></span><br><span class="line">@TableName：设置数据库表名字</span><br><span class="line">@TableField(value=&quot;&quot;,select=&quot;&quot;,exist=&quot;&quot;) </span><br><span class="line">value：设置表字段和实体类字段映射</span><br><span class="line">select：设置不查询表中某字段</span><br><span class="line">exist：设置实体类中字段在表中不存在</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据库</title>
      <link href="/posts/eb52a7b2/"/>
      <url>/posts/eb52a7b2/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h2><p><img src="/posts/eb52a7b2/qwe.png"></p><h3 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET key value  设置指定key的值</span><br><span class="line">GET key    获取指定key的值</span><br><span class="line">SETEX key seconds value设置指定key的值，并将key的过期时间设置为seconds秒</span><br><span class="line">SETNX key value只有在key不存在时，设置keyd</span><br></pre></td></tr></table></figure><h3 id="哈希操作命令"><a href="#哈希操作命令" class="headerlink" title="哈希操作命令"></a>哈希操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象，常用命令</span><br><span class="line"></span><br><span class="line">HSET key field value 将哈希表key中的字段field的值设为value</span><br><span class="line">HGET key field 获取存储在哈希表中指定字段的值</span><br><span class="line">HDEL key field 删除存储在哈希表中的指定字段</span><br><span class="line">HKEYS key    获取哈希表中所有字段</span><br><span class="line">HVALS key    获取哈希表中所有值</span><br></pre></td></tr></table></figure><h3 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Redis列表是简单的字符串列表，按照插入顺序排序，常用命令</span><br><span class="line"></span><br><span class="line">LPUSH key value1 [value2]  将一个或多个值插入到列表头部</span><br><span class="line">LRANGE key start stop    获取列表指定范围内的元素</span><br><span class="line">RPOP key    移除并获取列表最后一个元素</span><br><span class="line">LLEN key   获取列表长度</span><br></pre></td></tr></table></figure><h3 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Redis set是string类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据，常用命令</span><br><span class="line"></span><br><span class="line">SADD key member1 [member2]向集合添加一个或多个成员</span><br><span class="line">SMEMBERS key返回集合中所有的成员</span><br><span class="line">SCARD key获取集合的成员数</span><br><span class="line">SINTER key1 [key2]返回给定所有集合的交集</span><br><span class="line">SUNION key1 [key2]返回所有给定集合的并集</span><br><span class="line">SREM key member1 [member2]删除集合中一个或多个成员</span><br></pre></td></tr></table></figure><h3 id="有序集合操作命令"><a href="#有序集合操作命令" class="headerlink" title="有序集合操作命令"></a>有序集合操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Redis有序集合是string类型元素的集合，且不允许有重复成员，每个元素都会关联一个double类型的分数，常用命令</span><br><span class="line"></span><br><span class="line">ZADD key score1 member1 [score2 member2]向有序集合添加一个或多个成员</span><br><span class="line">ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合中指定区间内的成员</span><br><span class="line">ZINCRBY key increament member有序集合中对指定成员的分数加上增量increment</span><br><span class="line">ZREM key member [member……]移除有序集合中的一个或多个成员</span><br></pre></td></tr></table></figure><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Redis的通用命令是不分数据类型的，都可以使用的命令</span><br><span class="line"></span><br><span class="line">KEYS pattern 查找所有符合给定模式(pattern)的key</span><br><span class="line">EXISTS key 检查给定key是否存在</span><br><span class="line">TYPE key返回key所存储的值的类型</span><br><span class="line">DEL key 该命令用于在key存在时删除key</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试题</title>
      <link href="/posts/489ef953/"/>
      <url>/posts/489ef953/</url>
      
        <content type="html"><![CDATA[<h3 id="面试题1：如果别人给我了一个项目，都已经打成jar包了（没有提供源码），发现其中的一项参数不对，能不能在外部直接修改项目配置项的内容，如何实现？"><a href="#面试题1：如果别人给我了一个项目，都已经打成jar包了（没有提供源码），发现其中的一项参数不对，能不能在外部直接修改项目配置项的内容，如何实现？" class="headerlink" title="面试题1：如果别人给我了一个项目，都已经打成jar包了（没有提供源码），发现其中的一项参数不对，能不能在外部直接修改项目配置项的内容，如何实现？"></a>面试题1：如果别人给我了一个项目，都已经打成jar包了（没有提供源码），发现其中的一项参数不对，能不能在外部直接修改项目配置项的内容，如何实现？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当然可以</span><br><span class="line">java -Dserver.port=9000 jar jar包  --server.port=9001</span><br></pre></td></tr></table></figure><h3 id="面试题2：Spring容器中的bean对象是什么时候创建的-？-包括-默认单例-以及-非单例"><a href="#面试题2：Spring容器中的bean对象是什么时候创建的-？-包括-默认单例-以及-非单例" class="headerlink" title="面试题2：Spring容器中的bean对象是什么时候创建的 ？[包括: 默认单例 以及 非单例]"></a>面试题2：Spring容器中的bean对象是什么时候创建的 ？[包括: 默认单例 以及 非单例]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单例作用域（Singleton）</span><br><span class="line">对于默认的单例作用域，Spring容器在启动时会创建并初始化所有单例的Bean对象</span><br><span class="line"></span><br><span class="line">非单例作用域（Prototype）</span><br><span class="line">对于非单例作用域，Spring容器在接收到相应的请求时，才会创建新的Bean实例</span><br></pre></td></tr></table></figure><h3 id="面试题3：简单聊聊你对SpringBoot框架的理解-x2F-SpringBoot自动配置的原理是什么"><a href="#面试题3：简单聊聊你对SpringBoot框架的理解-x2F-SpringBoot自动配置的原理是什么" class="headerlink" title="面试题3：简单聊聊你对SpringBoot框架的理解 &#x2F; SpringBoot自动配置的原理是什么?"></a>面试题3：简单聊聊你对SpringBoot框架的理解 &#x2F; SpringBoot自动配置的原理是什么?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于SpringBoot框架的理解：</span><br><span class="line">SpringBooot就是基于Spring Framework的一款开源框架，简化了项目的开发，最大特点就是有AOP以及IOC，极大程度的简化了，应用的开发，秉承着约定大于配置的原则，使程序员不用在关心各种各样的配置，而专心写业务逻辑。</span><br><span class="line"></span><br><span class="line">对于SpringBoot自动配置的原理：</span><br><span class="line">说到SpringBoot的自动配置，我想到了一个注解@EnableAutoConfiguration，这个注解底层封装了一个@import注解，通过import来导入指定的Bean或者配置类，这个注解导入了AutoConfigurationImportSelector他是ImportSelector的实现类，这个importSelector接口中有一个selectImports方法返回一个String[]数组（那些类需要导入到IOC容器当中，里边封装的就是这些类的全类名）</span><br><span class="line">META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports </span><br><span class="line">META-INF/spring.factories</span><br></pre></td></tr></table></figure><h3 id="面试题4：SpringBoot框架与Spring-Framework的关系能详细的描述一下吗-为什么现在项目开发都基于SpringBoot进行"><a href="#面试题4：SpringBoot框架与Spring-Framework的关系能详细的描述一下吗-为什么现在项目开发都基于SpringBoot进行" class="headerlink" title="面试题4：SpringBoot框架与Spring Framework的关系能详细的描述一下吗? 为什么现在项目开发都基于SpringBoot进行 ?"></a>面试题4：SpringBoot框架与Spring Framework的关系能详细的描述一下吗? 为什么现在项目开发都基于SpringBoot进行 ?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringBooot就是基于Spring Framework的一款开源框架，简化了项目的开发，最大特点就是有AOP以及IOC，极大程度的简化了应用的开发，秉承着约定大于配置的原则，使程序员不用在关心各种各样的配置，而专心写业务逻辑的代码。</span><br></pre></td></tr></table></figure><h3 id="面试题5：有没有在项目中自己定义过-starter，如果让你来定义starter，能描述下大概的思路吗？"><a href="#面试题5：有没有在项目中自己定义过-starter，如果让你来定义starter，能描述下大概的思路吗？" class="headerlink" title="面试题5：有没有在项目中自己定义过 starter，如果让你来定义starter，能描述下大概的思路吗？"></a>面试题5：有没有在项目中自己定义过 starter，如果让你来定义starter，能描述下大概的思路吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 确定功能和用途：确定Starter要提供的功能和用途。可以根据项目的需求或特定领域的需求来定义功能范围。</span><br><span class="line"></span><br><span class="line">2. 定义核心依赖：确定Starter的核心依赖，这些依赖将作为应用程序使用该Starter时需要引入的依赖。</span><br><span class="line"></span><br><span class="line">3. 编写自动配置：编写自动配置类，为Starter提供默认的配置和功能。在自动配置类中，可以使用条件化配置来决定是否应用配置。</span><br><span class="line"></span><br><span class="line">4. 定义配置属性：定义一组配置属性，让使用者可以通过配置文件或其他方式进行自定义。可以使用Spring Boot的配置属性注解来定义和绑定配置属性。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE阶段笔记</title>
      <link href="/posts/737a1d7/"/>
      <url>/posts/737a1d7/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="定义类的补充注意事项"><a href="#定义类的补充注意事项" class="headerlink" title="定义类的补充注意事项"></a>定义类的补充注意事项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javabean类：</span><br><span class="line">用来描述一类事物的类，在javabean类中，是不写main方法的</span><br><span class="line">标准的javabean类：</span><br><span class="line">类名需要见名知意</span><br><span class="line">成员变量需要用<span class="keyword">private</span>修饰</span><br><span class="line">提供至少两个构造方法</span><br><span class="line">无参构造</span><br><span class="line">带全部参数的构造方法</span><br><span class="line">成员方法</span><br><span class="line">提供每一个成员变量对应的setXxx()和getXxx()</span><br><span class="line">如果还有其他行为，也需要写上</span><br><span class="line"></span><br><span class="line">测试类：</span><br><span class="line">在以前编写main方法的类，我们可以在测试类中创建javabean类的对象进行赋值调用</span><br><span class="line"></span><br><span class="line">成员变量的完整定义格式：修饰符 数据类型 变量名称 = 初始化值，一般无需定义初始化值，存在默认值</span><br></pre></td></tr></table></figure><h2 id="面向对象三大特征（封装-继承-多态）"><a href="#面向对象三大特征（封装-继承-多态）" class="headerlink" title="面向对象三大特征（封装   继承    多态）"></a>面向对象三大特征（封装   继承    多态）</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">告诉我们如何正确的设计对象的属性和方法</span><br><span class="line">对象代表什么，就得封装对应的数据，并提供数据对应的行为</span><br><span class="line">例如：</span><br><span class="line">需求：人画圆，请针对这个需求进行面向对象的设计</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系。（java只支持单继承，不支持多继承，但是支持多层继承）</span><br><span class="line">    每一个类都直接或间接的继承<span class="function">Object</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Student extends <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">Student称为子类，Person称为父类</span><br><span class="line">    </span><br><span class="line">使用继承的好处</span><br><span class="line">    可以把多个子类重复的代码抽取到父类中，提高了代码的复用性</span><br><span class="line">    子类可以在父类的基础上，增加其他的共能，是子类更强大。</span><br><span class="line">    </span><br><span class="line">什么时候用继承</span><br><span class="line">    当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码。</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">什么是多态？</span><br><span class="line">同类型的对象，表现出的不同的形态。</span><br><span class="line"></span><br><span class="line">多态的表现形式</span><br><span class="line">父类类型 对象名称 = 子类对象;</span><br><span class="line"></span><br><span class="line">多态的前提</span><br><span class="line">有继承/实现（接口）关系</span><br><span class="line">有父类引用指向子类对象</span><br><span class="line">有方法重写</span><br><span class="line"></span><br><span class="line">多态的好处</span><br><span class="line">使用父类型作为参数，可以接收所有的子类对象，体现多态的扩展与便利 </span><br><span class="line">在多态形式下，右边对象可以实现解耦合，便于扩展和维护</span><br><span class="line"></span><br><span class="line">多态的弊端</span><br><span class="line">不能使用子类独有的方法</span><br><span class="line">解决方法</span><br><span class="line">转换成真正的子类类型，从而调用子类独有的功能</span><br><span class="line">转换类型与真实对象类型不一致会报错</span><br><span class="line">转换时用instanceof关键字进行判断</span><br><span class="line"></span><br><span class="line">调用成员变量的特点：</span><br><span class="line">编译看左边，运行也看左边</span><br><span class="line">调用成员方法的特点：</span><br><span class="line">编译看左边，运行看右边</span><br></pre></td></tr></table></figure><h2 id="关键字还有修饰符"><a href="#关键字还有修饰符" class="headerlink" title="关键字还有修饰符"></a>关键字还有修饰符</h2><h3 id="private-lt-空着不写-lt-protected-lt-public"><a href="#private-lt-空着不写-lt-protected-lt-public" class="headerlink" title="private &lt; 空着不写 &lt; protected &lt; public"></a>private &lt; 空着不写 &lt; protected &lt; public</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>关键字：</span><br><span class="line">是一个权限修饰符</span><br><span class="line">可以修饰成员（成员变量和成员方法）</span><br><span class="line">被  <span class="keyword">private</span>  修饰的成员只能在本类中才能访问</span><br><span class="line">针对<span class="keyword">private</span>   修饰的成员变量，如果要被其他类使用，应该提供相应的操作</span><br><span class="line">提供“setXxx(参数)”方法，用于给成员变量赋值，方法用<span class="keyword">public</span>修饰</span><br><span class="line">提供<span class="string">&quot;getXxx()&quot;</span>方法，用于获取成员变量的值，方法用<span class="keyword">public</span>修饰</span><br><span class="line"></span><br><span class="line">实际开发中，一般只用<span class="keyword">private</span>和<span class="keyword">public</span></span><br><span class="line">    成员变量私有</span><br><span class="line">    方法公开</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>关键字   （表示当前方法调用者的地址值）</span><br><span class="line">可以区分成员变量(在类中不在方法中的变量)和局部变量(方法中的变量就叫局部变量)</span><br></pre></td></tr></table></figure><h3 id="this和super使用总结"><a href="#this和super使用总结" class="headerlink" title="this和super使用总结"></a>this和super使用总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">表示当前方法调用者的地址值</span><br><span class="line">这个this是由虚拟机赋值的 </span><br><span class="line"></span><br><span class="line">this</span><br><span class="line">理解为一个变量，表示当前方法调用者的地址</span><br><span class="line">super</span><br><span class="line">代表父类存储空间</span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static表示静态，是java中的一个修饰符，可以修饰成员方法和成员变量</span><br><span class="line"></span><br><span class="line">被static修饰的成员变量  静态变量</span><br><span class="line">特点：</span><br><span class="line">被该类所有的对象共享</span><br><span class="line">不属于对象，属于类</span><br><span class="line">随着类的加载而加载，优先于对象存在</span><br><span class="line">调用方式：</span><br><span class="line">类名调用和对象名调用</span><br><span class="line"></span><br><span class="line">被static修饰的成员方法  静态方法</span><br><span class="line">特点：</span><br><span class="line">多用在测试类和工具类中</span><br><span class="line">javabean类中很少会用</span><br><span class="line">调用方式：a</span><br><span class="line">类名调用和对象名调用</span><br></pre></td></tr></table></figure><h3 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态方法中，只能访问静态</span><br><span class="line">非静态方法可以访问所有</span><br><span class="line">静态方法中没有this关键字</span><br></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可修饰  方法  类   变量</span><br><span class="line">一旦用final修饰</span><br><span class="line">方法</span><br><span class="line">该方法是最终方法，不能被重写</span><br><span class="line">类</span><br><span class="line">该类值最终类，不能被继承</span><br><span class="line">变量</span><br><span class="line">叫做常量，只能被赋值一次</span><br><span class="line">final修改基本数据类型，记录的值不能发生改变</span><br><span class="line">final修改引用数据类型，记录的地址值不能发生改变，内部的属性值还是可以改变的</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instanceof   </span><br><span class="line">用来判断对象和类型是否一致     对象   instanceof   类型</span><br></pre></td></tr></table></figure><h2 id="构造方法（构造器，构造函数）"><a href="#构造方法（构造器，构造函数）" class="headerlink" title="构造方法（构造器，构造函数）"></a>构造方法（构造器，构造函数）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">在创建对象时，虚拟机（jvm）会自动调用构造方法，作用是给成员变量进行赋值的</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">修饰符     方法名与类名相同  (参数)&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">特点：</span><br><span class="line">方法名与类名相同大小写也要一致</span><br><span class="line">没有返回值类型，没有<span class="keyword">void</span></span><br><span class="line">没有具体的返回值(不能由<span class="keyword">return</span>返回具体的数据)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">构造方法的定义：</span><br><span class="line">如果没有定义构造方法，系统将会给出一个默认的无参构造</span><br><span class="line">无参构造：</span><br><span class="line">在初始化对象的时候，成员变量的数据均采用默认值</span><br><span class="line">如果自己给出了构造方法，系统将不会提供默认的构造方法</span><br><span class="line">有参构造：</span><br><span class="line">在初始化对象的时候，同时可以给成员变量进行赋值</span><br><span class="line">构造方法的重载：</span><br><span class="line">带参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这就叫做构造方法的重载</span><br><span class="line">推荐使用方式：</span><br><span class="line">无论是否使用，都手动书写无参构造方法，和带全部参数的构造方法</span><br></pre></td></tr></table></figure><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="/posts/737a1d7/Snipaste_2023-02-19_15-50-31.png"></p><h2 id="x3D-x3D-号到底比的是什么？"><a href="#x3D-x3D-号到底比的是什么？" class="headerlink" title="&#x3D;&#x3D;号到底比的是什么？"></a>&#x3D;&#x3D;号到底比的是什么？</h2><p><img src="/posts/737a1d7/Snipaste_2023-02-28_20-54-06.png"></p><h1 id="String概述"><a href="#String概述" class="headerlink" title="String概述"></a>String概述</h1><h2 id="创建String对象的两种方式"><a href="#创建String对象的两种方式" class="headerlink" title="创建String对象的两种方式"></a>创建String对象的两种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>。直接赋值</span><br><span class="line">String name = <span class="string">&quot;Mq&quot;</span>;</span><br><span class="line"><span class="number">2.</span><span class="function">new</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span>  <span class="comment">//空参构造</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] chs)</span>  <span class="comment">//根据字符数组，创建字符串对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] chs)</span>  <span class="comment">//根据字节数字，创建字符串对象</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h3 id="第二种创建方式"><a href="#第二种创建方式" class="headerlink" title="第二种创建方式"></a>第二种创建方式</h3><p><img src="/posts/737a1d7/Snipaste_2023-02-28_20-43-55.png"></p><h2 id="String的一些方法"><a href="#String的一些方法" class="headerlink" title="String的一些方法"></a>String的一些方法</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> equals方法(要比较的字符串)   完全一样结果才是<span class="keyword">true</span>，否则就是<span class="function"><span class="keyword">false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalslgnoreCase</span><span class="params">(要比较的字符串)</span>  忽略大小写比较   <span class="comment">//一般都是字符串</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//比较两个字符串字母的大小</span></span></span><br><span class="line"><span class="function"><span class="title">compareTo</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    String s1 </span>= <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">s1.compareTo(s2);<span class="comment">//会返回-1</span></span><br></pre></td></tr></table></figure><h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>: 根据索引返回字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>: 返回此字符串的长度</span></span><br><span class="line"><span class="function">数组的长度： 数组名.length</span></span><br><span class="line"><span class="function">字符串的长度： 字符串对象.<span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function">字符串的长度是方法    数组的长度是属性</span></span><br></pre></td></tr></table></figure><h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)</span>  注意：包头不包尾，包左不包右</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>  截取到末尾 </span></span><br></pre></td></tr></table></figure><h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(旧值,新值)</span>  <span class="comment">//注意：只有返回值才是替换之后的结果</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串原理"><a href="#字符串原理" class="headerlink" title="字符串原理"></a>字符串原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字符串存储的内存原理</span><br><span class="line">直接赋值会复用字符常量池中的</span><br><span class="line"><span class="keyword">new</span>出来的不会复用，而是开辟一个新的空间</span><br><span class="line">==号比较的到底是什么？</span><br><span class="line">基本数据类型比较数据值</span><br><span class="line">引用数据类型比较地址值   .equals()方法</span><br><span class="line">字符串拼接的底层原理</span><br><span class="line">如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串。</span><br><span class="line">如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存。</span><br></pre></td></tr></table></figure><h3 id="字符串拼接的底层原理"><a href="#字符串拼接的底层原理" class="headerlink" title="字符串拼接的底层原理"></a>字符串拼接的底层原理</h3><p><img src="/posts/737a1d7/Snipaste_2023-03-01_21-59-54.png"></p><h2 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder可以看成一个容器，创建之后里边的内容是可变的！！！</span><br><span class="line">作用：提高字符串的操作效率</span><br><span class="line">比如单纯的字符串拼接操作会产生新的字符串造成空间的浪费</span><br><span class="line">提高效率的底层原理</span><br><span class="line">所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存</span><br><span class="line">构造方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span>    创建一个空白可变字符串对象，不含有任何内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> 根据字符串的内容，来创建可变字符串对象</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(任意类型)</span> 添加数据，并返回对象本身</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">reverse</span><span class="params">()</span> 反转容器中的内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengh</span><span class="params">()</span> 返回长度（字符出现的个数）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> 通过<span class="title">toString</span><span class="params">()</span>就可以实现把StringBuilder转换为String</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder源码分析"><a href="#StringBuilder源码分析" class="headerlink" title="StringBuilder源码分析"></a>StringBuilder源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认创建一个长度为<span class="number">16</span>的字节数组</span><br><span class="line">添加的内容长度小于<span class="number">16</span>，直接存</span><br><span class="line">添加的内容大于<span class="number">16</span>会扩容（原来的容量*<span class="number">2</span>+<span class="number">2</span>）</span><br><span class="line">如果扩容之后还不够，以实际长度为准</span><br></pre></td></tr></table></figure><h2 id="StringJoiner概述"><a href="#StringJoiner概述" class="headerlink" title="StringJoiner概述"></a><strong>StringJoiner概述</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringJoiner和StringBuilder一样，也可以看成一个容器，创建之后里边的内容是可变的</span><br><span class="line">作用：</span><br><span class="line">提高字符串的操作效率，而且代码编写特别简介，但是目前市场上很少有人用。</span><br><span class="line">构造方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringJoiner</span><span class="params">(间隔符号)</span>  创建一个StringJoiner对象，指定拼接时的间隔符号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringJoiner</span><span class="params">(间隔符号,开始符号,结束符号)</span> 创建一个StringJoiner对象，指定拼接时的间隔符号开始符号和结束符号</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h3 id="StringJoiner常用方法"><a href="#StringJoiner常用方法" class="headerlink" title="StringJoiner常用方法"></a><strong>StringJoiner常用方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringJoiner <span class="title">add</span><span class="params">(添加的内容)</span>  添加数据，并返回对象本身</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>  返回长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>  返回一个字符串该字符串就是拼接后的结果 </span></span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Collection单列集合（接口，需要创建实现类对象）"><a href="#Collection单列集合（接口，需要创建实现类对象）" class="headerlink" title="Collection单列集合（接口，需要创建实现类对象）"></a>Collection单列集合（接口，需要创建实现类对象）</h3><p><img src="/posts/737a1d7/Snipaste_2023-03-16_14-59-52.png" alt="Snipaste_2023-03-16_14-59-52"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line">Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>把给定的对象添加到当前集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>清空集合中所有的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span>把给定的对象在当前集合删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span>判断当前集合是否包含给定对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>判断当前集合是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> 返回集合元素个数</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">需要注意：</span></span><br><span class="line"><span class="function">     contains底层是依赖equals方法进行判断是否存在的</span></span><br><span class="line"><span class="function">        <span class="comment">// 所以，如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在javabean类中，一定要重写equals方法</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">---------------------------------------------------Collection集合获取迭代器</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span>返回迭代器对象，默认指向当前集合的0索引</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p><img src="/posts/737a1d7/Snipaste_2023-03-18_15-02-50.png"></p><h4 id="List集合（也是接口，需要创建实现类的对象）"><a href="#List集合（也是接口，需要创建实现类的对象）" class="headerlink" title="List集合（也是接口，需要创建实现类的对象）"></a>List集合（也是接口，需要创建实现类的对象）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List集合的特点</span><br><span class="line">有序：</span><br><span class="line">存和取的元素顺序一致</span><br><span class="line">有索引：</span><br><span class="line">可以通过索引操作元素</span><br><span class="line">可重复：</span><br><span class="line">存储的元素可以重复</span><br><span class="line"></span><br><span class="line">List集合的特有方法</span><br><span class="line">Collection的方法List都继承了</span><br><span class="line">List集合因为有索引，所以多了很多索引操作的方法</span><br><span class="line"></span><br><span class="line">方法名称</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span> <span class="comment">//在集合中按指定位置插入元素</span></span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span><span class="comment">//删除指定索引的元素，返回被删除的元素</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span><span class="comment">//修改指定索引的元素，返回被修改的元素</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span><span class="comment">//返回指定索引处的元素</span></span></span><br></pre></td></tr></table></figure><h5 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h5><h5 id="集合和数组的对比"><a href="#集合和数组的对比" class="headerlink" title="集合和数组的对比"></a>集合和数组的对比</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">集合</span><br><span class="line">长度可变</span><br><span class="line">可以存引用数据类型（存基本数据类型的话需要包装类）</span><br><span class="line">    E   泛型：限定集合中存储数据的类型</span><br><span class="line">数组</span><br><span class="line">长度固定</span><br><span class="line">可以存基本数据类型和引用数据类型</span><br></pre></td></tr></table></figure><h5 id="ArrayList成员方法-增删改查"><a href="#ArrayList成员方法-增删改查" class="headerlink" title="ArrayList成员方法(增删改查)"></a>ArrayList成员方法(增删改查)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>  <span class="comment">//添加元素，返回值表示是否添加成功</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span><span class="comment">//删除指定元素，返回值表示是否删除成功</span></span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//删除指定索引的元素，返回被删除的元素</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E e)</span> <span class="comment">//修改指定索引下的元素，返回原来的元素</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//获取指定索引的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>  <span class="comment">//集合的长度，也就是集合中元素的个数</span></span></span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="Set系列集合（Set接口中的方法和Collection的Api一致）"><a href="#Set系列集合（Set接口中的方法和Collection的Api一致）" class="headerlink" title="Set系列集合（Set接口中的方法和Collection的Api一致）"></a>Set系列集合（Set接口中的方法和Collection的Api一致）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set集合特点：</span><br><span class="line">无序：存取顺序不一致</span><br><span class="line">不重复：可以去除重复</span><br><span class="line">无索引:没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素</span><br><span class="line"></span><br><span class="line">Set集合的实现类：</span><br><span class="line">HashSet：无序、不重复、无索引</span><br><span class="line">LinkedHashSet：有序、不重复、无索引</span><br><span class="line">TreeSet：可排序、不重复、无索引</span><br></pre></td></tr></table></figure><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">HashSet底层原理：</span><br><span class="line">HashSet集合底层采取哈希表存储数据</span><br><span class="line">哈希表是一种对于增删改查数据性能都较好的结构</span><br><span class="line">1.创建一个默认长度16，默认加载因子为0.75的数组，数组名为table</span><br><span class="line">2.根据元素的哈希值跟数组的长度计算出应存入的位置</span><br><span class="line">3.判断当前位置是否为null，如果是null直接存入</span><br><span class="line">4.如果位置不为null，表示有元素，则调用equals方法比较属性值</span><br><span class="line">5.一样： 不存不一样： 存入数组，形成链表</span><br><span class="line">JDK8以前： 新元素存入数组，老元素挂在新元素下面</span><br><span class="line">JDK8以后： 新元素直接挂在老元素下面</span><br><span class="line">JDK8以后，当链表长度超过8，而且数组长度大于等于64时，自动转换为红黑树</span><br><span class="line"></span><br><span class="line">如果集合中存储的时自定义对象，必须重写hashCode和equals方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashSet的三个问题</span><br><span class="line">HashSet为什么存和取的顺序不一样？</span><br><span class="line">遍历时从数组的0索引开始，遇到链表先遍历完再进行数组的遍历</span><br><span class="line"></span><br><span class="line">HashSet为什么没有索引？</span><br><span class="line">因为HashSet在底层是，数组链表和红黑树组成的的结构，不知道以谁当索引</span><br><span class="line"></span><br><span class="line">HashSet是利用什么机制保证数据去重的？</span><br><span class="line">HashSet方法和equals方法</span><br><span class="line"></span><br><span class="line">哈希表组成：</span><br><span class="line">JDK8之前：</span><br><span class="line">数组+链表</span><br><span class="line">JDK8开始：</span><br><span class="line">数组+链表+红黑树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希值：</span><br><span class="line">对象的整数表现形式</span><br><span class="line">根据hashCode方法算出来的int类型的整数</span><br><span class="line">该方法定义再Object类中，所有对象都可以调用，默认使用地址值进行计算</span><br><span class="line">一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值</span><br><span class="line"></span><br><span class="line">对象的哈希值特点：</span><br><span class="line">如果没有重写hashCode方法，不同对象计算出的哈希值是不同的</span><br><span class="line">如果已经重写hashCode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的</span><br><span class="line">在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样（哈希碰撞）</span><br></pre></td></tr></table></figure><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">继承HashSet直接用HashSet的方法即可</span><br><span class="line">底层是使用双向链表保证数据的顺序</span><br><span class="line">特点：</span><br><span class="line">有顺序、不重复、无索引</span><br></pre></td></tr></table></figure><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">可排序、不重复、无索引</span><br><span class="line"></span><br><span class="line">TreeSet添加的两种规则：</span><br><span class="line">方式一：</span><br><span class="line">默认排序，自然排序：</span><br><span class="line">Javabean类实现Comparable接口指定比较规则</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line">    <span class="comment">//     负数：认为要添加的元素是小的，存在左边</span></span><br><span class="line">    <span class="comment">//     正数：认为要添加的元素是大的，存在右边</span></span><br><span class="line">    <span class="comment">//     0：认为要添加的元素已经存在，舍弃</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定排序的规则</span></span><br><span class="line"><span class="comment">//按照年龄比较</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge()-o.getAge();</span><br><span class="line">        <span class="comment">// return 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">        比较器排序：创建TreeSet对象的时候，传递比较器Comparator指定规则</span><br></pre></td></tr></table></figure><h3 id="单列集合总结"><a href="#单列集合总结" class="headerlink" title="单列集合总结"></a>单列集合总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.如果想要集合中的元素可重复</span><br><span class="line">用ArrayList集合，基于数组的</span><br><span class="line">2.如果想要集合中元素重复，而且当前的增删操作明显多于查询</span><br><span class="line">用LinkedList集合，基于链表的</span><br><span class="line">3.如果想对集合中的元素去重</span><br><span class="line">用HashSet集合，基于哈希表的</span><br><span class="line">4.如果想对集合中的元素去重，而且保证存取顺序</span><br><span class="line">用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet</span><br><span class="line">5.如果想对集合中的元素进行排列</span><br><span class="line">用TreeSet集合，基于红黑树，后续也可以用List集合实现排序</span><br></pre></td></tr></table></figure><h3 id="Map双列集合（Map是双列集合的顶层接口，它的共功能是全部双列集合都可以继承使用的）"><a href="#Map双列集合（Map是双列集合的顶层接口，它的共功能是全部双列集合都可以继承使用的）" class="headerlink" title="Map双列集合（Map是双列集合的顶层接口，它的共功能是全部双列集合都可以继承使用的）"></a>Map双列集合（Map是双列集合的顶层接口，它的共功能是全部双列集合都可以继承使用的）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">双列集合的特点</span><br><span class="line">双列集合一次需要存一对数据，分别为键和值</span><br><span class="line">键不能重复，值可以重复</span><br><span class="line">键和值是一一对应的，每一个键只能找到自己对应的值</span><br><span class="line">键+值这个整体 我们称之为&quot;键值对&quot; 或者 &quot;键值对对象&quot;，在java中叫做&quot;Entry对象&quot;</span><br><span class="line"></span><br><span class="line">TreeMap特点：</span><br><span class="line">不重复、无索引、可排序</span><br><span class="line">底层基于红黑树实现排序，增删改查性能好</span><br><span class="line">TreeMap集合排序的两种方式：</span><br><span class="line">实现Compareble接口，指定比较规则</span><br><span class="line">创建集合时传递Com【arator比较器对象，指定比较规则</span><br></pre></td></tr></table></figure><p><img src="/posts/737a1d7/Snipaste_2023-03-20_15-15-33.png" alt="Snipaste_2023-03-20_15-15-33"></p><h4 id="Map常见的API"><a href="#Map常见的API" class="headerlink" title="Map常见的API"></a>Map常见的API</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">V put (K key,V value)添加元素</span><br><span class="line">V remove(Object key)根据键删除键值对元素</span><br><span class="line">void clear()移除所有的键值对元素</span><br><span class="line">boolean containsKey(Object key)判断集合是否包含指定的键</span><br><span class="line">Boolean containsValue(Object value) 判断集合是否包含指定的值</span><br><span class="line">boolean isEmpty() 判断集合是否为空</span><br><span class="line">int size()集合的长度，也就是集合中键值对的个数</span><br><span class="line">int get(Object key)判断键出现的次数</span><br></pre></td></tr></table></figure><h5 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">遍历方式有三种</span><br><span class="line"><span class="number">1.</span>键找值</span><br><span class="line"><span class="comment">//获取所有的键，把这些键放到一个集合中</span></span><br><span class="line">        Set&lt;String&gt; keySet = m.keySet();</span><br><span class="line">        然后通过Set集合遍历</span><br><span class="line">    <span class="comment">//利用map中对应的key键获取对应的值value</span></span><br><span class="line">        String value = m.get(key);</span><br><span class="line">        System.out.println(<span class="string">&quot;key = &quot;</span>+key+<span class="string">&quot;  value = &quot;</span>+value);</span><br><span class="line"><span class="number">2.</span>不推荐</span><br><span class="line">    <span class="number">3.</span>利用Lambda改写BiConsumer</span><br><span class="line">        m.forEach((key,value)-&gt; System.out.println(key+<span class="string">&quot;=&quot;</span>+value));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">统计思想，利用map集合进行排序</span><br><span class="line">    如果题目中没有要求对结果进行排序，默认使用HashMap</span><br><span class="line">如果题目中要求对结果进行排序，默认使用TreeMap</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="Colleation遍历"><a href="#Colleation遍历" class="headerlink" title="Colleation遍历"></a>Colleation遍历</h3><h4 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">迭代器不依赖索引</span><br><span class="line">Iterator中常用方法</span><br><span class="line"></span><br><span class="line">boolean hasNext() 判断当前位置是否有元素，有元素返回true，没有元素返回false</span><br><span class="line"></span><br><span class="line">E next() 获取当前位置的元素，并将迭代器对象移向下一个位置</span><br></pre></td></tr></table></figure><h4 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">增强<span class="keyword">for</span>的底层就是迭代器，为了简化迭代器的代码书写的</span><br><span class="line">他是JDK5以后出现的，其内部原理就是一个Iterator迭代器</span><br><span class="line">所有的单列集合和数组才能用增强<span class="keyword">for</span>进行遍历</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line"><span class="keyword">for</span>(元素的数据类型 变量名:数组或集合)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">例如：</span><br><span class="line">    <span class="keyword">for</span>(String s : List)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">增强<span class="keyword">for</span>的细节：</span><br><span class="line">    修改增强<span class="keyword">for</span>中的变量，不会改变集合中原本的数据</span><br></pre></td></tr></table></figure><h4 id="Lambda表达式遍历"><a href="#Lambda表达式遍历" class="headerlink" title="Lambda表达式遍历"></a>Lambda表达式遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDK8开始的新技术Lambda表达式，提供了一种更简单，更直接的遍历集合的方式</span><br><span class="line">() -&gt; </span><br><span class="line">default void forEach(Consumer&lt;? super T&gt; action) :结合Lambda遍历集合</span><br></pre></td></tr></table></figure><h3 id="基本数据类型对应包装类"><a href="#基本数据类型对应包装类" class="headerlink" title="基本数据类型对应包装类"></a>基本数据类型对应包装类</h3><p><img src="/posts/737a1d7/Snipaste_2023-03-02_21-18-07.png" alt="Snipaste_2023-03-02_21-18-07"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是反射？</span><br><span class="line">反射允许对封装类的字段（成员变量）</span><br><span class="line">方法（成员方法）</span><br><span class="line">构造函数（构造方法）</span><br><span class="line">的信息进行编程访问</span><br></pre></td></tr></table></figure><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">什么是多线程？</span><br><span class="line">有了多线程，我们就可以让程序同时做多件事情</span><br><span class="line">多线程的作用？</span><br><span class="line">提高效率</span><br><span class="line">多线程的应用场景？</span><br><span class="line">只要你想让多个事情同时运行就需要用到多线程</span><br></pre></td></tr></table></figure><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">并发：</span><br><span class="line">在同一时刻，有多个指令在单个CPU上   交替   执行</span><br><span class="line"></span><br><span class="line">并行：</span><br><span class="line">在同一时刻，有多个指令在多个CPU上   同时   执行</span><br></pre></td></tr></table></figure><h4 id="多线程三种实现方法对比"><a href="#多线程三种实现方法对比" class="headerlink" title="多线程三种实现方法对比"></a>多线程三种实现方法对比</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">继承Thread类</span><br><span class="line">优点：</span><br><span class="line">编程比较简单可以直接使用Thread类中的方法</span><br><span class="line">缺点：</span><br><span class="line">扩展性较差，不能再继承其他类</span><br><span class="line">第二种：</span><br><span class="line">实现Runnable接口</span><br><span class="line">优点：</span><br><span class="line">扩展性强，实现该接口的同时还可以继承其他的类</span><br><span class="line">缺点：</span><br><span class="line">编程相对复杂，不能直接使用Thread类中的方法</span><br><span class="line">第三种：</span><br><span class="line">实现Callable接口    （同第二种）</span><br><span class="line">不过可以获取线程运行的结果</span><br></pre></td></tr></table></figure><h4 id="线程常用的成员方法"><a href="#线程常用的成员方法" class="headerlink" title="线程常用的成员方法"></a>线程常用的成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回此线程的名称</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置线程的名字（构造方法也可以设置名字）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前线程的对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 让线程休眠指定的时间，单位为毫秒</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(Long time)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 设置线程的优先级</span></span></span><br><span class="line"><span class="function"><span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 获取线程的优先级</span></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 设置为守护线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 出让线程/礼让线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 插入线程/插队线程</span></span></span><br><span class="line"><span class="function">publid <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p><img src="/posts/737a1d7/Snipaste_2023-03-29_11-50-03.png" alt="Snipaste_2023-03-29_11-50-03"></p><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">把操作共享数据的代码锁起来</span><br><span class="line">格式：</span><br><span class="line">synchronized(锁)&#123;</span><br><span class="line">操作共享数据的代码</span><br><span class="line">&#125;</span><br><span class="line">特点：</span><br><span class="line">锁默认打开，有一个线程进入，锁自动关闭</span><br><span class="line">里面所有的代码全部执行完毕，线程出来，锁自动打开</span><br></pre></td></tr></table></figure><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock实现提供比使用<span class="keyword">synchronized</span>方法和语句可以获得更广泛的锁定操作</span><br><span class="line">Lock中提供了获得锁和释放锁的方法</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">locl</span><span class="params">()</span>:获得锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>:释放锁</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</span></span><br><span class="line"><span class="function">ReentrantLock的构造方法</span></span><br><span class="line"><span class="function"><span class="title">ReentrantLock</span><span class="params">()</span>:创建一个ReentrantLock的实例化</span></span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Execuors：</span><br><span class="line">线程池的工具类通过调用方法返回不同类型的线程池对象</span><br><span class="line"></span><br><span class="line">线程池代码实现：</span><br><span class="line"></span><br><span class="line">// 创建一个没有上线的线程池</span><br><span class="line">public static ExecutorService newCachedThreadPool()</span><br><span class="line"></span><br><span class="line">// 创建有上限的线程池</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程池主要核心原理</span><br><span class="line">1.创建一个池子，池子中是空的</span><br><span class="line">2.提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可</span><br><span class="line">3.但是如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义线程池</span><br><span class="line">小结：</span><br><span class="line">1.创建一个空的池子</span><br><span class="line">2.有任务提交时，线程池会创建线程去执行任务，执行完毕归还线程</span><br><span class="line"></span><br><span class="line">不断的提交任务，会有三个临界点：</span><br><span class="line">1.当核心线程满时，在提交任务就会排队</span><br><span class="line">2.当核心线程满，队伍满时，会创建临时线程</span><br><span class="line">3.当核心线程满，队伍满，临时线程满时，会触发任务拒绝策略</span><br></pre></td></tr></table></figure><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">什么是网络编程？</span><br><span class="line">在网络通信协议下，不同计算机上运行的程序，进行的数据传输</span><br><span class="line"></span><br><span class="line">表示互联网协议（IP）地址的类</span><br><span class="line">InetAddress</span><br><span class="line"></span><br><span class="line">端口号：</span><br><span class="line">应用程序在设备中的唯一标识</span><br><span class="line"></span><br><span class="line">端口号：</span><br><span class="line">由两个字节表示的整数，取值范围：0~65535</span><br><span class="line">其中0~1023之间的端口号用于一些知名的网络服务或者应用</span><br><span class="line">我们自己使用1024以上的端口号就可以了</span><br><span class="line">注意：</span><br><span class="line">一个端口号只能被一个应用程序使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">协议：</span><br><span class="line">计算机网络中，连接和通信的规则被称为网络通信协议</span><br><span class="line"></span><br><span class="line">UDP协议：</span><br><span class="line">用户数据报协议</span><br><span class="line">UDP是  面向无连接  通信协议</span><br><span class="line">速度快，有大小限制一次最多发送64K，数据不安全，易丢失</span><br><span class="line"></span><br><span class="line">UDP的三种通信方式</span><br><span class="line">1.单播：</span><br><span class="line">以前的代码就是单播</span><br><span class="line">2.组播：</span><br><span class="line">组播地址：224.0.0.0 ~ 239.255.255.255</span><br><span class="line">其中224.0.0.0 ~ 224.0.0.255为预留的组播地址</span><br><span class="line">3.广播：</span><br><span class="line">广播地址：255.255.255.255</span><br><span class="line">TCP协议：</span><br><span class="line">传输控制协议TCP</span><br><span class="line">TCP协议是  面向连接  的通信协议</span><br><span class="line">速度慢，没有大小限制，数据安全</span><br><span class="line"></span><br><span class="line">客户端：</span><br><span class="line">1.创建客户端的Socket对象与指定服务端连接</span><br><span class="line">Socket(String host,int port)</span><br><span class="line">2.获取输出流，写数据</span><br><span class="line">OutputStream  getOutputStream()</span><br><span class="line">3.释放资源</span><br><span class="line">void close()</span><br><span class="line"></span><br><span class="line">服务器：</span><br><span class="line">1.创建服务器端的Socket对象</span><br><span class="line">ServerSocket(int port)</span><br><span class="line">2.监听客户端连接，返回一个Socket对象</span><br><span class="line">Socket accept()</span><br><span class="line">3.获取输入流，读数据，并把数据显示在控制台</span><br><span class="line">InputStream   getInputStream()</span><br><span class="line">4.释放资源</span><br><span class="line">void close()</span><br></pre></td></tr></table></figure><h4 id="TCP通信程序（三次握手）"><a href="#TCP通信程序（三次握手）" class="headerlink" title="TCP通信程序（三次握手）"></a>TCP通信程序（三次握手）</h4><p><img src="/posts/737a1d7/Snipaste_2023-03-30_09-20-17.png" alt="Snipaste_2023-03-30_09-20-17"></p><h4 id="TCP通信程序（四次挥手）"><a href="#TCP通信程序（四次挥手）" class="headerlink" title="TCP通信程序（四次挥手）"></a>TCP通信程序（四次挥手）</h4><p><img src="/posts/737a1d7/Snipaste_2023-03-30_09-23-49.png" alt="Snipaste_2023-03-30_09-23-49"></p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">什么是IO流</span><br><span class="line">存储和读取数据的解决方啊</span><br><span class="line">I:intputO:output</span><br><span class="line">流：像水流一样传输数据</span><br><span class="line"></span><br><span class="line">IO流的作用：</span><br><span class="line">用于读写数据（本地文件，网络）</span><br><span class="line"></span><br><span class="line">IO流按照流向可以分类哪两种流</span><br><span class="line">输出流： 程序  -&gt;  文件</span><br><span class="line">输入流： 文件  -&gt;  程序</span><br><span class="line"></span><br><span class="line">IO流按照操作文件的类型可以分类哪两种流</span><br><span class="line">字节流：可以操作所有类型的文件</span><br><span class="line">字符流：只能操作纯文本文件</span><br><span class="line"></span><br><span class="line">什么是纯文本文件</span><br><span class="line">用Windows系统自带的记事本打开并且能够读懂的文件</span><br></pre></td></tr></table></figure><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">File表示什么：</span><br><span class="line">    File对象表示路径，可以是文件，也可以是文件夹。</span><br><span class="line">    这个路径可以是存在的，也可以是不存在的</span><br><span class="line">    </span><br><span class="line">绝对路径和相对路径是什么意思：</span><br><span class="line">    绝对路径是带盘符的</span><br><span class="line">    相对路径是不带盘符的，默认到当前项目下去找</span><br><span class="line"></span><br><span class="line">File三种构造方法：    </span><br><span class="line"><span class="comment">// 根据文件路径创建文件对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 根据父路径名字符串和子路径名字符串创建文件对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String chile)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 根据父路径对应文件对象和子路径名字符串创建文件对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent,String chile)</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure><h4 id="File常见的成员方法"><a href="#File常见的成员方法" class="headerlink" title="File常见的成员方法"></a>File常见的成员方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 判断此路径名表示的File是否为文件夹</span><br><span class="line">boolean isDirectory()</span><br><span class="line"></span><br><span class="line">// 判断此路径名表示的File是否为文件</span><br><span class="line">boolean isFile()</span><br><span class="line"></span><br><span class="line">// 判断此路径名表示的File是否为存在</span><br><span class="line">boolean exists()</span><br><span class="line"></span><br><span class="line">// 返回文件的大小(字节数量)</span><br><span class="line">long length()</span><br><span class="line"></span><br><span class="line">// 返回文件的绝对路径</span><br><span class="line">String getAbsolutePath()</span><br><span class="line"></span><br><span class="line">// 返回定义文件时使用的路径</span><br><span class="line">String getPath()</span><br><span class="line"></span><br><span class="line">// 返回文件的名称，带后缀</span><br><span class="line">String getName()</span><br><span class="line"></span><br><span class="line">// 返回文件的最后修改时间(时间毫秒值)</span><br><span class="line">Long lastModified()</span><br><span class="line"></span><br><span class="line">=================(创建、删除)==============</span><br><span class="line">// 创建一个新的空的文件</span><br><span class="line">boolean createNewFile()</span><br><span class="line"></span><br><span class="line">// 创建单级文件夹</span><br><span class="line">boolean mkdir()</span><br><span class="line"></span><br><span class="line">// 创建多级文件夹</span><br><span class="line">boolean mkdirs()</span><br><span class="line"></span><br><span class="line">// 删除文件、空文件见！！！注意删除的时候不走回收站</span><br><span class="line">boolean delete()</span><br><span class="line"></span><br><span class="line">=================获取并遍历===============</span><br><span class="line">// 获取当前该路径下所有内容</span><br><span class="line">File[] listFiles()</span><br></pre></td></tr></table></figure><h4 id="FileOutPutStream书写细节（字节流）"><a href="#FileOutPutStream书写细节（字节流）" class="headerlink" title="FileOutPutStream书写细节（字节流）"></a>FileOutPutStream书写细节（字节流）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">字节输出流的细节：</span><br><span class="line">  1.创建字节输出流对象</span><br><span class="line">        细节1：参数是字符串表示的路径或者是File对象都是可以的</span><br><span class="line">        细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的</span><br><span class="line">        细节3: 如果文件中存在数据，则会清空数据</span><br><span class="line">        </span><br><span class="line">     2.写出数据：</span><br><span class="line">        细节1：write输入的是整数，但是保存在本地的是ASCII的对应字符</span><br><span class="line">        </span><br><span class="line">     3.释放资源：</span><br><span class="line">        每次使用完流之后都要释放资源</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">FileOutPutStream写数据的3中方式</span><br><span class="line"></span><br><span class="line">//一次写一个数据</span><br><span class="line">void write(int b)</span><br><span class="line"></span><br><span class="line">//一次写一个字节数组数据</span><br><span class="line">void write(byte[] b)</span><br><span class="line"></span><br><span class="line">//一次写一个字节数组的部分数据</span><br><span class="line">void write(byte[] b,int off,int len)</span><br></pre></td></tr></table></figure><h4 id="FileInPutStream书写细节（字节流）"><a href="#FileInPutStream书写细节（字节流）" class="headerlink" title="FileInPutStream书写细节（字节流）"></a>FileInPutStream书写细节（字节流）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.创建字节输入流对象：</span><br><span class="line">细节1：如果文件不存在，就直接报错</span><br><span class="line"></span><br><span class="line">2.读取数据：</span><br><span class="line">细节1：一次读一个字节，读出来的数据是ASCII上对应的数字</span><br><span class="line">细节2：读到文件末尾了，read方法返回-1</span><br><span class="line"></span><br><span class="line">3.释放资源：</span><br><span class="line">细节：每次使用完流必须要释放资源</span><br></pre></td></tr></table></figure><h3 id="FileReader（字符流）"><a href="#FileReader（字符流）" class="headerlink" title="FileReader（字符流）"></a>FileReader（字符流）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(File file)</span>        创建字符输入流关联本地文件</span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String pathname)</span>  创建字符输入流关联本地文件</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//第二步：读取数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>                   读取数据，读到末尾返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buffer)</span>      读取多个数据，读到末尾返回-1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//第三步：释放资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>                 释放资源/关流</span></span><br></pre></td></tr></table></figure><h4 id="字符流原理解析"><a href="#字符流原理解析" class="headerlink" title="字符流原理解析"></a>字符流原理解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.创建字符输入流对象</span><br><span class="line">底层：关联文件，并创建缓冲区（长度为8192的字节数组）</span><br><span class="line"></span><br><span class="line">2.读取数据</span><br><span class="line">底层：</span><br><span class="line">1.判断缓冲区中是否有数据可以读取</span><br><span class="line">2.缓冲区没有数据：</span><br><span class="line">就从文件中获取，撞到缓冲区中，每次尽可能装满缓冲区 如果文件中也没有数据了，返回-1</span><br><span class="line">3.缓冲区有数据：</span><br><span class="line">就从缓冲区读取</span><br><span class="line">空参的read方法：</span><br><span class="line">一次读取一个字节，遇到中文一次读多个字节，把字节解码并转换成十进制返回</span><br><span class="line">有参的read方法：</span><br><span class="line">把读取字节，解码，强转三步合并了，强转之后的字符放到数组中</span><br></pre></td></tr></table></figure><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.缓冲流有几种</span><br><span class="line">字节缓冲输入流：BufferedInputStream()</span><br><span class="line">字节缓冲输出流：BufferedOutputStream()</span><br><span class="line">字符缓冲输入流：BufferedReader()</span><br><span class="line">字节缓冲输出流：BufferedWriter()</span><br><span class="line"></span><br><span class="line">2.缓冲流为什么能提高性能</span><br><span class="line">缓冲流自带长度为8192的缓冲区</span><br><span class="line">可以显著提高字节流的读写性能</span><br><span class="line">对于字符流提升不明显，有两种特有的方法</span><br><span class="line"></span><br><span class="line">3.字符缓冲流有两个特有的方法</span><br><span class="line">字符缓冲输入流 BufferedReader: readLine()</span><br><span class="line">字符缓冲输出流 BufferedWriter: newLine()</span><br></pre></td></tr></table></figure><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">转换流的名字：</span><br><span class="line">字符转换输入流：InputStreamReader</span><br><span class="line">字符转换输出流：OutputStreamWriter</span><br><span class="line">转换流的作用是什么：</span><br><span class="line">指定字符集读写数据</span><br><span class="line">字节流想要使用字符流中的方法</span><br></pre></td></tr></table></figure><h3 id="序列化流-x2F-对象操作输出流"><a href="#序列化流-x2F-对象操作输出流" class="headerlink" title="序列化流&#x2F;对象操作输出流"></a>序列化流&#x2F;对象操作输出流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">可以把Java中的对象写到本地文件中</span><br><span class="line"></span><br><span class="line">构造方法</span><br><span class="line">// 把基本流包装成高级流</span><br><span class="line">public ObjectOutputStream(OutputStream out)</span><br><span class="line"></span><br><span class="line">成员方法</span><br><span class="line">// 把对象序列化(写出)到文件中去</span><br><span class="line">public final void wtiterObject(Object obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">序列化小细节：</span><br><span class="line">使用对象输出流将对象保存到文件时会出现问题</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">需要让JavaBean类实现Serializable接口</span><br><span class="line"></span><br><span class="line">如果一个对象的某个成员变量的值不想被序列化</span><br><span class="line">给该成员变量加上transient关键字修饰</span><br><span class="line">该关键字标记的成员变量不参与序列化过程</span><br></pre></td></tr></table></figure><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">分类：</span><br><span class="line">一般是指PintStream，PrintWrite</span><br><span class="line">特点1：</span><br><span class="line">打印流只操作文件目的地，不操作数据源</span><br><span class="line">特点2：</span><br><span class="line">特有的写出方法可以实现，数据原样写出</span><br><span class="line">特点3：</span><br><span class="line">特有的写出方法，可以实现自动刷新，换行</span><br><span class="line"></span><br><span class="line">字节打印流：</span><br><span class="line">构造方法</span><br><span class="line">//关联字节输出流/文件/文件路径</span><br><span class="line">public PrintStream(OutStream/File/String)</span><br><span class="line">//指定字符编码</span><br><span class="line">public PrintStream(String fileName, Charset charset)</span><br><span class="line"></span><br><span class="line">成员方法：</span><br><span class="line">//规则和之前一样，将指定的字节写出</span><br><span class="line">void write(int b)</span><br><span class="line"></span><br><span class="line">特有方法：</span><br><span class="line">//打印任意数据，自动换行，自动刷新</span><br><span class="line">println()</span><br><span class="line">//打印任意数据，不换行</span><br><span class="line">print()</span><br><span class="line">//带有占位符的打印语句，不换行</span><br><span class="line">printf(String format, Object... args)</span><br></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.在计算机中，任意数据都是以二进制的形式来存储的</span><br><span class="line">2.计算机中最小的存储单元是一个字节</span><br><span class="line">3.ASCII字符集中，一个英文占一个字节</span><br><span class="line">4.简体中文版Windows，默认使用GBK字符集</span><br><span class="line">5.GBK字符集完全兼容ASCII字符集</span><br><span class="line">一个英文占一个字节，二进制第一位是0</span><br><span class="line">一个中文占两个字节，二进制高位字节的第一位是1</span><br><span class="line"></span><br><span class="line">Unicode字符集的UTF-8下</span><br><span class="line">一个英文占一个字节，二进制第一位是0</span><br><span class="line">一个中文占3个字节，1110XXXX 10XXXXXX 10XXXXXX（首位是1）</span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">异常：</span><br><span class="line">就是代表程序出的错误</span><br><span class="line"></span><br><span class="line">误区：</span><br><span class="line">不是让我们以后不出异常，而是程序出了异常之后，该如何处理</span><br><span class="line"></span><br><span class="line">异常体系的最上层父类是谁？异常分为几类？</span><br><span class="line">父类：Exception</span><br><span class="line">异常分为两类：编译时异常、运行时异常</span><br><span class="line"></span><br><span class="line">编译时异常和运行时异常的区别</span><br><span class="line">编译时异常：</span><br><span class="line">没有继承RuntimeException的异常，直接继承于Exception</span><br><span class="line">编译阶段就会错误提示</span><br><span class="line">运行时异常：</span><br><span class="line">RuntimeException本身和子类</span><br><span class="line">编译阶段没有错误提示，运行时出现的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/posts/737a1d7/Snipaste_2023-03-22_17-41-33.png" alt="Snipaste_2023-03-22_17-41-33"></p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        可能出现异常的代码;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(异常类名 变量名) &#123;</span><br><span class="line">        异常的处理代码;</span><br><span class="line">    &#125;</span><br><span class="line">目的：</span><br><span class="line">    当代码出现异常时，可以让程序继续往下执行</span><br></pre></td></tr></table></figure><p><img src="/posts/737a1d7/Snipaste_2023-03-22_18-23-55.png" alt="Snipaste_2023-03-22_18-23-55"></p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.什么是方法引用？</span><br><span class="line">把已经存在的方法拿过来用，当作函数式接口中抽象方法的方法体</span><br><span class="line">2.::是什么符号？</span><br><span class="line">方法引用符</span><br><span class="line">3.方法引用时需要注意什么？</span><br><span class="line">需要有函数式接口</span><br><span class="line">被引用方法必须已经存在</span><br><span class="line">被引用方法的形参和返回值需要跟抽象方法保持一致</span><br><span class="line">被引用方法的功能要满足当前的需求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">1.引用静态方法</span><br><span class="line">类名::静态方法</span><br><span class="line">2.引用成员方法</span><br><span class="line">对象::成员方法</span><br><span class="line">this::成员方法</span><br><span class="line">super::成员方法</span><br><span class="line">3.引用构造方法</span><br><span class="line">类名::new</span><br><span class="line">4.使用类名引用成员方法</span><br><span class="line">类名::成员方法</span><br><span class="line">5.引用数组的构造方法</span><br><span class="line">数据类型[]::new</span><br></pre></td></tr></table></figure><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stream流的思想</span><br><span class="line"></span><br><span class="line">Stream流的作用：</span><br><span class="line">结合了Lambda表达式，简化集合，数组的操作</span><br><span class="line"></span><br><span class="line">Stream流的使用步骤：</span><br><span class="line">1.先得到一条Stream流（流水线），并把数据放上去</span><br><span class="line">2.利用Stream流中的API进行各种操作</span><br><span class="line">过滤转换中间方法   方法调用完毕之后，还可以调用其他方法</span><br><span class="line">统计打印终结方法   最后一步，调用完毕之后，不能调用其他方法</span><br><span class="line"></span><br><span class="line">使用流程：</span><br><span class="line">获取方式方法名  说明</span><br><span class="line">单列集合default Stream&lt;E&gt; stream()Collection中的默认方法</span><br><span class="line">双列集合无无法直接使用Stream流</span><br><span class="line">数组public static&lt;T&gt;Stream&lt;T&gt;stream(T[] Array)Array工具类</span><br><span class="line">一堆零散的数据Stream&lt;T&gt;of(T...values)Stream接口的静态方法</span><br></pre></td></tr></table></figure><h3 id="Stream流的中间方法"><a href="#Stream流的中间方法" class="headerlink" title="Stream流的中间方法"></a>Stream流的中间方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">过滤</span><br><span class="line">Stream&lt;T&gt;filter(Predicate&lt;? super T&gt;predicate) </span><br><span class="line"></span><br><span class="line">获取前几个元素</span><br><span class="line">Stream&lt;T&gt;limit(long maxSize)</span><br><span class="line"></span><br><span class="line">跳过前几个元素</span><br><span class="line">Stream&lt;T&gt;skip(long n)</span><br><span class="line"></span><br><span class="line">元素去重，依赖（hashCode和equals方法）</span><br><span class="line">Stream&lt;T&gt;distinct()</span><br><span class="line"></span><br><span class="line">合并a和b两个流为一个流</span><br><span class="line">static&lt;T&gt;Stream&lt;T&gt;concat(Stream a,Stream b)</span><br><span class="line"></span><br><span class="line">转换流中的数据类型</span><br><span class="line">Stream&lt;R&gt;map(Function&lt;T,R&gt; mapper)</span><br><span class="line"></span><br><span class="line">注意点：</span><br><span class="line">1.中间方法，返回新的Stream流，原来的Stream流只能用一次，建议使用链式编程</span><br><span class="line">2.修改Stream流中的数据，不会影响原来集合或者数组中的数据</span><br></pre></td></tr></table></figure><h3 id="Stream流的终结方法"><a href="#Stream流的终结方法" class="headerlink" title="Stream流的终结方法"></a>Stream流的终结方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">遍历</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer action)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">统计</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">收集流中的数据，放到数组中</span></span><br><span class="line"><span class="function"><span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">收集流中的数据，放到集合中</span></span><br><span class="line"><span class="function"><span class="title">collect</span><span class="params">(Collector collector)</span></span></span><br></pre></td></tr></table></figure><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">static &lt;E&gt; List&lt;E&gt; of(E...elements) 创建一个具有指定元素的List集合对象</span><br><span class="line">static &lt;E&gt; Set&lt;E&gt; of(E...elements) 创建一个具有指定元素的Set集合对象</span><br><span class="line">static &lt;E,V&gt; Map&lt;K,V&gt; of(E...elements) 创建一个具有指定元素的Map集合对象</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">这个集合不能添加，不能删除，不能修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不可变集合的特点：</span><br><span class="line">定义完成后不可以修改，或者添加，删除</span><br><span class="line">如何创建不可变集合：</span><br><span class="line">List，Set，Map接口中，都存在of方法可以创建不可变集合</span><br><span class="line">三种方式的细节：</span><br><span class="line">List：</span><br><span class="line">直接用</span><br><span class="line">Set：</span><br><span class="line">元素不能重复</span><br><span class="line">Map：</span><br><span class="line">元素不重复，键值对数量最多是10个</span><br><span class="line">超过10个用ofEntries方法</span><br><span class="line">（如果JDK超过10  可以用copyOf方法）</span><br><span class="line">Map&lt;String, String&gt; map = Map.copyOf(hashMap);</span><br></pre></td></tr></table></figure><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">Collections不是集合，而是集合的工具类</span><br><span class="line"></span><br><span class="line">Collections常用的API</span><br><span class="line"></span><br><span class="line">方法名称</span><br><span class="line">public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c,T...elements)</span><br><span class="line">批量添加元素</span><br><span class="line">public static void shuffke(List&lt;?&gt; list) </span><br><span class="line">打乱list集合元素的顺序。</span><br><span class="line">public static &lt;T&gt; void sort(List&lt;T&gt; List)</span><br><span class="line">排序</span><br><span class="line">public static &lt;T&gt; void sort(List&lt;T&gt; List,Comparator&lt;T&gt; c)</span><br><span class="line">根据指定的规则进行排序</span><br><span class="line">public static &lt;T&gt; int binarySearch(List&lt;T&gt;, T key)</span><br><span class="line">以二分查找法查找元素</span><br><span class="line">public static &lt;T&gt; void copy(List&lt;T&gt; dest,List&lt;T&gt; src)</span><br><span class="line">拷贝集合中的元素</span><br><span class="line">public static &lt;T&gt; int fill(List&lt;T&gt; list,T obj)</span><br><span class="line">使用指定的元素填充集合</span><br><span class="line">public static &lt;T&gt; void max/min(Collection&lt;T&gt; coll)</span><br><span class="line">根据默认的自然排序获取最大/最小值</span><br><span class="line">public static &lt;T&gt; void swap(List&lt;?&gt; list,int i,int j)</span><br><span class="line">交换集合中指定位置的元素</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JDK5</span><br><span class="line">可变参数</span><br><span class="line">方法形参的个数时可以发生变化的0 1 2 3......</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line">在形参中接收多个数据</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">数据类型...名字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">底层：</span><br><span class="line">可变参数底层就是一个数组</span><br><span class="line">只不过不需要我们自己创建了，java会帮我们创建好</span><br><span class="line"></span><br><span class="line">public static int getSum(int...args)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小细节：</span><br><span class="line">在方法的形参中可变参数最多可以写一个</span><br><span class="line">如果在方法中除了可变参数还有其他形参，那么可变参数要写在最后</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">泛型：</span><br><span class="line">是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查</span><br><span class="line"></span><br><span class="line">泛型的格式：</span><br><span class="line">&lt;数据类型&gt;</span><br><span class="line">注意：</span><br><span class="line">泛型只能支持引用数据类型</span><br><span class="line">如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合添加任意的数据类型，带来一个坏处，我们在获取数据的时候，无法使用他的特有行为</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展知识：</span><br><span class="line">Java中的泛型是伪泛型</span><br><span class="line">在Java文件中泛型存在，编译后泛型就不存在了</span><br><span class="line">叫做泛型的擦除</span><br><span class="line"></span><br><span class="line">泛型的细节：</span><br><span class="line">泛型中不能写基本数据类型</span><br><span class="line">指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型</span><br><span class="line">如果不写泛型，类型默认是Object</span><br><span class="line"></span><br><span class="line">泛型方法：</span><br><span class="line">方法中形参类型不确定时</span><br><span class="line">方案1：</span><br><span class="line">使用类名后面定义的泛型本类中所有的方法都能用</span><br><span class="line">方案2：</span><br><span class="line">在方法申明上定义自己的泛型只有本方法可以用</span><br><span class="line"></span><br><span class="line">泛型方法格式：</span><br><span class="line">修饰符&lt;类型&gt;返回值类型 方法名(类型 变量名)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//K T V E</span><br><span class="line">public &lt;T&gt; void show(T,t)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">泛型接口：</span><br><span class="line">格式：</span><br><span class="line">修饰符 interface 接口名&lt;类型&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">举例：</span><br><span class="line">public interface List&lt;E&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">重点：</span><br><span class="line">如何使用一个带泛型的接口</span><br><span class="line"></span><br><span class="line">方式1：</span><br><span class="line">实现类给出具体类型</span><br><span class="line">方式2：</span><br><span class="line">实现类延续泛型，创建对象时再确定</span><br></pre></td></tr></table></figure><h3 id="Lanmbda表达式"><a href="#Lanmbda表达式" class="headerlink" title="Lanmbda表达式"></a>Lanmbda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Lambda的省略规则</span><br><span class="line">    <span class="number">1.</span>参数类型可以省略不写</span><br><span class="line"><span class="number">2.</span>如果只有一个参数，参数类型可以省略，同时()也可以省略</span><br><span class="line"><span class="number">3.</span>如果Lambda表达式的方法体只有一行，大括号，分号，<span class="keyword">return</span>可以省略不写，需要同时省略</span><br><span class="line">    </span><br><span class="line">lambda表达式的标准格式</span><br><span class="line">() -&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Lambda表达式的基本作用：</span><br><span class="line">Lambda表达式可以用来简化匿名内部类的书写</span><br><span class="line">Lambda表达式只能简化函数式接口的匿名内部类的书写</span><br><span class="line"></span><br><span class="line">Lambda表达式有什么使用前提：</span><br><span class="line">    必须式接口的匿名内部类，接口中只能有一个抽象方法</span><br><span class="line">    </span><br><span class="line">Lambda的好处：</span><br><span class="line">    Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，它可以写出更简洁，更灵活的代码，作为一种更紧凑的代码风格，使Java语言表达能力得到了提升</span><br></pre></td></tr></table></figure><h3 id="计算机存储规则"><a href="#计算机存储规则" class="headerlink" title="计算机存储规则"></a>计算机存储规则</h3><p><img src="/posts/737a1d7/Snipaste_2023-03-04_14-40-29.png" alt="Snipaste_2023-03-04_14-40-29"></p><h3 id="重新认识main方法"><a href="#重新认识main方法" class="headerlink" title="重新认识main方法"></a>重新认识main方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">被jvm调用，访问权限足够大</span><br><span class="line">static：</span><br><span class="line">被jvm调用，不用创建对象，直接类名访问</span><br><span class="line">因为main方法是静态的，所以测试类中其他方法也需要是静态的</span><br><span class="line">void：</span><br><span class="line">被jvm调用，不需要给返回值</span><br><span class="line">main：</span><br><span class="line">一个通用的名称，虽然不是关键字，但是被jvm识别</span><br><span class="line">String[] args：</span><br><span class="line">以前用于接收键盘录入数据的，现在没用</span><br></pre></td></tr></table></figure><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方法的重写</span><br><span class="line">当父类的方法不能满足子类现在的需求时，需要进行方法的重写</span><br><span class="line">书写格式</span><br><span class="line">在继承体系中，子类出现了和父类一样的方法声明，我们就称为子类这个方法是重写的方法</span><br><span class="line"></span><br><span class="line">@Override重写注解</span><br><span class="line">1.@Override是重写后的方法上，校验子类重写时语法是否正确</span><br><span class="line">2.加上注解后如果有红色波浪线，表示语法错误</span><br><span class="line">3.建议重写方法都加@Override注解，代码安全，优雅。</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override重写注解</span><br><span class="line">1.@Override是重写后的方法上，校验子类重写时语法是否正确</span><br><span class="line">2.加上注解后如果有红色波浪线，表示语法错误</span><br><span class="line">3.建议重写方法都加@Override注解，代码安全，优雅。</span><br><span class="line"></span><br><span class="line">@FunctionalInterface函数式接口（Lambda表达式的时候使用）</span><br><span class="line">有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解判断</span><br></pre></td></tr></table></figure><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用其他类的规则</span><br><span class="line">使用同一个包中的类时，不需要导包</span><br><span class="line">使用java.lang包中的类时，不需要导包</span><br><span class="line">其他情况都需要导包</span><br><span class="line">如果同时使用两个包中的同名类，需要使用全类名</span><br></pre></td></tr></table></figure><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">代码块的分类</span><br><span class="line">局部代码块，构造代码块，静态代码块</span><br><span class="line"></span><br><span class="line">局部代码块</span><br><span class="line">提前结束变量的生命周期（已经淘汰）</span><br><span class="line">构造代码块</span><br><span class="line">抽取构造方法中的重复代码（不够灵活）</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">静态代码块</span><br><span class="line">数据的初始化 </span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">抽象类的作用是什么</span><br><span class="line">抽取共性时，无法确定方法体，就把方法定义为抽象的。</span><br><span class="line">强制让子类按照某种格式重写</span><br><span class="line">抽象方法所在的类，必须时抽象类</span><br><span class="line"></span><br><span class="line">抽象类和抽象方法的格式</span><br><span class="line">public abstract 返回值类型 方法名(参数列表);</span><br><span class="line">public abstract class 类名&#123;&#125;</span><br><span class="line"></span><br><span class="line">继承抽象类有哪些要注意</span><br><span class="line">要么重写抽象类中所有的方法</span><br><span class="line">要么时抽象类</span><br></pre></td></tr></table></figure><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设计模式是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性，程序的重用性</span><br></pre></td></tr></table></figure><h4 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">解决接口与接口实现类之间的矛盾问题</span><br><span class="line"></span><br><span class="line">当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以适配器设计模式</span><br><span class="line"></span><br><span class="line">书写步骤 </span><br><span class="line">编写中间类XXXAdapter，实现对应的接口</span><br><span class="line">对接口中的抽象方法进行空实现</span><br><span class="line">让真正的实现类继承中间类，并重写需要用的方法</span><br><span class="line">为了避免其他类创建适配器类的对象，中间的适配器类</span><br><span class="line">用abstract进行修饰</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">类的五大成员：</span><br><span class="line">属性，方法，构造方法，代码块，内部类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">内部类</span><br><span class="line">表示的事物是外部类的一部分</span><br><span class="line">内部类单独出现没有意义</span><br><span class="line"></span><br><span class="line">内部类的访问特点</span><br><span class="line">内部类可以直接访问外部类的成员，包括私有</span><br><span class="line">外部类要访问内部类的成员，必须创建对象</span><br><span class="line"></span><br><span class="line">成员内部类</span><br><span class="line">写在成员位置，属于外部类的成员</span><br><span class="line"></span><br><span class="line">获取成员内部类对象的两种方式</span><br><span class="line">方式一：</span><br><span class="line">当成员内部类被private修饰时</span><br><span class="line">在外部类中编写方法，对外提供内部类的对象</span><br><span class="line">方式二：</span><br><span class="line">当成员内部类被非私有修饰时，直接创建对象</span><br><span class="line">Outer.Inner oi = new Outter().new Inner();直接创建对象</span><br><span class="line">外部类成员变量和内部类成员变量重名时，在内部类中如何访问</span><br><span class="line">System.out.pringln(Outer.this.变量名);</span><br><span class="line"></span><br><span class="line">静态内部类</span><br><span class="line"></span><br><span class="line">局部内部类</span><br><span class="line"></span><br><span class="line">匿名内部类</span><br><span class="line">什么是匿名内部类：</span><br><span class="line">隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置</span><br><span class="line">匿名内部类的格式：</span><br><span class="line">new 类名或者接口名()&#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br><span class="line">格式的细节</span><br><span class="line">包含了继承或实现，方法重写，创建对象。</span><br><span class="line">整体就是一个类的子类对象或者接口的实现类对象</span><br><span class="line">使用场景</span><br><span class="line">当方法的参数是接口或者类时</span><br><span class="line">以接口为例，可以传递这个接口的实现类对象，</span><br><span class="line">如果实现类只使用一次，就可以用匿名内部类简化代码</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">事件源：</span><br><span class="line">按钮 图片 窗体...</span><br><span class="line">事件：某些操作</span><br><span class="line">如：鼠标单击，鼠标划入...</span><br><span class="line">绑定监听：</span><br><span class="line">当事件源上发生了某个事件，则执行某段代码</span><br><span class="line"></span><br><span class="line">KeryListener</span><br><span class="line">键盘监听</span><br><span class="line">MouseListener</span><br><span class="line">鼠标监听</span><br><span class="line">划入动作</span><br><span class="line">按下动作</span><br><span class="line">松开动作</span><br><span class="line">hua&#x27;chu</span><br><span class="line">ActionListener</span><br><span class="line">动作监听</span><br></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BigInteger构造方法注意：对象一旦创建，内部的值不能发生改变</span><br><span class="line">public BigInteger(int num, Random rnd)获取随机大整数 范围：[0~2的num次方-1]</span><br><span class="line">public BigInteger(String val)获取指定的大整数</span><br><span class="line">public BigInteger(String val, int radix) 获取指定进制的大整数</span><br><span class="line"></span><br><span class="line">public static BigInteger valueOf(long val)静态方法获取BigInteger的对象，内部有优化</span><br><span class="line"></span><br><span class="line">BigInteger构造方法小结</span><br><span class="line">如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取</span><br><span class="line">如果BigInteger表示的超出long的范围，可以用构造方法获取</span><br><span class="line">对象一旦创建，BigInteger内部记录的值不能发生改变</span><br><span class="line">只要进行计算都会产生一个新的BigInteger对象</span><br><span class="line"></span><br><span class="line">BigInteger成员方法</span><br><span class="line">public BigInteger add(BigInteger val)加法</span><br><span class="line">public BigInteger subtract(BigInteger val)减法</span><br><span class="line">public BigInteger multiply(BigInteger val)乘法</span><br><span class="line">public BigInteger divide(BigInteger val)除法，获取商</span><br><span class="line">public BigInteger divideAndRemainder(BigInteger val)除法，获取商和余数</span><br><span class="line">public BigInteger equals(Object x)比较是否相同</span><br><span class="line">public BigInteger pow(int exponent)次幂</span><br><span class="line">public BigInteger max/min(BigInteger val)返回较大值/较小值</span><br><span class="line">public int intValue(BigInteger val)转为int类型整数，超出范围数据有误</span><br></pre></td></tr></table></figure><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8种包装类中除了Character都有对应的parseXxx的方法进行类型</span><br></pre></td></tr></table></figure><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer的成员方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ToBinaryString</span><span class="params">(<span class="keyword">int</span> i)</span>得到二进制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ToOctalString</span><span class="params">(<span class="keyword">int</span> i)</span>得到八进制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ToHexString</span><span class="params">(<span class="keyword">int</span> i)</span>得到十六进制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span>将字符串类型的整数转成<span class="keyword">int</span>类型的整数</span></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">第一轮：</span><br><span class="line">把<span class="number">0</span>索引的数字作为基准数，确定基准数在数组中正确的位置。</span><br><span class="line">比基准数小的全部在左边，比基准数大的全部在右边。</span><br><span class="line">代码：</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义两个变量记录要查找的范围</span></span><br><span class="line">        <span class="keyword">int</span> start = i;</span><br><span class="line">        <span class="keyword">int</span> end = j;</span><br><span class="line">        <span class="comment">//递归的出口</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录基准数的值</span></span><br><span class="line">        <span class="keyword">int</span> baseNumber = arr[i];</span><br><span class="line">        <span class="comment">// 利用循环找到要交换的数字   5   3  2  7  6</span></span><br><span class="line">        <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">            <span class="comment">// 利用end，从后往前开始找，找比基准数小的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (end &lt;= start || arr[end] &lt; baseNumber) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 利用start，从前往后找，找比基准数大的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start &gt;= end || arr[start] &gt; baseNumber) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把end和start指向的元素进行交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当start和end指向了同一个元素的时候，那么上面的循环就会结束</span></span><br><span class="line">        <span class="comment">// 表示已经找到了基准数在数组中应存的位置</span></span><br><span class="line">        <span class="comment">// 基准数归位</span></span><br><span class="line">        <span class="comment">//就是拿着这个范围中的第一个数字，跟start指向的元素进行交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">        arr[start] = baseNumber;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">//确定6左边的范围，重复刚刚所做的事情</span></span><br><span class="line">        quickSort(arr,i,start-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//确定6右边的范围，重复刚刚所做的事情</span></span><br><span class="line">        quickSort(arr,start+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">操作数组的工具类：</span><br><span class="line">public static String toString(数组)  把数组拼接成一个字符串</span><br><span class="line">public static int binarySearch(数组,查找的元素)二分法查找元素</span><br><span class="line">public static int[] copyOf(原数组, 新数组长度)拷贝数组</span><br><span class="line">public static int[] copyOfRange(原数组,起始索引，结束索引)拷贝数组（指定范围）</span><br><span class="line">public static void fill(数组,元素)填充数组</span><br><span class="line">public static void sort(数组)按照默认方式进行数组排序</span><br><span class="line">public static void sort(数组,排序规则)按照指定的规则排序</span><br></pre></td></tr></table></figure><h3 id="数据结构（红黑树）"><a href="#数据结构（红黑树）" class="headerlink" title="数据结构（红黑树）"></a>数据结构（红黑树）</h3><p><img src="/posts/737a1d7/Snipaste_2023-03-20_08-42-16.png" alt="Snipaste_2023-03-20_08-42-16"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小结、复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web阶段注解分析</title>
      <link href="/posts/a85d6283/"/>
      <url>/posts/a85d6283/</url>
      
        <content type="html"><![CDATA[<h1 id="RequestParam-PathVariable和-RequestBody三者区别"><a href="#RequestParam-PathVariable和-RequestBody三者区别" class="headerlink" title="@RequestParam,@PathVariable和@RequestBody三者区别"></a>@RequestParam,@PathVariable和@RequestBody三者区别</h1><h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">顾名思义：路径变量，即是获取链接url路径上的变量</span><br><span class="line">  例如</span><br><span class="line">http:<span class="comment">//localhost:8090/hello/2</span></span><br><span class="line">  代码</span><br><span class="line"><span class="comment">//使用@PathVariable注解获取id</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//则   id的值为2</span></span><br><span class="line">&#125;</span><br><span class="line">注意：路径变量名要与参数名要一致</span><br></pre></td></tr></table></figure><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">顾名思义：获取参数，即是获取传送过来的参数；例如获取下面链接的id参数值</span><br><span class="line">  例如</span><br><span class="line">http:<span class="comment">//localhost:8090/hello?id=2</span></span><br><span class="line">  代码</span><br><span class="line"><span class="comment">//使用@RequestParam注解获取id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;链接中请求参数的id：&quot;</span>+id);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时@RequestParam的作用就可以获取id下来并且作为形参传给方法体里面的id</span></span><br></pre></td></tr></table></figure><h4 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="@RequestBody注解"></a>@RequestBody注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">首先说下，<span class="meta">@RequestBody</span>注解一般主要是用来处理content-type:<span class="string">&quot;application/json charset=utf-8&quot;</span>或者content-type:<span class="string">&quot;application/xml charset=utf-8&quot;</span>两种请求数据，一般是异步请求用的比较多些，简而言之就是json和xml。</span><br><span class="line">    例如</span><br><span class="line"><span class="comment">//异步请求部分代码</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">　　　　　url:<span class="string">&quot;/hello&quot;</span>,</span><br><span class="line">　　　　　type:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">　　　　　data:<span class="string">&#x27;&#123;&quot;id&quot;:&quot;123&quot;,&quot;name&quot;:&quot;Mr.Q&quot;&#125;&#x27;</span>,</span><br><span class="line">　　　　　content-type:<span class="string">&quot;application/json charset=utf-8&quot;</span>,</span><br><span class="line">　　　　　success:function(data)&#123;</span><br><span class="line">　　　　　　　alert(data);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//@RequestBody注解获取数据代码</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@RequestBody</span> Integer id,<span class="meta">@RequestBody</span> String name)</span></span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;;&quot;</span>+<span class="string">&quot;name:&quot;</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意的是 如果有一个User类的话（类中包含id和name的成员变量）</span></span><br><span class="line"><span class="comment">//那么代码可以写为</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line"><span class="comment">// 此时user中就封装了id和name　　　　　</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个关于hexo提供下载的尝试</title>
      <link href="/posts/345212/"/>
      <url>/posts/345212/</url>
      
        <content type="html"><![CDATA[<h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">步骤如下：</span><br><span class="line">1.修改配置文件</span><br><span class="line">修改_config.yml 里的 post_asset_folder: 这个选项设置为True</span><br><span class="line">2.在_post的同级目录下创建download的文件夹。</span><br><span class="line">3.在文章里引用文件，通过如[点击下载](/download/xx.zip)这样的链接。</span><br><span class="line">4.在文章中引用图片，通过 ![pic](/download/image-20191211200232715.png)这样写入。</span><br></pre></td></tr></table></figure><p><a href="/download/x64_Patch.zip">typora下载链接</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个typora的激活插件</span><br></pre></td></tr></table></figure><p><a href="/download/NavicatCrack.zip">NavicatCrack下载链接</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个Navicat破解的软件</span><br></pre></td></tr></table></figure><p><img src="/posts/345212/2-1684200807297-1.png" alt="pic"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 尝试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web总结</title>
      <link href="/posts/8ffbbb9f/"/>
      <url>/posts/8ffbbb9f/</url>
      
        <content type="html"><![CDATA[<h1 id="Day01-HTML-amp-CSS-amp-JS"><a href="#Day01-HTML-amp-CSS-amp-JS" class="headerlink" title="Day01 - HTML&amp;CSS&amp;JS"></a>Day01 - HTML&amp;CSS&amp;JS</h1><h2 id="1-web"><a href="#1-web" class="headerlink" title="1.web"></a>1.web</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是web？</span><br><span class="line">万维网，浏览器可以访问的网站</span><br></pre></td></tr></table></figure><h2 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2.HTML"></a>2.HTML</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是HTML？</span><br><span class="line">超文本标记语言</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML的作用？</span><br><span class="line">控制 网页结构</span><br></pre></td></tr></table></figure><h3 id="2-1-HTML基础标签"><a href="#2-1-HTML基础标签" class="headerlink" title="2.1 HTML基础标签"></a>2.1 HTML基础标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【文本标签】</span><br><span class="line">标题：&lt;h1&gt; &lt;h6&gt;</span><br><span class="line">定义文本颜色、大小、字体：&lt;font color=&quot;&quot; size=&quot;&quot; face=&quot;&quot;&gt;</span><br><span class="line">斜体：&lt;i&gt;</span><br><span class="line">加粗：&lt;b&gt;</span><br><span class="line">下划线：&lt;u&gt;</span><br><span class="line">居中：&lt;center&gt;</span><br><span class="line">段落：&lt;p&gt;</span><br><span class="line">换行：&lt;br&gt;</span><br><span class="line">水平线：&lt;hr&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【图片及音视频标签】</span><br><span class="line">图片：&lt;img src=&quot;&quot; height=&quot;&quot; width=&quot;&quot;&gt;</span><br><span class="line">音频：&lt;audio src=&quot;&quot; controls&gt;</span><br><span class="line">视频：&lt;video src=&quot;&quot; controls&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【超链接及表格标签】</span><br><span class="line">超链接：&lt;a href=&quot;&quot; target=&quot;&quot;&gt;</span><br><span class="line">表格：&lt;table&gt;</span><br><span class="line">行：&lt;tr&gt;</span><br><span class="line">单元格：&lt;td&gt;</span><br><span class="line">表头：&lt;th&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【布局标签】</span><br><span class="line">定义html中区域：&lt;div&gt;</span><br><span class="line">定义行内元素：&lt;span&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-HTML表单标签"><a href="#2-2-HTML表单标签" class="headerlink" title="2.2 HTML表单标签"></a>2.2 HTML表单标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【表单】：&lt;form action=&quot;&quot; method=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【GET和POST的区别】：</span><br><span class="line">GET：表单数据拼接到url后，有大小限制</span><br><span class="line">POST：表单数据封装到请求体中，无大小限制</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【表单项】：</span><br><span class="line">&lt;input&gt;：表单项，通过type来控制输入形式</span><br><span class="line">文本输入框：text</span><br><span class="line">密码：password</span><br><span class="line">单选按钮：radio</span><br><span class="line">复选框：checkbox</span><br><span class="line">文件：file</span><br><span class="line">隐藏域：hidden</span><br><span class="line">提交按钮：submit</span><br><span class="line">重置按钮：reset</span><br><span class="line">可点击按钮：button</span><br><span class="line">&lt;select&gt;：下拉列表，多个&lt;option&gt;指定下拉列表具体内容</span><br><span class="line">&lt;textarea&gt;：文本域</span><br></pre></td></tr></table></figure><h2 id="3-CSS"><a href="#3-CSS" class="headerlink" title="3. CSS"></a>3. CSS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSS的作用？</span><br><span class="line">控制页面的样式</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSS三种引入方式？</span><br><span class="line">内联方式：直接在标签中使用style属性配置样式</span><br><span class="line">内部方式：在head标签中使用&lt;style&gt;标签定义样式</span><br><span class="line">外部方式：在head标签中使用&lt;link&gt;标签引入外部css文件 从而引入样式</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSS三种选择器</span><br><span class="line">元素选择器：所有使用了该标签的元素 都会适配 定义的样式 div&#123;&#125;</span><br><span class="line">id选择器：唯一，只能选择上一个元素  #id名&#123;&#125;</span><br><span class="line">class选择器：可以选择一类元素，也就是多个元素 .class名&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-JS"><a href="#4-JS" class="headerlink" title="4. JS"></a>4. JS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JS的作用？</span><br><span class="line">控制网页的行为</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS的书写语法？</span><br><span class="line">1.区分大小写</span><br><span class="line">2.行尾的可有可无 建议写上</span><br><span class="line">3.注释 单行注释//  多行注释 /* */</span><br><span class="line">4.&#123;&#125;代表代码块</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JS声明变量的关键字？</span><br><span class="line">全局变量 var</span><br><span class="line">局部变量 let</span><br><span class="line">常量 const</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JS控制语句 哪些会返回false？</span><br><span class="line">0、NaN、空字符串、null、undefined 都返回false，其余都返回 true</span><br></pre></td></tr></table></figure><h1 id="Day02-JS-amp-Vue"><a href="#Day02-JS-amp-Vue" class="headerlink" title="Day02 - JS &amp; Vue"></a>Day02 - JS &amp; Vue</h1><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JS中函数定义的两种方式？</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add = function(a,b)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-JS中的对象"><a href="#2-JS中的对象" class="headerlink" title="2. JS中的对象"></a>2. JS中的对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【Array】</span><br><span class="line">属性</span><br><span class="line">获取数组长度：length</span><br><span class="line">方法</span><br><span class="line">遍历数组：forEach()</span><br><span class="line">添加元素到末尾：push()</span><br><span class="line">删除元素：splice()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【String】</span><br><span class="line">属性</span><br><span class="line">获取字符串长度：length</span><br><span class="line">方法</span><br><span class="line">获取指定角标的字符：charAt()</span><br><span class="line">获取指定字符串的索引：indexOf()</span><br><span class="line">去除字符串两端的空格：trim()</span><br><span class="line">字符串截取：subString()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【JSON】</span><br><span class="line">定义json：</span><br><span class="line">1. 键值对类型</span><br><span class="line">2. 所有键都要用&quot;&quot;括起来</span><br><span class="line">3. 值：</span><br><span class="line">String：用&quot;&quot;括起来</span><br><span class="line">数字：直接写</span><br><span class="line">boolean：直接写true、false</span><br><span class="line">数组：[]</span><br><span class="line">对象：&#123;&#125;</span><br><span class="line">json字符串 转json对象：JSON.parse</span><br><span class="line">js对象 转 json串：JSON.Stringify()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【BOM】浏览器对象模型</span><br><span class="line">window对象的方法</span><br><span class="line">弹出警告框：alert()</span><br><span class="line">弹出对话框：confirm()</span><br><span class="line">周期执行的定时器：setInterval()</span><br><span class="line">一次性执行的定时器：setTimeout()</span><br><span class="line">location对象：</span><br><span class="line">设置或者获取url的属性：href</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【DOM】文档对象模型</span><br><span class="line">使用document对象获取Element元素对象</span><br><span class="line">根据id获取元素：getElementById()</span><br><span class="line">根据标签获取元素：getElementsByTagName()</span><br><span class="line">根据名称获取元素：getElementsByName()</span><br><span class="line">根据类名获取元素：getElementsByClassName()</span><br></pre></td></tr></table></figure><h2 id="3-事件监听"><a href="#3-事件监听" class="headerlink" title="3. 事件监听"></a>3. 事件监听</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如何为元素绑定事件？</span><br><span class="line">1.在html标签中 使用 事件属性 进行绑定</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;事件绑定1&quot; onclick=&quot;on()&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function on()&#123;</span><br><span class="line">        alert(&quot;按钮1被点击了...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">2.使用DOM中的Element元素的事件属性进行绑定</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;事件绑定2&quot;&gt;</span><br><span class="line">document.getElementById(&#x27;btn2&#x27;).onclick = function()&#123;</span><br><span class="line">    alert(&quot;按钮2被点击了...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常见的事件？</span><br><span class="line">鼠标单击：onclick</span><br><span class="line">元素失去焦点：onblur</span><br><span class="line">元素获取焦点：onfocus</span><br><span class="line">页面加载完成：onload</span><br><span class="line">表单提交：onsubmit</span><br><span class="line">键盘的按键被按下：onkeydown</span><br><span class="line">鼠标移到元素上：onmouseover</span><br><span class="line">鼠标从元素上移开：onmouseout</span><br></pre></td></tr></table></figure><h2 id="4-Vue"><a href="#4-Vue" class="headerlink" title="4. Vue"></a>4. Vue</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue常见指令的作用：</span><br><span class="line">v-bind：给html标签中的属性绑定数据模型</span><br><span class="line">v-model：双向绑定，数据模型和view</span><br><span class="line">v-if：条件控制，条件成立则渲染元素，条件不成立则不渲染</span><br><span class="line">v-show：条件控制，不管条件是否成立都会渲染元素，通过display属性控制元素是否要展示</span><br><span class="line">v-for：遍历</span><br><span class="line">v-on：绑定事件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue的生命周期方法：Vue挂载完成会调用哪个方法？</span><br><span class="line">mounted() vue挂载完成/页面加载完成 后会自动调用该方法</span><br></pre></td></tr></table></figure><h1 id="Day03-Vue-amp-Element"><a href="#Day03-Vue-amp-Element" class="headerlink" title="Day03 - Vue&amp;Element"></a>Day03 - Vue&amp;Element</h1><h2 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1. Ajax"></a>1. Ajax</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过Axios请求发送ajax请求 的两种方式</span><br><span class="line">axios.get(&quot;url&quot;).then(result =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.post(&quot;url&quot;，&quot;id=1&quot;).then(result =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-前后端分离开发"><a href="#2-前后端分离开发" class="headerlink" title="2. 前后端分离开发"></a>2. 前后端分离开发</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">好处：</span><br><span class="line">便于开发、便于维护</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前后端分离的开发模式是什么样的？</span><br><span class="line">前端开发前端代码，后端开发后端代码，后端定义接口文档（请求方式、请求路径、前后端、出参），前后端都按照接口文档进行开发即可</span><br></pre></td></tr></table></figure><h2 id="3-前端工程化开发"><a href="#3-前端工程化开发" class="headerlink" title="3. 前端工程化开发"></a>3. 前端工程化开发</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前端工程化开发的步骤：</span><br><span class="line">1. 安装NodeJs</span><br><span class="line">2. 安装Vue-cli</span><br><span class="line">------上述为一次性操作------</span><br><span class="line"></span><br><span class="line">3. 使用Vue-cli生成vue工程</span><br></pre></td></tr></table></figure><h2 id="4-ElementUI"><a href="#4-ElementUI" class="headerlink" title="4. ElementUI"></a>4. ElementUI</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ElementUI的作用：组件库</span><br><span class="line">让我们可以开发美观的前端页面</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如何进行ElementUI开发</span><br><span class="line">1.安装ElementUI</span><br><span class="line">2.在main.js文件中引入了ElementUI</span><br><span class="line">------上述为一次性操作------</span><br><span class="line"></span><br><span class="line">3.开发vue代码 到ElementUI官网复制粘贴</span><br><span class="line">（1）Html：template （2）js：script （3）css：style</span><br><span class="line">4.在App.vue中引入.vue文件</span><br></pre></td></tr></table></figure><h2 id="5-Vue路由"><a href="#5-Vue路由" class="headerlink" title="5. Vue路由"></a>5. Vue路由</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue路由的作用是什么？</span><br><span class="line">vue路由 是一个路径管理器，它的作用是 当我们点击页面上一个按钮 后url发生变化，在页面中展示对应的视图</span><br></pre></td></tr></table></figure><h2 id="6-前端工程打包部署"><a href="#6-前端工程打包部署" class="headerlink" title="6. 前端工程打包部署"></a>6. 前端工程打包部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何在Nigix服务器上部署前端代码？</span><br><span class="line">1. 打包前端代码，把dist里的代码复制粘贴到 nigix的html目录下</span><br><span class="line">2. 双击nigix.exe启动服务</span><br></pre></td></tr></table></figure><h1 id="Day04-Maven-amp-SpringBootWeb入门"><a href="#Day04-Maven-amp-SpringBootWeb入门" class="headerlink" title="Day04 - Maven&amp;SpringBootWeb入门"></a>Day04 - Maven&amp;SpringBootWeb入门</h1><h2 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1. Maven"></a>1. Maven</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Maven的作用是什么？</span><br><span class="line">项目管理和构建工具</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Maven的安装与配置</span><br><span class="line">按照文档安装配置即可。如果clean都报错，必定maven配置有问题</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Maven的仓库有哪几类？</span><br><span class="line">本地仓库</span><br><span class="line">私服</span><br><span class="line">中央仓库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何使用Maven配置依赖？如何排除依赖？</span><br><span class="line">&lt;dependencies&gt; </span><br><span class="line">&lt;exclusions&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">依赖传递性</span><br><span class="line">如果A依赖B，B依赖C，则A依赖C</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">依赖的范围有哪些？</span><br><span class="line">compile（默认）</span><br><span class="line">test</span><br><span class="line">provided</span><br><span class="line">runtime</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Maven常见的生命周期</span><br><span class="line">clean、compile、test、package、install</span><br></pre></td></tr></table></figure><h2 id="2-SpringBoot入门程序"><a href="#2-SpringBoot入门程序" class="headerlink" title="2.SpringBoot入门程序"></a>2.SpringBoot入门程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）创建SpringBoot</span><br><span class="line">（2）编写请求处理器类 HelloController</span><br><span class="line">@RestController 代表此类是请求处理器类</span><br><span class="line">@RequestMapping 映射请求路径和后端方法</span><br><span class="line">（3）启动服务</span><br><span class="line">运行SpringBoot主启动类</span><br><span class="line">@SpringBootApplication 标识此类是SpringBoot的主启动类</span><br><span class="line"></span><br><span class="line">扩展：pom.xml文件</span><br><span class="line">&lt;parent&gt; 为当前pom制定了父pom，父pom中锁定了依赖的版本号，好处是减少依赖冲突</span><br><span class="line">starter 起步依赖：帮我们引入了许多依赖，简化了依赖配置</span><br></pre></td></tr></table></figure><h2 id="3-HTTP协议"><a href="#3-HTTP协议" class="headerlink" title="3. HTTP协议"></a>3. HTTP协议</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是HTTP协议？</span><br><span class="line">超文本传输协议，规定了浏览器和服务器之间数据传输的规则</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP请求信息都有哪些部分？</span><br><span class="line">请求行、请求头、请求体</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP响应信息都有哪些部分？</span><br><span class="line">响应行、响应头、响应体</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP状态码分别代表什么含义？</span><br><span class="line">1 开头：处理中，临时状态</span><br><span class="line">2 开头：成功</span><br><span class="line">3 开头：重定向</span><br><span class="line">4 开头：浏览器错误</span><br><span class="line">5 开头：服务器错误</span><br><span class="line"></span><br><span class="line">常见的状态：200/404/500</span><br></pre></td></tr></table></figure><h2 id="4-Tomcat服务器"><a href="#4-Tomcat服务器" class="headerlink" title="4. Tomcat服务器"></a>4. Tomcat服务器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装：解压</span><br><span class="line">启动：/bin/startup.bat</span><br><span class="line">部署项目：把项目代码复制到tomcat安装目录下的webapp目录中</span><br></pre></td></tr></table></figure><h1 id="Day05-SpringBootWeb请求响应"><a href="#Day05-SpringBootWeb请求响应" class="headerlink" title="Day05 - SpringBootWeb请求响应"></a>Day05 - SpringBootWeb请求响应</h1><h2 id="1-PostMan"><a href="#1-PostMan" class="headerlink" title="1. PostMan"></a>1. PostMan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postman的作用？</span><br><span class="line">做接口测试</span><br></pre></td></tr></table></figure><h3 id="1-1-不同-请求类型-发送请求"><a href="#1-1-不同-请求类型-发送请求" class="headerlink" title="1.1 不同 请求类型 发送请求"></a>1.1 不同 请求类型 发送请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET：参数放在请求行的url后，使用postman放在param中</span><br><span class="line">POST:参数放在请求体中，使用postman放在body</span><br></pre></td></tr></table></figure><h3 id="1-2-不同-参数类型-发送与接收请求"><a href="#1-2-不同-参数类型-发送与接收请求" class="headerlink" title="1.2 不同 参数类型 发送与接收请求"></a>1.2 不同 参数类型 发送与接收请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单类型/实体类：</span><br><span class="line">前端：前端请求参数 和 后端形参保持一致即可</span><br><span class="line">后端：后端用简单类型或实体类接收，如果参数名不一致，要加 @RequestParam(name=&quot;前端参数名&quot;)绑定参数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组/集合：</span><br><span class="line">前端：前端请求参数 和 后端形参保持一致；参数写多个</span><br><span class="line">后端：使用数组或集合接收，如果用集合接收，形参前要加一个@RequestParam绑定参数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日期：</span><br><span class="line">前端：按照后端指定的日期格式进行传参</span><br><span class="line">后端：使用@DateTimeFormat(pattern=&quot;&quot;)指定日期格式</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json格式：</span><br><span class="line">前端：要使用post方式，选择body-》row-》json进行传参</span><br><span class="line">后端：使用实体类接收，实体类前添加@RequestBody注解</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">路径格式：</span><br><span class="line">前端：/path/1</span><br><span class="line">后端：在路径中使用&#123;id&#125;作为占位符；形参和路径中的参数变量保持一致；形参前要添加@PathVariable</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【总结】</span><br><span class="line">前端：</span><br><span class="line">前端请求参数 和 后端形参保持一致</span><br><span class="line">json传参：body -》 row -》json</span><br><span class="line">后端：</span><br><span class="line">如果请求参数名和形参不一致 或 使用List接收数据 形参前要添加@RequestParam</span><br><span class="line">如果是日期传参，要添加 @DateTimeFormat(pattern=&quot;&quot;)</span><br><span class="line">如果是json传参，要添加 @RequestBody</span><br><span class="line">如果是路径变量传参：路径要加&#123;&#125;占位符，形参前要添加@PathVariable</span><br></pre></td></tr></table></figure><h3 id="1-3-返回响应"><a href="#1-3-返回响应" class="headerlink" title="1.3 返回响应"></a>1.3 返回响应</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回响应需要用到哪个注解？</span><br><span class="line">@ResponseBody把当前方法返回值放在响应体中，如果返回值是实体类或集合，会默认转换成json格式，并放到响应体中</span><br></pre></td></tr></table></figure><h2 id="2-分层架构"><a href="#2-分层架构" class="headerlink" title="2.分层架构"></a>2.分层架构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三层架构中每一层的职责：</span><br><span class="line">controller：控制层 用于接收请求和返回响应</span><br><span class="line">service：业务逻辑处理层</span><br><span class="line">dao：数据操作层（持久层）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分层后各层之间的解耦思路</span><br><span class="line">高内聚低耦合</span><br><span class="line">内聚：单个模块内部功能联系程度，越高越好 UserController内部只处理用户相关功能，不处理其他功能</span><br><span class="line">耦合：各个模块之间功能联系程度，越低越好 UserController和OrderController之间依赖影响越低越好</span><br><span class="line"></span><br><span class="line">实现思路：使用Spring容器中的IOC和DI</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring容器的作用是什么？</span><br><span class="line">背景：Springboot基于Spring的框架，Spring容器是Spring的组件</span><br><span class="line">作用：创建并管理对象</span><br></pre></td></tr></table></figure><h2 id="3-IOC和DI"><a href="#3-IOC和DI" class="headerlink" title="3. IOC和DI"></a>3. IOC和DI</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是IOC？（Inverse Of Controller）</span><br><span class="line">控制反转，反转的是对象的创建权，从程序员new对象 反转为 Spring容器 new对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是DI？</span><br><span class="line">依赖注入，给容器中bean的属性赋值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">声明bean的注解？（即把对象放入容器中的注解）</span><br><span class="line">@Component</span><br><span class="line">@Controller</span><br><span class="line">@Service</span><br><span class="line">@Repository</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">依赖注入的注解?</span><br><span class="line">@Autowired：按照类型注入</span><br><span class="line">@Qualifier：按照名称注入 要和@Autowired搭配使用</span><br><span class="line">@Resource：按照名称注入 = @Autowired + @Qualifier</span><br></pre></td></tr></table></figure><h1 id="Day06-MySQL"><a href="#Day06-MySQL" class="headerlink" title="Day06 - MySQL"></a>Day06 - MySQL</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mysql数据库的作用</span><br><span class="line">存储和管理数据的仓库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mysql数据库的使用</span><br><span class="line">安装 ：解压</span><br><span class="line">启动 ：net start mysql</span><br><span class="line">连接 ：mysql -uroot -proot</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见Sql语句的分类</span><br><span class="line">DDL：数据库定义语言，对库和表进行增删改查</span><br><span class="line">DML: 数据库操作语言，对表中的数据进行增删改</span><br><span class="line">DQL: 数据库查询语言，对表中数据进行查询</span><br><span class="line">DCL: 数据库控制语言，用于控制权限</span><br></pre></td></tr></table></figure><h2 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2.DDL"></a>2.DDL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">常见DDL语句</span><br><span class="line">【数据库】</span><br><span class="line">创建：create database db01;</span><br><span class="line">查询：show databases;</span><br><span class="line">使用：use db01;</span><br><span class="line">删除：drop database db01;</span><br><span class="line">创建：</span><br><span class="line">create table user(</span><br><span class="line">字段名 字段类型 [约束]  [comment &#x27;字段说明&#x27;],</span><br><span class="line">...</span><br><span class="line">字段名 字段类型 [约束]  [comment &#x27;字段说明&#x27;]</span><br><span class="line">)comment &#x27;用户表&#x27;;</span><br><span class="line">查询 掌握图形化界面使用</span><br><span class="line">修改</span><br><span class="line">删除</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">约束</span><br><span class="line">非空约束 not null</span><br><span class="line">唯一约束 unique</span><br><span class="line">主键约束 primary key</span><br><span class="line">默认约束 default</span><br><span class="line">外键约束 foreign key</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如何根据产品原型和需求设计数据库和表结构？</span><br><span class="line">表结构设计：</span><br><span class="line">原型字段：需要哪些字段、字段类型、约束</span><br><span class="line">基础字段：id、create_time、update_time</span><br><span class="line">表结构：原型字段 + 基础字段</span><br></pre></td></tr></table></figure><h2 id="3-DML"><a href="#3-DML" class="headerlink" title="3. DML"></a>3. DML</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新增数据：</span><br><span class="line">insert into 表名(字段列表) values(字段值列表)，(字段值列表)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改数据：</span><br><span class="line">update 表名 set 字段名1=字段值1，字段名2=字段值2 where 条件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除数据：</span><br><span class="line">delete from 表名 where 条件</span><br></pre></td></tr></table></figure><h1 id="Day07-MySQL多表"><a href="#Day07-MySQL多表" class="headerlink" title="Day07 - MySQL多表"></a>Day07 - MySQL多表</h1><h2 id="1-DQL"><a href="#1-DQL" class="headerlink" title="1. DQL"></a>1. DQL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DQL语法：</span><br><span class="line">select</span><br><span class="line">字段列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where</span><br><span class="line">条件列表</span><br><span class="line">group by </span><br><span class="line">分组列表</span><br><span class="line">having</span><br><span class="line">分组过滤条件列表</span><br><span class="line">order by</span><br><span class="line">排序字段列表</span><br><span class="line">limit</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【基础查询】</span><br><span class="line">select 字段列表 from 表名</span><br><span class="line"></span><br><span class="line">select * from 表名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【条件查询】</span><br><span class="line">比较运算符：</span><br><span class="line">数学运算符：&gt; &gt;= &lt; &lt;= =</span><br><span class="line">不等于：!=  &lt;&gt;</span><br><span class="line">范围：between and （包含最大值和最小值）</span><br><span class="line">列表中多选一：in()</span><br><span class="line">模糊查询：like</span><br><span class="line">占位符：</span><br><span class="line">_:一个任意字符</span><br><span class="line">%:0个或多个任意字符</span><br><span class="line">是null：is null</span><br><span class="line">逻辑运算符：</span><br><span class="line">并且：and</span><br><span class="line">或：or</span><br><span class="line">不是：not !</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【聚合】</span><br><span class="line">查询数量：count(*)</span><br><span class="line">最大值：max()</span><br><span class="line">最小值：min()</span><br><span class="line">平均值：avg()</span><br><span class="line">求和：sum()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【分组】</span><br><span class="line">group by ... having</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【排序】</span><br><span class="line">order by</span><br><span class="line">排序方式：</span><br><span class="line">asc:升序 （默认）</span><br><span class="line">desc：降序</span><br><span class="line">如果排序字段有多个，那么先按照第一个字段排序，如果第一个字段相等，再按照第二个字段进行排序</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【分页查询】</span><br><span class="line">limit 起始索引, 每页查询数量</span><br><span class="line"></span><br><span class="line">起始索引 从0开始</span><br><span class="line">起始索引 = （查询页数 - 1） * 每页查询数量</span><br></pre></td></tr></table></figure><h2 id="2-多表"><a href="#2-多表" class="headerlink" title="2. 多表"></a>2. 多表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表之间的关系有哪三种，分别怎么维护？</span><br><span class="line">一对一：任意在一个表中建立另一个表的外键</span><br><span class="line">一对多：在多对应的表中 建立 一对应的表的外键</span><br><span class="line">多对多：建立中间表，中间表中分别建立另两张表的外键</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外键的作用</span><br><span class="line">可以通过外键关联到另外一张表的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多表设计的思路和流程</span><br><span class="line">1.根据需求文档和页面原型 分析 表关系</span><br><span class="line">2.根据需求文档和页面原型 分析 表结构</span><br><span class="line">字段、字段类型、约束</span><br><span class="line">3.创建表</span><br></pre></td></tr></table></figure><h1 id="Day08-MySQL-amp-MyBatis入门"><a href="#Day08-MySQL-amp-MyBatis入门" class="headerlink" title="Day08 - MySQL&amp;MyBatis入门"></a>Day08 - MySQL&amp;MyBatis入门</h1><h2 id="1-多表查询"><a href="#1-多表查询" class="headerlink" title="1. 多表查询"></a>1. 多表查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">连接查询的基础语法</span><br><span class="line">内连接：</span><br><span class="line">隐式内连接：</span><br><span class="line">select * from 表A, 表B where 关联条件</span><br><span class="line">显式内连接：</span><br><span class="line">select * from 表A</span><br><span class="line">join 表B on 关联条件</span><br><span class="line">外连接：</span><br><span class="line">左连接：</span><br><span class="line">select * from 表A</span><br><span class="line">left join 表B on 关联条件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内连接和外连接的区别？</span><br><span class="line">内连接：取两张表的交集</span><br><span class="line">外连接：取左表的全部数据 和 右表能关联上的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">子查询</span><br><span class="line">标量子查询：常量 = &lt; &lt;= &gt; &gt;=</span><br><span class="line">列子查询：子查询结果只有一列，可以认为是一个列表   in</span><br><span class="line">行子查询：子查询结果只有一行 </span><br><span class="line">表子查询：子查询结果是一张临时表，可以把子查询结果当做一张临时表使用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如何完成多表查询操作？</span><br><span class="line">1. 分析要查询哪些字段</span><br><span class="line">2. 看这些字段在哪些表中</span><br><span class="line">3. 分析表之间的关联条件</span><br><span class="line">4. 查看是否有其他条件</span><br></pre></td></tr></table></figure><h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2. 事务"></a>2. 事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是事务？</span><br><span class="line">事务是多个操作的集合，这些操作要么同时成功，要么同时失败</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何开启事务、提交事务、回滚事务？</span><br><span class="line">开启事务：start transation; / begin;</span><br><span class="line">提交事务：commit;</span><br><span class="line">回滚事务：rollback;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事务的四大特性是什么？</span><br><span class="line">原子性、一致性、隔离性、持久性</span><br></pre></td></tr></table></figure><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">什么是索引？</span><br><span class="line">是一种提高查询效率的数据结构，B+Tree(多路平衡搜索树)</span><br><span class="line">优点：提高查询效率和排序效率</span><br><span class="line">缺点：占用空间，数据增删改的时候维护索引需要性能开销</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">索引的操作</span><br><span class="line">创建：create index 索引名 on 表名(字段名)</span><br><span class="line">删除：drop index 索引名 on 表名</span><br><span class="line">查询：show index from 表名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MySQL数据库索引的数据结构</span><br><span class="line">B+Tree(多路平衡搜索树)</span><br><span class="line">（1）每个节点上有多个key，也就有多路分支</span><br><span class="line">（2）所有数据都存储在叶子节点，非叶子节点只存储索引</span><br><span class="line">（3）叶子节点是天然有序的双向链表，便于数据的排序和范围查询</span><br></pre></td></tr></table></figure><h2 id="4-Mybatis入门"><a href="#4-Mybatis入门" class="headerlink" title="4. Mybatis入门"></a>4. Mybatis入门</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot-Mybatis入门程序</span><br><span class="line">1. 准备工作：创建数据库和表，创建了工程，user实体类</span><br><span class="line">2. 在application.properties中 配置数据库连接：驱动、url、username、password</span><br><span class="line">3. 编写Mapper接口，@Mapper @Select(&quot;select * from user&quot;)</span><br><span class="line">4. 测试</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是数据库驱动？</span><br><span class="line">java程序连接数据库的工具</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是JDBC ？</span><br><span class="line">JDBC是用于操作 数据库驱动这个工具 的API接口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库连接池的作用？</span><br><span class="line">数据库连接池 是一个容器，用于创建、管理数据库连接</span><br></pre></td></tr></table></figure><h1 id="Day09-Mybatis"><a href="#Day09-Mybatis" class="headerlink" title="Day09 - Mybatis"></a>Day09 - Mybatis</h1><h2 id="1-Mybatis基础操作"><a href="#1-Mybatis基础操作" class="headerlink" title="1. Mybatis基础操作"></a>1. Mybatis基础操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">预编译SQL的优势是什么？</span><br><span class="line">更高效：把预编译的sql缓存了起来</span><br><span class="line">更安全：防止sql注入，把密码当做一整个字符串传入sql语句，如果密码中有引号，会进行转义</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数占位符$&#123;&#125; 与 #&#123;&#125;的区别</span><br><span class="line">$&#123;&#125;：直接把参数拼装到sql中，不能防止sql注入</span><br><span class="line">#&#123;&#125;：使用预编译的方式 把参数做为一个整体 替换 ?, 可以防止sql注入</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis开发增删改查接口分别使用哪个注解？</span><br><span class="line">增：@Insert</span><br><span class="line">删：@Delete</span><br><span class="line">改：@Update</span><br><span class="line">查：@Select</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新增数据如何获取到主键?</span><br><span class="line">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span><br></pre></td></tr></table></figure><h2 id="2-基于XML开发Mybatis"><a href="#2-基于XML开发Mybatis" class="headerlink" title="2. 基于XML开发Mybatis"></a>2. 基于XML开发Mybatis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mybatis中XML映射文件的开发规范</span><br><span class="line">1.同包同名: xml文件和mapper文件的包名、文件名保持一致</span><br><span class="line">2.xml的namespace 和 mapper的全限定类名保持一致</span><br><span class="line">3.xml中的id 和 mapper的方法名保持一致</span><br><span class="line">只有按照这个格式开发，将来调用到mapper中的方法，才能找到xml文件中对应的sql语句</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;if&gt;标签的作用和用法</span><br><span class="line">作用：如果if标签中条件成立，则拼接sql，否则不拼接</span><br><span class="line">用法：&lt;if test=&quot;name != null&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;where&gt;和&lt;set&gt;标签的应用场景和作用</span><br><span class="line">应用场景：</span><br><span class="line">&lt;where&gt;条件查询 &lt;set&gt;update更新的时候使用</span><br><span class="line">作用：</span><br><span class="line">&lt;where&gt;：动态拼接 where，去除多余的AND/OR</span><br><span class="line">&lt;set&gt;: 动态拼接set，去除多余的逗号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;foreach&gt;标签的用法</span><br><span class="line">&lt;foreach colletion=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span><br><span class="line">#&#123;id&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql&gt;和&lt;include&gt;的作用</span><br><span class="line">&lt;sql id=&quot;aaa&quot;&gt;：抽取公共的sql片段</span><br><span class="line">&lt;include refid=&quot;aaa&quot;&gt;：使用sql片段</span><br></pre></td></tr></table></figure><h1 id="Day10-SpringBootWeb"><a href="#Day10-SpringBootWeb" class="headerlink" title="Day10 - SpringBootWeb"></a>Day10 - SpringBootWeb</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">REST风格</span><br><span class="line">请求路径 + 请求方式 唯一确定一个后端方法</span><br><span class="line"></span><br><span class="line">增：POST     /users</span><br><span class="line">删：DELETE   /users/1   </span><br><span class="line">改：PUT      /users</span><br><span class="line">查：GET      /users/1</span><br><span class="line">查全部：GET   /users</span><br></pre></td></tr></table></figure><h1 id="Day11-SpringBootWeb-案例2"><a href="#Day11-SpringBootWeb-案例2" class="headerlink" title="Day11 - SpringBootWeb - 案例2"></a>Day11 - SpringBootWeb - 案例2</h1><h2 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1. 文件上传"></a>1. 文件上传</h2><h3 id="1-1-本地文件上传"><a href="#1-1-本地文件上传" class="headerlink" title="1.1 本地文件上传"></a>1.1 本地文件上传</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件上传 前端页面三要素</span><br><span class="line">(1) 表单提交方式 必须是 POST</span><br><span class="line">(2) 表单的encType属性值 必须是 mutipart/form-data</span><br><span class="line">(3) 表单项的type属性值 必须是 file</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件上传 后端接收文件二要素</span><br><span class="line">（1）形参类型必须是 MutipartFile</span><br><span class="line">（2）形参名必须和表单项名称保持一致</span><br></pre></td></tr></table></figure><h3 id="1-2-阿里云OSS文件上传"><a href="#1-2-阿里云OSS文件上传" class="headerlink" title="1.2 阿里云OSS文件上传"></a>1.2 阿里云OSS文件上传</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件上传：</span><br><span class="line">1. 注册账号，创建Bucket、AKSK</span><br><span class="line">2. 导入依赖，导入阿里云文件上传工具类 </span><br><span class="line">3. 编写文件上传代码 形参类型为MutipartFile，形参名是image 和前端请求参数保持一致，再调用文件上传工具类即可</span><br></pre></td></tr></table></figure><h2 id="2-YML"><a href="#2-YML" class="headerlink" title="2. YML"></a>2. YML</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML文件的语法格式</span><br><span class="line">（1）以冒号结尾</span><br><span class="line">（2）属性值 和 属性名之间用冒号连接，冒号和属性值之间一定要加一个空格</span><br><span class="line">（3）用空格缩进表示层级关系</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取YML文件的配置信息</span><br><span class="line">@Value：读取配置文件中的值，读取单个属性</span><br><span class="line">@ConfigurationProperties(prefix=&quot;aliyun.oss&quot;)：读取配置文件中的值到实体类中 批量读取属性</span><br></pre></td></tr></table></figure><h1 id="Day12-Web登录认证"><a href="#Day12-Web登录认证" class="headerlink" title="Day12 - Web登录认证"></a>Day12 - Web登录认证</h1><h2 id="1-会话技术"><a href="#1-会话技术" class="headerlink" title="1.会话技术"></a>1.会话技术</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是会话？</span><br><span class="line">一个浏览器和一个服务器建立一次连接的过程就是一次会话，浏览器或服务器断开连接则会话结束。一次会话中可以有多次请求</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">会话跟踪技术的作用？</span><br><span class="line">在一次会话的多次请求间共享数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">会话跟踪技术有哪些？</span><br><span class="line">cookie：客户端会话跟踪技术</span><br><span class="line">session：服务端会话跟踪技术</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cookie的原理</span><br><span class="line">多次请求 携带的是同一个 cookie，就在客户端实现了数据共享</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">不能在移动端使用</span><br><span class="line">不安全，因为用户可以禁用cookie</span><br><span class="line">不能跨域</span><br><span class="line"></span><br><span class="line">【跨域】：</span><br><span class="line">判断两次请求中 协议、ip/域名、端口号 是否不一致，如果不一致则跨域了</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session的原理</span><br><span class="line">  多次请求在cookie中携带的是同一个sessionId，就能在服务器中找到同一个session，就实现了服务端的数据共享</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">集群中不能使用session共享数据</span><br><span class="line">cookie的所有缺点（因为session是基于cookie实现的）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JWT令牌的三个组成部分</span><br><span class="line">header：令牌类型 和 签名算法</span><br><span class="line">payload：自定义数据</span><br><span class="line">signature：签名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JWT令牌的生成和校验</span><br><span class="line">使用Jwts工具类 生成令牌和校验令牌</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">登录校验中使用令牌</span><br><span class="line">令牌生成：登录成功后 生成令牌 并返回给前端</span><br><span class="line">令牌校验：（除了登录之外的）每次请求都需要校验令牌，统一拦截校验</span><br></pre></td></tr></table></figure><h2 id="2-Filter-过滤器"><a href="#2-Filter-过滤器" class="headerlink" title="2. Filter 过滤器"></a>2. Filter 过滤器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过滤器的作用：</span><br><span class="line">拦截请求 并在放行前后 做一些逻辑处理</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过滤器入门程序</span><br><span class="line">1.定义 实现 Filter接口</span><br><span class="line">2.添加注解</span><br><span class="line">@WebFilter(urlPatterns=&quot;/*&quot;)</span><br><span class="line">@ServletComponentScan //开启Servlet组件扫描，只有开启了才能扫描到@WebFilter</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过滤器的执行流程</span><br><span class="line">1. 放行前逻辑</span><br><span class="line">2. 放行</span><br><span class="line">3. 执行目标方法</span><br><span class="line">4. 放行后逻辑</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">登录校验过滤器的作用</span><br><span class="line">统一拦截所有请求，并判断令牌的合法性，如果合法则放行，如果并不合法，则返回NOT_LOGIN</span><br></pre></td></tr></table></figure><h2 id="3-Interceptor-拦截器"><a href="#3-Interceptor-拦截器" class="headerlink" title="3. Interceptor 拦截器"></a>3. Interceptor 拦截器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拦截器的入门程序</span><br><span class="line"> 1.定义拦截器 实现HandlerInterceptor，并重写preHandler、postHander、AfterComplection</span><br><span class="line"> 2.注册拦截器 定义配置类，并实现WebMvcConfiguer，并添加 @Configuration</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拦截器的执行顺序</span><br><span class="line">preHandler</span><br><span class="line">return true </span><br><span class="line">执行目标方法</span><br><span class="line">postHander</span><br><span class="line">AfterComplection</span><br><span class="line">return false</span><br><span class="line">拦截请求</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过滤器和拦截器的区别</span><br><span class="line">1. 如果过滤器和拦截器同时存在，那么请求先进入过滤器，过滤器放行再进入拦截器</span><br><span class="line">2. 过滤器实现Filter接口，拦截器实现 HandlerInterceptor接口</span><br><span class="line">3. 过滤器拦截所有请求，拦截器只拦截controller</span><br><span class="line">4. 实现原理不同：过滤器基于回调实现，拦截器基于反射实现</span><br></pre></td></tr></table></figure><h2 id="4-全局异常处理器"><a href="#4-全局异常处理器" class="headerlink" title="4. 全局异常处理器"></a>4. 全局异常处理器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义全局异常处理器</span><br><span class="line">@RestControllerAdvice：放在类上，标明此类是一个异常处理器类</span><br><span class="line">@ExceptionHandler(Exception.class)：放在方法上，指定当前方法捕获哪一类异常</span><br></pre></td></tr></table></figure><h1 id="Day13-事务管理-amp-AOP"><a href="#Day13-事务管理-amp-AOP" class="headerlink" title="Day13 - 事务管理 &amp; AOP"></a>Day13 - 事务管理 &amp; AOP</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何在Spring中完成事务管理</span><br><span class="line">@Transactional</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事务属性 rollback的作用</span><br><span class="line">指定哪些异常要回滚，一般指定所有异常都要回滚</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务传播行为propagation的作用</span><br><span class="line">propagation: 控制事务传播行为，当业务层方法之间相互调用发生事务嵌套时，内层事务是否要和外层同成功同失败</span><br><span class="line">- REQUIRED：默认内外层使用同一个事物，同成功同失败</span><br><span class="line">- REQUIRES_NEW：内外层事务之间互不影响</span><br></pre></td></tr></table></figure><h2 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2. AOP"></a>2. AOP</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是AOP？</span><br><span class="line">面向切面编程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AOP的作用？</span><br><span class="line">在不改变原始代码的基础上进行功能增强</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AOP的核心概念</span><br><span class="line">连接点：所有可以进行功能增强的方法都是连接点</span><br><span class="line">切入点：进行了功能增强的方法就是切入点</span><br><span class="line">通知：共性功能</span><br><span class="line">切面：切入点 + 通知</span><br><span class="line">目标对象：通知所应用的对象就是目标对象</span><br><span class="line">切入点表达式：指定哪些方法是切入点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOP常见通知类型</span><br><span class="line">前置通知：@Before</span><br><span class="line">后置通知：@After</span><br><span class="line">环绕通知：@Around</span><br><span class="line">返回后通知：@AfterReturning</span><br><span class="line">异常后通知：@AfterThrowing</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">切入点表达式的写法</span><br><span class="line">写法一：@PointCut(&quot;execution(访问修饰符 返回值 包名.类名.方法名(参数))&quot;)</span><br><span class="line">通配符：</span><br><span class="line">* 单个或半个任意符号 多用于模糊匹配</span><br><span class="line">.. 多个连续任意符号 多用于参数省略或包名省略</span><br><span class="line">写法二：@PointCut(&quot;@annotation(注解的全路径类名)&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过连接点对象获取目标方法的信息</span><br><span class="line">获取类名：joinPoint.getTarget().getClass().getName()</span><br><span class="line">获取方法名：joinPoint.getSignature().getName()</span><br><span class="line">获取参数：joinPoint.getArgs()</span><br><span class="line">执行目标方法：joinPoint.proceed()</span><br><span class="line">获取返回值：Object result = joinPoint.proceed()</span><br></pre></td></tr></table></figure><h1 id="Day14-自动配置原理"><a href="#Day14-自动配置原理" class="headerlink" title="Day14 - 自动配置原理"></a>Day14 - 自动配置原理</h1><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Springboot配置文件的优先级</span><br><span class="line">properties、yml、yaml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot的jar包启动</span><br><span class="line">java -jar xxx.jar </span><br></pre></td></tr></table></figure><h2 id="2-管理bean"><a href="#2-管理bean" class="headerlink" title="2. 管理bean"></a>2. 管理bean</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">手动从容器中获取bean</span><br><span class="line">applicationContext.getBean(&quot;&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置bean的作用域</span><br><span class="line">@Scope</span><br><span class="line">singleton：单例</span><br><span class="line">prototype：非单例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Bean注解的作用</span><br><span class="line">管理第三方bean时使用，作用是：把当前方法的返回值放到Spring容器中</span><br></pre></td></tr></table></figure><h2 id="3-自动配置原理"><a href="#3-自动配置原理" class="headerlink" title="3. 自动配置原理"></a>3. 自动配置原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动配置</span><br><span class="line">在容器启动的时候，自动把一些配置类或bean放到Spring容器中，这些不需要我们手动操作，只需要拿来即用即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">自动配置原理：</span><br><span class="line">在主启动类的核心注解里，有一个自动配置注解@EnableAutoConfiguration，这个注解会自动扫描spring.factories和AutoConfiguration.imports这两个文件，文件内部定义了一些xxxAutoConfiguration，里边使用了@Bean注解把对象放到Spring容器中</span><br><span class="line"></span><br><span class="line">自动配置注解：@EnableAutoConfiguration</span><br><span class="line">自动配置文件：spring.factories 和 AutoConfiguration.imports 文件</span><br><span class="line">自动配置类：xxxAutoConfiguration（@Bean）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Import注解的作用</span><br><span class="line">把类对应的对象导入到容器中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Conditional注解的作用</span><br><span class="line">满足条件的bean才会被放到Spring容器中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Conditional衍生注解</span><br><span class="line">@ConditionalOnClass：环境中存在该字节码对象 才会把bean放到Spring容器中</span><br><span class="line">@ConditionalOnMissingBean：容器中不存在当前bean，才会把bean放到Spring容器中</span><br><span class="line">@ConditionalOnProperty：配置文件中存在指定的属性名和属性值，才会把bean放到Spring容器中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如何自定义starter</span><br><span class="line">1. 编写依赖管理模块（starter），引入依赖即可</span><br><span class="line">2. 编写自动配置模块（autoConfiguer），在starter中引入autoConfiguer模块</span><br><span class="line">3. 在自动配置模块中编写 </span><br><span class="line">自动配置文件（META-INF/spring/xxxAutoConfiguration.imports）</span><br><span class="line">自动配置类 （在xxxAutoConfiguration使用@Bean注解把类对应的对象放到Spring容器中）</span><br></pre></td></tr></table></figure><h1 id="Day15-MybatisPlus"><a href="#Day15-MybatisPlus" class="headerlink" title="Day15 - MybatisPlus"></a>Day15 - MybatisPlus</h1><h2 id="1-入门案例"><a href="#1-入门案例" class="headerlink" title="1. 入门案例"></a>1. 入门案例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">入门案例步骤</span><br><span class="line">1. 准备工作：数据库表、创建模块（导入依赖、修改配置文件中的数据库连接信息、添加实体类）</span><br><span class="line">2. 编写UserDao, 继承BaseMapper&lt;User&gt;, 添加@Mapper</span><br><span class="line">3. 测试</span><br></pre></td></tr></table></figure><h2 id="2-标准CRUD操作"><a href="#2-标准CRUD操作" class="headerlink" title="2. 标准CRUD操作"></a>2. 标准CRUD操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新增：insert</span><br><span class="line">根据id删除：deleteById</span><br><span class="line">根据id修改：updateById</span><br><span class="line">根据id查询: selectById</span><br><span class="line">查列表： selectList</span><br><span class="line">查分页：selectPage  添加分页拦截器</span><br><span class="line"></span><br><span class="line">查询投影：selectMaps</span><br></pre></td></tr></table></figure><h2 id="3-按条件查询"><a href="#3-按条件查询" class="headerlink" title="3. 按条件查询"></a>3. 按条件查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;gt</span><br><span class="line">&gt;=ge</span><br><span class="line">&lt;lt</span><br><span class="line">&lt;=le</span><br><span class="line">=eq</span><br><span class="line">范围查询：between and</span><br><span class="line">模糊查询：like</span><br><span class="line">包含：in</span><br></pre></td></tr></table></figure><h2 id="4-批量操作"><a href="#4-批量操作" class="headerlink" title="4. 批量操作"></a>4. 批量操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根据id批量查询：selectBatchById</span><br><span class="line">根据id批量删除：deleteBatchById</span><br></pre></td></tr></table></figure><h2 id="5-兼容性匹配"><a href="#5-兼容性匹配" class="headerlink" title="5. 兼容性匹配"></a>5. 兼容性匹配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据库表名 和 实体类名不一致：@TableName</span><br><span class="line">数据库字段名 和 实体类属性名不一致：@TableField(value=&quot;&quot;)</span><br><span class="line">设置不查询某字段：@TableField(select=false)</span><br><span class="line">设置实体类属性名在数据库中不存在：@TableField(exist=false)</span><br></pre></td></tr></table></figure><h2 id="6-id生成策略"><a href="#6-id生成策略" class="headerlink" title="6. id生成策略"></a>6. id生成策略</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id生成策略注解：@TableId</span><br><span class="line">全局配置：id-type</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id生成策略有哪些？</span><br><span class="line">Auto、Assign-id</span><br></pre></td></tr></table></figure><h2 id="7-逻辑删除"><a href="#7-逻辑删除" class="headerlink" title="7. 逻辑删除"></a>7. 逻辑删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">逻辑删除注解：</span><br><span class="line">@TableLogic(value=&quot;0&quot;，delval=&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">步骤：</span><br><span class="line">1.添加字段</span><br><span class="line">2.添加注解</span><br></pre></td></tr></table></figure><h2 id="8-乐观锁"><a href="#8-乐观锁" class="headerlink" title="8. 乐观锁"></a>8. 乐观锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1.添加字段 version 和 添加 @Version注解</span><br><span class="line">2.添加乐观锁拦截器</span><br><span class="line">3.查询数据库中的数据和版本号，调用修改操作，把要修改的数据和刚才查询出来的版本号都设置进去</span><br></pre></td></tr></table></figure><h1 id="Day16-Maven高级"><a href="#Day16-Maven高级" class="headerlink" title="Day16 - Maven高级"></a>Day16 - Maven高级</h1><h2 id="1-分模块开发"><a href="#1-分模块开发" class="headerlink" title="1. 分模块开发"></a>1. 分模块开发</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分模块开发的好处？</span><br><span class="line">解耦、便于开发、便于维护、便于复用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何分模块开发？</span><br><span class="line">水平拆分：分层拆分</span><br><span class="line">垂直拆分：按业务拆分</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何在A模块中使用B模块？</span><br><span class="line">&lt;dependency&gt;引入即可</span><br></pre></td></tr></table></figure><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">继承的作用？</span><br><span class="line">简化了依赖配置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何实现继承？</span><br><span class="line">1. 在父pom文件中设置打包方式为pom  &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">2. 在子模块中使用&lt;parent&gt;标签设置父模块</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;和&lt;dependencies&gt;的区别</span><br><span class="line">&lt;dependencyManagement&gt;：锁定版本号，并没有真正引入依赖。可以减少依赖冲突</span><br><span class="line">&lt;dependencies&gt;: 真正引入依赖</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;标签的作用？</span><br><span class="line">配置pom文件中的属性/变量，使用变量$&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="3-聚合"><a href="#3-聚合" class="headerlink" title="3. 聚合"></a>3. 聚合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">聚合的作用？</span><br><span class="line">构建聚合工程的时候，子工程也会跟着构建</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何用聚合实现多工程统一构建？</span><br><span class="line">在聚合工程中使用&lt;modules&gt;设置聚合工程有几个子工程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">聚合和继承的区别？</span><br><span class="line">继承：子模块继承父模块的依赖和配置，在子模块中配置继承关系</span><br><span class="line">聚合：工程的统一构建，在聚合工程中配置聚合关系</span><br></pre></td></tr></table></figure><h2 id="4-私服"><a href="#4-私服" class="headerlink" title="4. 私服"></a>4. 私服</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">私服的作用？</span><br><span class="line">团队间的资源共享</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下载：在setting.xml中配置 用户名密码(&lt;server&gt;)、私服仓库的镜像（&lt;mirrors&gt; url）</span><br><span class="line">上传：在pom.xml文件中配置私服的url路径，点击 install、deploy就可以上传依赖到私服了</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题库</title>
      <link href="/posts/c5e9cf91/"/>
      <url>/posts/c5e9cf91/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题小结"><a href="#面试题小结" class="headerlink" title="面试题小结"></a>面试题小结</h1><h1 id="1-内存结构"><a href="#1-内存结构" class="headerlink" title="1 内存结构"></a>1 内存结构</h1><blockquote><h3 id="1、简述一下JVM的内存结构？-高频"><a href="#1、简述一下JVM的内存结构？-高频" class="headerlink" title="1、简述一下JVM的内存结构？(高频)"></a>1、简述一下JVM的内存结构？(高频)</h3></blockquote><p>JVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有</p><p>区和共享区。</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220216222845410.png" alt="image-20220216222845410" style="zoom: 50%;"></th></tr></thead></table><p><strong>线程私有区</strong>：</p><p>① 程序计数器</p><ul><li>作用：是一块较小的内存空间，可以理解为是当前线程所执行程序的字节码文件的行号指示器，存储的是当前线程所执行的<strong>行号</strong></li><li>特点：线程私有 ，唯一一个不会出现内存溢出的内存空间</li></ul><p>② 虚拟机栈</p><ul><li><p>作用：管理JAVA方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法中变量的变量表、操作数栈、动态链接方法、返回值、返回地址</p><p>等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）</p></li></ul><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205133550896.png" alt="image-20220205133550896"></th></tr></thead></table><ul><li><p>特点：</p><p>1、线程私有</p><p>2、局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）以及对象引用（reference 类</p><p>型）</p><p>3、栈太小或者方法调用过深，都将抛出StackOverflowError异常</p></li><li><p>测试代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录调用了多少次出现了栈内存溢出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            show() ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;show方法被调用了:&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++ ;</span><br><span class="line">        System.out.println(<span class="string">&quot;show方法执行了.....&quot;</span>);</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置虚拟机参数-Xss可以指定栈内存大小；例如：-Xss180k</p><p>栈内存的默认值问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The <span class="keyword">default</span> value depends on the platform: </span><br><span class="line">* Linux/x64 (<span class="number">64</span>-bit): <span class="number">1024</span> KB </span><br><span class="line">* macOS (<span class="number">64</span>-bit): <span class="number">1024</span> KB </span><br><span class="line">* Oracle Solaris/x64 (<span class="number">64</span>-bit): <span class="number">1024</span> KB </span><br><span class="line">* Windows: The <span class="keyword">default</span> value depends on virtual memory</span><br></pre></td></tr></table></figure><p>③ 本地方法栈：与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p><p><strong>线程共享区</strong>：</p><p>① 堆内存</p><ul><li>作用：是Java内存区域中一块用来存放对象实例的区域，新创建的对象，数组都使用堆内存；【从Java7开始，常量池也会使用堆内存】</li></ul><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220216224408053.png" alt="image-20220216224408053" style="zoom:50%;"></th></tr></thead></table><p>Java 堆从GC的角度还可以细分为: 新生代( Eden区 、From Survivor区和 To Survivor区 )和老年代。</p><ul><li><p>特点：</p><p>1、被线程共享，因此需要考虑线程安全问题</p><p>2、会产生内存溢出问题</p></li><li><p>测试代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个变量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个ArrayList对象</span></span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList() ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                arrayList.add(<span class="keyword">new</span> Object()) ;</span><br><span class="line">                count++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable a) &#123;</span><br><span class="line">            a.printStackTrace();</span><br><span class="line">            <span class="comment">// 输出程序执行的次数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;总共执行了:&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚拟机参数：</li></ul><p>​-Xms设置最小堆内存大小(不能小于1024K); -Xms 堆内存初始大小，可以通过jmap工具进行查看</p><p>​-Xmx设置最大堆内存大小(不能小于1024K);     -Xmx 堆内存最大值，可以通过jmap工具进行查看</p><p>​例如：-Xms1024K -Xmx2048K</p><p>② 方法区</p><ul><li><p>作用：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p></li><li><p>特点：</p><p>1、方法区是一块线程共享的内存区域</p><p>2、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出的错误</p><p>3、jdk1.6和jdk1.7方法区也常常被称之为永久区(永久代),大小一般都是几百兆；</p><p>4、jdk1.8已经将方法区取消，替代的是元数据区(元空间),如果不指定大小，默认情况下，虚拟机会耗尽可用系统内存</p><p>5、jdk7以后就将方法区中的常量池移动至<strong>堆内存</strong></p></li></ul><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205140202778.png" alt="image-20220205140202778"></th></tr></thead></table><p>​变化的原因：</p><p>​1、提高内存的回收效率(方法区内存的回收效率远远低于堆内存，因为方法去中存储的都是类信息，静态变量…这些信息不能被轻易回收)</p><p>​2、字符串常量池在方法区，那么很容易产生内存溢出(因为方法区的垃圾回收效率比较低);</p><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">jdk1.8的元数据区可以使用参数-XX:MaxMetaspaceSzie设定大小</span></span><br><span class="line"><span class="comment"> * 演示元空间内存溢出</span></span><br><span class="line"><span class="comment"> * -XX:-UseCompressedClassPointers -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> UseCompressedClassPointers使用指针压缩，如果不使用这个参数可能会出现: Compressed class space内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxMetaspaceDemo</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;<span class="comment">// 当前这个类就是一个类加载器</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义变量，记录程序产生类的个数</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            MaxMetaspaceDemo test = <span class="keyword">new</span> MaxMetaspaceDemo();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 字节码写入器</span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 定义一个类版本为Opcodes.V1_1，它的访问域为public，名称为Class&#123;i&#125;,父类为java.lang.Object，不实现任何接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 加载该类</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="2、堆和栈的区别？-高频"><a href="#2、堆和栈的区别？-高频" class="headerlink" title="2、堆和栈的区别？(高频)"></a>2、堆和栈的区别？(高频)</h3></blockquote><p>① 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储</p><p>在堆内存中。</p><p>② 共享性不同：栈内存是线程私有的。堆内存是所有线程共有的。</p><p>③ 异常错误不同：如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：</p><p>java.lang.OutOfMemoryError。</p><p>④ 空间大小：栈的空间大小远远小于堆的。</p><blockquote><h3 id="3、怎么获取Java程序使用的内存？堆使用的百分比？"><a href="#3、怎么获取Java程序使用的内存？堆使用的百分比？" class="headerlink" title="3、怎么获取Java程序使用的内存？堆使用的百分比？"></a>3、怎么获取Java程序使用的内存？堆使用的百分比？</h3></blockquote><p>可以通过java.lang.Runtime类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余</p><p>空间。</p><p>1、Runtime.freeMemory() 方法返回剩余空间的字节数</p><p>2、Runtime.totalMemory()方法总内存的字节数</p><blockquote><h3 id="4、栈帧都有哪些数据？"><a href="#4、栈帧都有哪些数据？" class="headerlink" title="4、栈帧都有哪些数据？"></a>4、栈帧都有哪些数据？</h3></blockquote><p>栈帧包含：局部变量表、操作数栈、动态连接、返回值、返回地址等。</p><blockquote><h3 id="5、如何启动系统的时候设置jvm的启动参数？"><a href="#5、如何启动系统的时候设置jvm的启动参数？" class="headerlink" title="5、如何启动系统的时候设置jvm的启动参数？"></a>5、如何启动系统的时候设置jvm的启动参数？</h3></blockquote><p>其实都很简单，比如说采用”java -jar”的方式启动一个jar包里面的系统，那么就可以才用类似下面的格式：</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205141640067.png" alt="image-20220205141640067"></th></tr></thead></table><h1 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2 垃圾回收"></a>2 垃圾回收</h1><blockquote><h3 id="6、如何判断一个对象是否为垃圾？-高频"><a href="#6、如何判断一个对象是否为垃圾？-高频" class="headerlink" title="6、如何判断一个对象是否为垃圾？(高频)"></a>6、如何判断一个对象是否为垃圾？(高频)</h3></blockquote><p>两种算法：</p><p><strong>① 引用计数法</strong>：堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被</p><p>赋值为这个对象的引用时，计数加1（a &#x3D; b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，</p><p>对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。</p><p>特点：简单、无法解决循环引用问题</p><p>定义学生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义成员变量</span></span><br><span class="line">    <span class="keyword">public</span> Object instance ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jvm参数：-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</span></span><br><span class="line"><span class="comment">-verbose:gc -XX:+PrintGCDetails：打印gc日志信息</span></span><br><span class="line"><span class="comment">-XX:+PrintGCTimeStamps: 打印gc日志的时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountGcDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Student对象</span></span><br><span class="line">        Student a = <span class="keyword">new</span> Student() ;</span><br><span class="line">        Student b = <span class="keyword">new</span> Student() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行循环引用</span></span><br><span class="line">        a.instance = b ;</span><br><span class="line">        b.instance = a ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将a对象和b对象设置为null</span></span><br><span class="line">        a = <span class="keyword">null</span> ;</span><br><span class="line">        b = <span class="keyword">null</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用System.gc进行垃圾回收</span></span><br><span class="line">        System.gc();                    <span class="comment">// 如果没有触发垃圾回收说明Hotspot的jvm使用的就是引用计数法来判断对象是否为垃圾</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出gc日志:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.076</span>: [GC (System.gc()) [PSYoungGen: 7802K-&gt;856K(151552K)] 7802K-&gt;864K(498688K), <span class="number">0.0008493</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.02</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">0.077</span>: [<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 856K-&gt;0<span class="title">K</span><span class="params">(151552K)</span>] [ParOldGen: 8K-&gt;620<span class="title">K</span><span class="params">(347136K)</span>] 864K-&gt;620<span class="title">K</span><span class="params">(498688K)</span>, [Metaspace: 3356K-&gt;3356<span class="title">K</span><span class="params">(1056768K)</span>], 0.0044768 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 151552K, used 3901K [<span class="number">0x0000000716c00000</span>, <span class="number">0x0000000721500000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 130048K, <span class="number">3</span>% used [<span class="number">0x0000000716c00000</span>,<span class="number">0x0000000716fcf748</span>,<span class="number">0x000000071eb00000</span>)</span><br><span class="line">  from space 21504K, <span class="number">0</span>% used [<span class="number">0x000000071eb00000</span>,<span class="number">0x000000071eb00000</span>,<span class="number">0x0000000720000000</span>)</span><br><span class="line">  to   space 21504K, <span class="number">0</span>% used [<span class="number">0x0000000720000000</span>,<span class="number">0x0000000720000000</span>,<span class="number">0x0000000721500000</span>)</span><br><span class="line"> ParOldGen       total 347136K, used 620K [<span class="number">0x00000005c4400000</span>, <span class="number">0x00000005d9700000</span>, <span class="number">0x0000000716c00000</span>)</span><br><span class="line">  object space 347136K, <span class="number">0</span>% used [<span class="number">0x00000005c4400000</span>,<span class="number">0x00000005c449b318</span>,<span class="number">0x00000005d9700000</span>)</span><br><span class="line"> Metaspace       used 3365K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 370<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">① <span class="number">0.076</span>: 代表gc发生的时间，从jvm启动以来经过的秒数</span><br><span class="line">② [GC和[Full Gc: 说明这次垃圾收集器的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有<span class="string">&quot;Full&quot;</span>，说明此次GC发生了stop-the-world。System.gc()是说明显示的调用了   System.gc方法进行垃圾回收</span><br><span class="line">③ [PSYoungGen：表示GC发生的区域, 不同的垃圾收集器展示的区域名称不一样，PSYoungGen表示的是新生代，这里默认使用的是Parallel Scavenge收集器 (-XX:+UseSerialGC)</span><br><span class="line">④ 7802K-&gt;856K(151552K)：GC前该区域已使用容量 -&gt; GC后该区域已使用容量(该区域的总容量)</span><br><span class="line">⑤ 7802K-&gt;864K(498688K)：GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)</span><br><span class="line">⑥ <span class="number">0.0008493</span> secs：该区域GC所占用的时间</span><br><span class="line">⑦ [Times: user=<span class="number">0.17</span> sys=<span class="number">0.02</span>, real=<span class="number">0.00</span> secs]: 分别表示用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间(墙钟时间包括非运算的等待耗时)。多线程操作会叠加这些CPU时间，所以user、sys时间超过real时间是完全正常的。  </span><br></pre></td></tr></table></figure><p><strong>② 可达性分析算法 <strong>： 可达性分析算法又叫做</strong>跟搜索法</strong>，就是通过一系列的称之为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的</p><p>路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。</p><p>(类似于葡萄串)；</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205142506230.png" alt="image-20220205142506230"></th></tr></thead></table><blockquote><h3 id="7、可达性算法中，哪些对象可作为GC-Roots对象？-高频"><a href="#7、可达性算法中，哪些对象可作为GC-Roots对象？-高频" class="headerlink" title="7、可达性算法中，哪些对象可作为GC Roots对象？(高频)"></a>7、可达性算法中，哪些对象可作为GC Roots对象？(高频)</h3></blockquote><p>可以作为GC ROOTS对象的情况：</p><p>1、虚拟机栈中引用的对象</p><p>2、方法区静态成员引用的对象</p><p>3、方法区常量引用对象</p><p>4、本地方法栈引用的对象</p><blockquote><h3 id="8、Java中都有哪些引用类型？-高频"><a href="#8、Java中都有哪些引用类型？-高频" class="headerlink" title="8、Java中都有哪些引用类型？(高频)"></a>8、Java中都有哪些引用类型？(高频)</h3></blockquote><p><strong>① 强引用</strong></p><p>Java中默认声明的就是强引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//只要obj还指向Object对象，Object对象就不会被回收</span></span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">//手动置null</span></span><br></pre></td></tr></table></figure><p>只要<strong>强引用存在，垃圾回收器将永远不会回收被引用的对象</strong>，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引</p><p>用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;() ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ;  x &lt; <span class="number">10</span> ; x++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line">            list.add(buff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 软引用</strong></p><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回</strong></p><p><strong>收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p><p>在 JDK1.2 之后，用java.lang.ref.<strong>SoftReference</strong>类来表示软引用。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建数组对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>]) ;</span><br><span class="line">            list.add(softReference) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.gc();  <span class="comment">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            Object obj = ((SoftReference) list.get(i)).get();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现无论循环创建多少个软引用对象，打印结果总是有一些为null，这里就说明了在内存不足的情况下，软引用将会被自动回收。</p><p><strong>③ 弱引用</strong></p><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2之后,用</p><p>java.lang.ref.WeakReference来表示弱引用。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建数组对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>]) ;</span><br><span class="line">            list.add(weakReference) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.gc();  <span class="comment">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            Object obj = ((WeakReference) list.get(i)).get();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>④ 虚引用</strong></p><p>虚引用是最弱的一种引用关系，如果<strong>一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收</strong>，在 JDK1.2 之后，用 </p><p>PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是</p><p>说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns this reference object&#x27;s referent.  Because the referent of a</span></span><br><span class="line"><span class="comment">     * phantom reference is always inaccessible, this method always returns</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new phantom reference that refers to the given object and</span></span><br><span class="line"><span class="comment">     * is registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; It is possible to create a phantom reference with a &lt;tt&gt;null&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * queue, but such a reference is completely useless: Its &lt;tt&gt;get&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * method will always return null and, since it does not have a queue, it</span></span><br><span class="line"><span class="comment">     * will never be enqueued.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent the object the new phantom reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><p>1、每次垃圾回收时都会被回收，主要用于监测对象是否已经从内存中删除</p><p>2、虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中</p><p>3、程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那</p><p>么就可以在所引用的对象的内存被回收之前采取必要的行动</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个虚引用，指向一个Object对象</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(<span class="keyword">new</span> Object(), referenceQueue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从引用队列中获取元素, 该方法是阻塞方法</span></span><br><span class="line">        System.out.println(referenceQueue.remove()); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="9、常见的垃圾回收算法都有哪些？-高频"><a href="#9、常见的垃圾回收算法都有哪些？-高频" class="headerlink" title="9、常见的垃圾回收算法都有哪些？(高频)"></a>9、常见的垃圾回收算法都有哪些？(高频)</h3></blockquote><p><strong>① 标记清除</strong></p><p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205143116277.png" alt="image-20220205143116277"></th></tr></thead></table><p>优点：速度比较快</p><p>缺点：会产生内存碎片，碎片过多，仍会使得连续空间少</p><p><strong>② 标记整理</strong></p><p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一进行整理，整理是指存活对象向一端移动来减少内存碎片，相对效率较低</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205143213301.png" alt="image-20220205143213301"></th></tr></thead></table><p>优点：无内存碎片</p><p>缺点：效率较低</p><p><strong>③ 复制算法</strong></p><p>执行过程：开辟两份大小相等空间，一份空间始终空着，垃圾回收时，将存活对象拷贝进入空闲空间；</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205143344612.png" alt="image-20220205143344612"></th></tr></thead></table><p>优点：无内存碎片</p><p>缺点：占用空间多</p><p>注意：如果有很多对象的存活率较高，这时我们采用复制算法，那么效率就比较低；</p><p><strong>④ 分代回收</strong></p><p>概述：根据对象存活周期的不同，将对象划分为几块，比如Java的堆内存，分为新生代和老年代，然后根据各个年代的特点采用最合适的算法；</p><p>新生代对象的存活的时间都比较短，因此使用的是【复制算法】；而老年代对象存活的时间比较长那么采用的就是【标记清除】或者【标记整理】；</p><blockquote><h3 id="10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？"></a>10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？</h3></blockquote><p>在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下</p><p>是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回</p><p>收。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><h1 id="3-对象分配"><a href="#3-对象分配" class="headerlink" title="3 对象分配"></a>3 对象分配</h1><blockquote><h3 id="11、对象在内存中是如何进行分配的？-高频"><a href="#11、对象在内存中是如何进行分配的？-高频" class="headerlink" title="11、对象在内存中是如何进行分配的？(高频)"></a>11、对象在内存中是如何进行分配的？(高频)</h3></blockquote><p><strong>① 对象优先在Eden分配</strong>：对象优先在『伊甸园』分配，当『伊甸园』没有足够的空间时，触发 ‘Minor GC’(小范围的GC)</p><p>情况一：伊甸园的内存空间足够，不会发生’Minor GC’</p><img src="/posts/c5e9cf91/image-20211121234732699.png" alt="image-20211121234732699" style="zoom: 50%;"> <p>情况二：伊甸园的空间不够了</p><img src="/posts/c5e9cf91/image-20211121234819672.png" alt="image-20211121234819672" style="zoom: 50%;"> <p>垃圾回收线程启动，进行垃圾回收，此时会触发”stop the world”(停止所有用户线程)，</p><img src="/posts/c5e9cf91/image-20211121234902565.png" alt="image-20211121234902565" style="zoom:50%;"> <p>Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄最多到一定值(最大值是15，对</p><p>象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁)(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有</p><p>达到阈值的对象会被复制到“To”区域。</p><img src="/posts/c5e9cf91/image-20211121235052820.png" alt="image-20211121235052820" style="zoom:50%;"> <p>“From”和”To”会交换他们的角色,下一次垃圾回收的时候也是从Eden将存活的对象复制到TO区</p><img src="/posts/c5e9cf91/image-20211121235346217.png" alt="image-20211121235346217" style="zoom:50%;"> <p>Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><p>案例演示：</p><p>jvm参数设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span>XX:<span class="operator">+</span>UseSerialGC <span class="operator">-</span>verbose:gc <span class="operator">-</span>XX:<span class="operator">+</span>PrintGCDetails <span class="operator">-</span>XX:<span class="operator">+</span>PrintGCTimeStamps <span class="operator">-</span>Xloggc:.<span class="operator">/</span>gc.log <span class="operator">-</span>Xms20M <span class="operator">-</span>Xmx20M <span class="operator">-</span>Xmn10M <span class="operator">-</span>XX:SurvivorRatio<span class="operator">=</span><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>XX:<span class="operator">+</span>UseSerialGC 是指使用 Serial <span class="operator">+</span> SerialOld 回收器组合</span><br><span class="line"><span class="operator">-</span>XX:<span class="operator">+</span>PrintGCDetails <span class="operator">-</span>verbose:gc 是指打印 GC 详细信息</span><br><span class="line"><span class="operator">-</span>XX:<span class="operator">+</span>PrintGCTimeStamps 打印gc日志的时间戳</span><br><span class="line"><span class="operator">-</span>Xloggc:.<span class="operator">/</span>gc.log 将gc日志输出到一个日志文件中</span><br><span class="line"><span class="operator">-</span>Xms20M <span class="operator">-</span>Xmx20M <span class="operator">-</span>Xmn10M 是指分配给JVM的最小，最大以及新生代内存</span><br><span class="line"><span class="operator">-</span>XX:SurvivorRatio<span class="operator">=</span><span class="number">8</span> 是指『伊甸园』与『幸存区 <span class="keyword">From</span>』和『幸存区 <span class="keyword">To</span>』比例为 <span class="number">8</span>:<span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>定义内存大小变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _512KB = <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _7MB = <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _8MB = <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>案例1：没有创建数组对象，看参数运行情况</p><p>案例2：创建一个4M的数组，查看内存分配情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个4M大小的数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_4MB] ;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total 9216K, used 8192K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">100</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>)  <span class="comment">// 在伊甸园中创建对象</span></span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 0K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,   <span class="number">0</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>没有触发GC操作，对象直接在Eden分配；</p><p>案例3：创建一个7M的数组，查看内存分配情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个7M大小的数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_7MB] ;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 触发垃圾回收</span><br><span class="line">[GC (Allocation Failure) [DefNew: 2004K-&gt;647K(9216K), <span class="number">0.0023439</span> secs] 2004K-&gt;647K(19456K), <span class="number">0.0024142</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total 9216K, used 7897K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">88</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff314930</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">63</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff5a1e58</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 0K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,   <span class="number">0</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>由于程序在启动的时候jdk内部还会存在一些对象的创建，因此当我们分配了一个7M的内存空间，eden内存不足，因此发生了一次Minor GC！并且将存</p><p>活下的对象最终存储到from区中。</p><p>案例4： 在案例3的基础上，在分配一个512KB的数组内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_7MB] ;</span><br><span class="line"><span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_512KB] ;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2005K-&gt;623K(9216K), <span class="number">0.0015235</span> secs] 2005K-&gt;623K(19456K), <span class="number">0.0015799</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total 9216K, used 8713K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">98</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff3e6820</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">60</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff59bdb8</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 0K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,   <span class="number">0</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><p>触发一次GC操作！并且将存活下的对象最终存储到from区中，第二次分配_512KB大小的内存空间的时候，直接在伊甸园分配即可。</p><p>案例5： 在4的基础上在分配一个512KB的数组内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_7MB] ;</span><br><span class="line"><span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_512KB] ;</span><br><span class="line"><span class="keyword">byte</span>[] bytes3 = <span class="keyword">new</span> <span class="keyword">byte</span>[_512KB] ;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2004K-&gt;620K(9216K), <span class="number">0.0018706</span> secs] 2004K-&gt;620K(19456K), <span class="number">0.0019275</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8628K-&gt;539K(9216K), <span class="number">0.0063389</span> secs] 8628K-&gt;8323K(19456K), <span class="number">0.0063773</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.01</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total 9216K, used 1133K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,   <span class="number">7</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec94930</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">52</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff486de0</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 7784K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">76</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd9a040</span>, <span class="number">0x00000000ffd9a200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>触发了2次垃圾回收！并且将from区中存活的对象存储到老年代！</p><p><strong>② 大对象直接晋升至老年代</strong></p><p>当对象太大，伊甸园包括幸存区都存放不下时，这时候老年代的连续空间足够，此对象会直接晋升至老年代，不会发生 GC</p><img src="/posts/c5e9cf91/image-20211122221152776.png" alt="image-20211122221152776" style="zoom: 50%;"> <p>结果</p><img src="/posts/c5e9cf91/image-20211122221255321.png" alt="image-20211122221255321" style="zoom:50%;"> <p>案例演示：</p><p>案例1：直接分配一个8M的内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_8MB] ;</span><br></pre></td></tr></table></figure><p>伊甸园总大小只有 8 MB，但新分配的对象大小已经是 8MB，而幸存区都仅有 1MB，也无法容纳这个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total 9216K, used 2169K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">26</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fee1e560</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 8192K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">80</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffe00010</span>, <span class="number">0x00000000ffe00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 376<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>可以看到结果并没有发生 GC，大对象直接被放入了老年代「tenured generation   total 10240K, used 8192K」</p><p>案例演示2：老年代连续空间不足，触发 Full GC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_8MB] ;</span><br><span class="line"><span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_8MB] ;</span><br></pre></td></tr></table></figure><p>第一个 8MB 直接进入老年代，第二个 8MB 对象在分配时发现老年代空间不足，只好尝试先进行一次 Minor GC，结果发现新生代没有连续空间，只好</p><p>触发一次 Full GC，最后发现老年代也没有连续空间，这时出现 OutOfMemoryError</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2004K-&gt;647K(9216K), <span class="number">0.0022693</span> secs][Tenured: 8192K-&gt;8838K(10240K), <span class="number">0.0452151</span> secs] 10197K-&gt;8838K(19456K), [Metaspace: 3438K-&gt;3438K(1056768K)], <span class="number">0.0504669</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.05</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [TenuredException in thread &quot;main&quot; : 8838K-&gt;8820<span class="title">K</span><span class="params">(10240K)</span>, 0.0027463 secs] 8838K-&gt;8820<span class="title">K</span><span class="params">(19456K)</span>, [Metaspace: 3438K-&gt;3438<span class="title">K</span><span class="params">(1056768K)</span>], 0.0027877 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.itheima.jvm.gc.ObjectMemoryDemo.main(ObjectMemoryDemo.java:<span class="number">14</span>)</span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total 9216K, used 246K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,   <span class="number">3</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec3d890</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 8820K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">86</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffe9d220</span>, <span class="number">0x00000000ffe9d400</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3470K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 379<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><blockquote><h3 id="12、对象是怎么从年轻代进入老年代的？"><a href="#12、对象是怎么从年轻代进入老年代的？" class="headerlink" title="12、对象是怎么从年轻代进入老年代的？"></a>12、对象是怎么从年轻代进入老年代的？</h3></blockquote><p>存在3种情况：</p><p>1、如果对象够老，会通过提升（Promotion）进入老年代，这一般是根据对象的年龄进行判断的。</p><p>2、动态对象年龄判定。有的垃圾回收算法，比如G1，并不要求age必须达到15才能晋升到老年代，它会使用一些动态的计算方法。</p><p>3、超出某个大小的对象将直接在老年代分配。不过这个值默认为0，意思是全部首选Eden区进行分配。</p><blockquote><h3 id="13、简单描述一下（分代）垃圾回收的过程？-高频"><a href="#13、简单描述一下（分代）垃圾回收的过程？-高频" class="headerlink" title="13、简单描述一下（分代）垃圾回收的过程？(高频)"></a>13、简单描述一下（分代）垃圾回收的过程？(高频)</h3></blockquote><p><img src="/posts/c5e9cf91/image-20220205135024347.png" alt="image-20220205135024347"> </p><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是2&#x2F;3。</p><p>新生代使用的是复制算法，新生代里有3个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><p>当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：</p><p>1、在Eden区执行了第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称to）</p><p>2、From区中的对象根据对象的年龄值决定去向，达到阈值15移动到老年代，没有达到复制到to区域(复制算法)</p><p>3、在把Eden和to区中的对象清空掉</p><blockquote><h3 id="14、JVM的永久代中会发生垃圾回收么？"><a href="#14、JVM的永久代中会发生垃圾回收么？" class="headerlink" title="14、JVM的永久代中会发生垃圾回收么？"></a>14、JVM的永久代中会发生垃圾回收么？</h3></blockquote><p>永久代会触发垃圾回收的，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。</p><p>注：Java 8 中已经移除了永久代，新加了一个叫做元数据区(Metaspace)的内存区。</p><h1 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h1><blockquote><h3 id="15、常见的垃圾收集器都有哪些？-高频"><a href="#15、常见的垃圾收集器都有哪些？-高频" class="headerlink" title="15、常见的垃圾收集器都有哪些？(高频)"></a>15、常见的垃圾收集器都有哪些？(高频)</h3></blockquote><p>常见的垃圾收集器如下所示：</p><img src="/posts/c5e9cf91/image-20211122221623386.png" alt="image-20211122221623386" style="zoom:50%;"> <p>不同的垃圾收集器，作用的堆内存空间是不一样的；上面的  serial ， parnew ， Paraller Scavenge 是新生代的垃圾回收</p><p>器；CMS ， Serial Old ， </p><p>Paralle Old是老年代的垃圾收集器 ， G1垃圾收集器可以作用于新生代和老年代； 连线表示垃圾收集器可以搭配使用；</p><p><strong>① Serial</strong></p><p>特点：</p><ol><li>Serial是一个单线程的垃圾收集器</li><li>“Stop The World”，它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。在用户不可见的情况下把用户正常工作的线程全部停掉。</li></ol><img src="/posts/c5e9cf91/image-20211122221834107.png" alt="image-20211122221834107" style="zoom:50%;"> <p>应用场景：</p><ol><li>使用场景：多用于桌面应用，Client端的垃圾回收器</li><li>桌面应用内存小，进行垃圾回收的时间比较短，只要不频繁发生停顿就可以接受</li></ol><p>Serial Old收集器是Serial的老年代版本和Serial一样是单线程，使用的算法是”标记-整理”</p><p><strong>② ParNew</strong></p><p>概述: ParNew 收集器其实就是 Serial 收集器的多线程版本</p><img src="/posts/c5e9cf91/image-20211122221953914.png" alt="image-20211122221953914" style="zoom:50%;"> <p>特点：</p><p>1、会触发stop the world</p><p>2、多线程方式进行垃圾回收</p><p>应用场景：它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器</p><p>注意：如果是单核cpu即使使用该垃圾回收器也无法提高执行效率</p><p><strong>③ Parallel Scavenge</strong></p><p>概述：Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p><p>特点：由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器</p><p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即<strong>吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）</strong>，虚拟</p><p>机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%  </p><p>应用场景： 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel old收集器Parallel Scavenge收集器的老年代版本，使用多线程+标记整理算法</p><p><strong>④ CMS(重点)</strong></p><p>概述：CMS  (Concurrent Mark Sweep）收集器是-种以获取最短回收停顿时间为目标的收集器。</p><p>特点：</p><ol><li><p>CMS 收集器是基于“标记-清除”算法实现的</p></li><li><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上,这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好</p><p>的体验。</p></li></ol><img src="/posts/c5e9cf91/image-20211122222251802.png" alt="image-20211122222251802" style="zoom:50%;"> <p>步骤流程：</p><ul><li>初始标记（CMS initial mark)    ——– 标记一下 GC Roots 能直接关联到的对象，速度很快（stop the world）</li><li>并发标记（CMS concurrent mark）  ——– 对初始标记标记过的对象，进行trace（进行追踪，得到所有关联的对象，进行标记）</li><li>重新标记（CMS remark)                   ——– 为了修正并发标记期间因用户程序导致标记产生变动的标记记录（stop the world）</li><li>并发清除（CMS concurrent sweep)</li></ul><p>缺点：会产生垃圾碎片</p><p><strong>⑤ G1</strong></p><p>概述： G1是一个分代的，并行与并发的”<strong>标记-整理</strong>“垃圾回收器。 它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂</p><p>停时间（pause time），同时兼顾良好的吞吐量。</p><p>相比于CMS：</p><ol><li><p>G1垃圾回收器使用的是”标记-整理”，因此其回收得到的空间是连续的。</p></li><li><p>G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内</p><p>存的回收是以region作为基本单位的；</p></li></ol><img src="/posts/c5e9cf91/image-20211122222552239.png" alt="image-20211122222552239" style="zoom:50%;"> <blockquote><h3 id="16、你都用过G1垃圾回收器的哪几个重要参数？"><a href="#16、你都用过G1垃圾回收器的哪几个重要参数？" class="headerlink" title="16、你都用过G1垃圾回收器的哪几个重要参数？"></a>16、你都用过G1垃圾回收器的哪几个重要参数？</h3></blockquote><p><strong>① -XX:MaxGCPauseMillis</strong></p><p>暂停时间，默认值200ms。这是一个软性目标，G1会尽量达成，如果达不成，会逐渐做自我调整。</p><p><strong>② -XX:G1HeapRegionSize</strong></p><p>Region大小，若未指定则默认最多生成2048块，每块的大小需要为2的幂次方，如1,2,4,8,16,32，最大值为32M。</p><p><strong>③ -XX:G1NewSizePercent 和 -XX:G1MaxNewSizePercent</strong></p><p>新生代比例有两个数值指定，下限：-XX:G1NewSizePercent，默认值5%，上限：-XX:G1MaxNewSizePercent，默认值60%。</p><blockquote><h3 id="17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？"><a href="#17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？" class="headerlink" title="17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？"></a>17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？</h3></blockquote><p>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。 而串行收集器对大多数的小应用（在现代处理器上需要大概 </p><p>100M 左右的内存）就足够了。</p><blockquote><h3 id="18、生产上如何配置垃圾收集器的？"><a href="#18、生产上如何配置垃圾收集器的？" class="headerlink" title="18、生产上如何配置垃圾收集器的？"></a>18、生产上如何配置垃圾收集器的？</h3></blockquote><table><thead><tr><th><img src="/images/image-20220205181209799.png" alt="image-20220205181209799"></th></tr></thead></table><p>1、首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的2&#x2F;3（这是想</p><p>给其他进程和操作系统预留一些时间），超过8GB的堆优先选用G1。</p><p>2、接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。</p><p>3、再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。我会通过记录</p><p>详细的GC日志，来找到这个瓶颈点，借用<strong>gceasy（重点）</strong><a href="https://gceasy.io/%E8%BF%99%E6%A0%B7%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%BE%88%E5%AE%B9%E6%98%93%E5%AE%9A%E4%BD%8D%E5%88%B0%E9%97%AE%E9%A2%98%E3%80%82%E4%B9%8B%E6%89%80%E4%BB%A5%E9%80%89%E6%8B%A9%E9%87%87%E7%94%A8%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%98%AF%E5%9B%A0">https://gceasy.io/这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因</a></p><p>为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。</p><p><img src="/posts/c5e9cf91/image-20220216235212123.png" alt="image-20220216235212123"> </p><h1 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5 类加载器"></a>5 类加载器</h1><blockquote><h3 id="19、什么是类加载器，类加载器有哪些？-高频"><a href="#19、什么是类加载器，类加载器有哪些？-高频" class="headerlink" title="19、什么是类加载器，类加载器有哪些？(高频)"></a>19、什么是类加载器，类加载器有哪些？(高频)</h3></blockquote><p>类加载器的作用：负载将的class文件加载到java虚拟机中，并为之创建一个Class对象</p><p>从Java虚拟机的角度来讲，只存在如下两种不同的类加载器：</p><ol><li>启动类加载器（Bootstrap ClassLoader）, 这个类加载器使用C++语言实现，是虚拟机自身的一部分</li><li>其他类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类（java.lang.ClassLoader）</li></ol><p>从Java开发人员的角度来讲，类加载器还可以划分的更细致一下，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p><ol><li><p>启动类加载器（Bootstrap class loader）：它是虚拟机的内置类加载器，通过表示为null</p></li><li><p>平台类加载器（Platform class loader）  ：它是平台类加载器； 负责加载JDK中一些特殊的模块；</p></li><li><p>系统类加载器（System class loader）    ：它也被称为应用程序类加载器， 它负责加载用户类路径上所指定的类库，一般情况下这个就是程序中默</p><p>认的类加载器</p></li></ol><blockquote><h3 id="20、Java的双亲委托机制是什么？-高频"><a href="#20、Java的双亲委托机制是什么？-高频" class="headerlink" title="20、Java的双亲委托机制是什么？(高频)"></a>20、Java的双亲委托机制是什么？(高频)</h3></blockquote><p><strong>概述</strong></p><p>我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自定义的类加载器。这些类加载器之间的层次关系一般会如下图所</p><p>示：</p><img src="/posts/c5e9cf91/1577331614462.png" alt="1577331614462" style="zoom:33%;">   <p>上图所展示的类加载器之间的这种层次关系，就称之为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该</p><p>有自己的父类加载器。这里的类加载器的父子关系不是真正物理意义上的继承，而是逻辑上的继承。</p><p><strong>工作过程</strong></p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个</p><p>层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索</p><p>返回中没有找到所需的类）时，子类加载器才会尝试自己去加载。</p><h1 id="6-性能调优"><a href="#6-性能调优" class="headerlink" title="6 性能调优"></a>6 性能调优</h1><blockquote><h3 id="21、调优命令有哪些？"><a href="#21、调优命令有哪些？" class="headerlink" title="21、调优命令有哪些？"></a>21、调优命令有哪些？</h3></blockquote><p>1、<strong>jps</strong>，JVM Process Status Tool显示指定系统内所有的HotSpot虚拟机进程。</p><p>2、<strong>jstat</strong>，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运</p><p>行数据。</p><p>查询帮助文档：jstat -options</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205192109645.png" alt="image-20220205192109645"></th></tr></thead></table><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205192221590.png" alt="image-20220205192221590"></th></tr></thead></table><p>3、<strong>jmap</strong>，JVM Memory Map命令用于查看<strong>堆内存</strong>的分配情况以及生成heap dump文件 </p><p>查询帮助文档：jmap -h</p><p>示例1：jmap -heap 33193 查询堆内存的分配情况</p><p>示例2：jmap -dump:format&#x3D;b,file&#x3D;thread-cup.log 33193</p><p>4、<strong>jhat</strong>，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的</p><p>分析结果后，可以在浏览器中查看</p><p>查询帮助文档：</p><p>jhat -h</p><p>示例：jhat -J-Xmx512M thread-cup.log</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205193256668.png" alt="image-20220205193256668"></th></tr></thead></table><p>5、<strong>jstack</strong>，用于生成java虚拟机当前时刻的线程快照。</p><p>查看帮助文档：jstack -h</p><p>示例：jstack -l 33193</p><p>6、<strong>jinfo</strong>，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</p><p>查看帮助文档：jinfo -h</p><p>示例：jinfo -flags 33193</p><table><thead><tr><th><img src="/posts/c5e9cf91/image-20220205193604548.png" alt="image-20220205193604548"></th></tr></thead></table><blockquote><h3 id="22、你知道哪些JVM性能调优参数？-高频"><a href="#22、你知道哪些JVM性能调优参数？-高频" class="headerlink" title="22、你知道哪些JVM性能调优参数？(高频)"></a>22、你知道哪些JVM性能调优参数？(高频)</h3></blockquote><p>1、设定堆内存大小：</p><p>​-Xms设置最小堆内存大小(不能小于1024K); -Xms 堆内存初始大小，可以通过jmap工具进行查看</p><p>​-Xmx设置最大堆内存大小(不能小于1024K);     -Xmx 堆内存最大值，可以通过jmap工具进行查看</p><p>2、设定新生代大小：</p><p>​-XX:NewSize：新生代大小</p><p>​-XX:NewRatio 新生代和老生代占比</p><p>3、-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p><p>4、设定垃圾回收器</p><p>​年轻代用 -XX:+UseParNewGC </p><p>​年老代用-XX:+UseConcMarkSweepGC</p><blockquote><h3 id="23、你用过哪些性能调优工具？-高频"><a href="#23、你用过哪些性能调优工具？-高频" class="headerlink" title="23、你用过哪些性能调优工具？(高频)"></a>23、你用过哪些性能调优工具？(高频)</h3></blockquote><p>常用调优工具分为两类</p><p>1、jdk自带监控工具</p><ul><li><p>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类</p><p>等的监控</p></li><li><p>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</p></li></ul><p>2、第三方</p><ul><li><p>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和</p><p>减少内存消耗</p></li><li><p>GChisto，一款专业分析gc日志的工具</p></li></ul><blockquote><h3 id="24、你都有哪些手段用来排查内存溢出？-高频"><a href="#24、你都有哪些手段用来排查内存溢出？-高频" class="headerlink" title="24、你都有哪些手段用来排查内存溢出？(高频)"></a>24、你都有哪些手段用来排查内存溢出？(高频)</h3></blockquote><p>内存溢出包含很多种情况，我在平常工作中遇到最多的就是堆溢出。有一次线上遇到故障，重新启动后，使用<strong>jstat</strong>命令，发现Old区在一直增长。我使用</p><p><strong>jmap</strong>命令，导出了一份线上堆栈，然后使用MAT进行分析。通过对GC Roots的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学做缓</p><p>存用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 Guava Cache，并设置了弱引用，故障就消失了。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
