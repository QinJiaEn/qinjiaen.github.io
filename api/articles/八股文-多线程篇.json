{"title":"八股文-多线程篇","slug":"八股文-多线程篇","date":"2023-07-29T08:49:10.000Z","updated":"2023-09-07T06:55:18.914Z","comments":true,"path":"api/articles/八股文-多线程篇.json","excerpt":null,"covers":["/posts/51401971/image-20230729175351086.png","/posts/51401971/image-20230729175326764.png","/posts/51401971/image-20230729175508967.png","/posts/51401971/image-20230729175559633.png","/posts/51401971/image-20230730101644568.png","/posts/51401971/image-20230730151902018.png","/posts/51401971/image-20230730195405751.png","/posts/51401971/image-20230731112245241.png","/posts/51401971/image-20230731112001825.png"],"content":"<h1 id=\"多线程篇\"><a href=\"#多线程篇\" class=\"headerlink\" title=\"多线程篇\"></a>多线程篇</h1><h2 id=\"线程的基础知识\"><a href=\"#线程的基础知识\" class=\"headerlink\" title=\"线程的基础知识\"></a>线程的基础知识</h2><h3 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h3><pre><code>二者对比：\n    进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务\n    不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间\n    线程更轻量，线程上下文切换成本一般上要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）\n</code></pre>\n<h3 id=\"并行和并发有什么区别？\"><a href=\"#并行和并发有什么区别？\" class=\"headerlink\" title=\"并行和并发有什么区别？\"></a>并行和并发有什么区别？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并发：</span><br><span class=\"line\">\t同一时间应对多件事情的能力（轮流交替执行）【多个线程轮流使用一个或多个 CPU 】</span><br><span class=\"line\">并行：</span><br><span class=\"line\">\t同一时间动手做多件事情的能力（一起执行）【4核 CPU 同时执行4个线程】</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建线程的方式有哪些？\"><a href=\"#创建线程的方式有哪些？\" class=\"headerlink\" title=\"创建线程的方式有哪些？\"></a>创建线程的方式有哪些？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">继承 Thread 类</span><br><span class=\"line\">实现 runnable 接口</span><br><span class=\"line\">实现 Callable 接口</span><br><span class=\"line\">线程池创建线程</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/posts/51401971/image-20230729175351086.png\" alt=\"image-20230729175351086\"></p>\n<p><img src=\"/posts/51401971/image-20230729175326764.png\" alt=\"image-20230729175326764\"></p>\n<p><img src=\"/posts/51401971/image-20230729175508967.png\" alt=\"image-20230729175508967\"></p>\n<p><img src=\"/posts/51401971/image-20230729175559633.png\" alt=\"image-20230729175559633\"></p>\n<h3 id=\"runnable和Callable有什么区别\"><a href=\"#runnable和Callable有什么区别\" class=\"headerlink\" title=\"runnable和Callable有什么区别\"></a>runnable和Callable有什么区别</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.runnable 接口 run 方法没有返回值</span><br><span class=\"line\">2.Callable 接口 call() 方法有返回值,是个泛型,和 Future\\FutureTask 配合可以用来获取异步执行结果</span><br><span class=\"line\">3.Callable 接口 call() 方法允许抛出异常，而 Runnable 接口的 run() 方法的异常只能内部消化，不允许上抛</span><br></pre></td></tr></table></figure>\n<h3 id=\"在启动线程的时候可以使用-run-方法嘛？run-和-start-有什么区别？\"><a href=\"#在启动线程的时候可以使用-run-方法嘛？run-和-start-有什么区别？\" class=\"headerlink\" title=\"在启动线程的时候可以使用 run 方法嘛？run 和 start 有什么区别？\"></a>在启动线程的时候可以使用 run 方法嘛？run 和 start 有什么区别？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start():</span><br><span class=\"line\">\t用来启动线程，通过该线程调用 run 方法执行 run 方法中所定义的逻辑代码，start 方法只能被调用一次</span><br><span class=\"line\">run():</span><br><span class=\"line\">\t封装了要被线程执行的代码，可以被调用多次</span><br></pre></td></tr></table></figure>\n<h3 id=\"线程包括那些状态，状态之间是如何变化的？\"><a href=\"#线程包括那些状态，状态之间是如何变化的？\" class=\"headerlink\" title=\"线程包括那些状态，状态之间是如何变化的？\"></a>线程包括那些状态，状态之间是如何变化的？</h3><p><img src=\"/posts/51401971/image-20230730101644568.png\" alt=\"image-20230730101644568\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.创建线程对象的时候是\t新建状态</span><br><span class=\"line\">2.调用 start() 方法后转变为\t可执行状态</span><br><span class=\"line\">3.线程获得 CPU 执行权，执行结束是\t终止状态</span><br><span class=\"line\">4.在可执行状态的过程中，如果没有获取 CPU 的执行权，可能会切换到其他状态</span><br><span class=\"line\">\t4.1如果没有获取锁（ synchronized 或者 lock ）进入\t阻塞状态，获得锁切换为可执行状态</span><br><span class=\"line\">\t4.2如果线程调用了 wait() 方法进入\t等待状态，其他线程调用 notify() 唤醒后可切换为可执行状态</span><br><span class=\"line\">\t4.3如果线程调用了 sleep(50) 方法，进入\t计时状态，到时间后切换为可执行状态</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建T1、T2、T3三个线程，如何保证它们按照顺序执行？\"><a href=\"#新建T1、T2、T3三个线程，如何保证它们按照顺序执行？\" class=\"headerlink\" title=\"新建T1、T2、T3三个线程，如何保证它们按照顺序执行？\"></a>新建T1、T2、T3三个线程，如何保证它们按照顺序执行？</h3><p><strong>可使用线程中的join方法解决</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果在 T2 线程中加入如下方法</span><br><span class=\"line\">\tT1.join();\t\t// 那么 T2 线程阻塞，进入\t计时等待状态，等 T1 线程执行完，那么 T2 线程继续执行</span><br></pre></td></tr></table></figure>\n<h3 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify() 和 notifyAll() 有什么区别？\"></a>notify() 和 notifyAll() 有什么区别？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">notifyAll()：</span><br><span class=\"line\">\t唤醒所有 wait 的线程</span><br><span class=\"line\">notify：</span><br><span class=\"line\">\t只随机唤醒一个 wait 线程</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java-中-wait-和-sleep-方法的不同？\"><a href=\"#Java-中-wait-和-sleep-方法的不同？\" class=\"headerlink\" title=\"Java 中 wait 和 sleep 方法的不同？\"></a>Java 中 wait 和 sleep 方法的不同？</h3><p><strong>共同点</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wait(), wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</span><br></pre></td></tr></table></figure>\n<p><strong>不同点</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.方法归属不同</span><br><span class=\"line\">\tsleep(long) 是 Thread 的静态方法</span><br><span class=\"line\">\twait(),wait(long) 是 Object 的成员方法，每个对象都有</span><br><span class=\"line\">2.醒来时机不同</span><br><span class=\"line\">\t执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</span><br><span class=\"line\">\twait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</span><br><span class=\"line\">\t它们都可以被打断唤醒</span><br><span class=\"line\">3.锁特性不同（重点）</span><br><span class=\"line\">\twait 方法的调用必须先获取 wait 对象的锁，而 sleep 则没有这样的限制</span><br><span class=\"line\">\twait 方法执行后会释放对象锁，允许其他线程获得该对象锁，也就是说（我放弃 CPU，但是你们还可以使用）</span><br><span class=\"line\">\tsleep 如果在 synchronized 代码块中执行，并不会释放对象锁，也就是说（我放弃了 CPU，但是你们也用不了）</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程中的并发安全\"><a href=\"#线程中的并发安全\" class=\"headerlink\" title=\"线程中的并发安全\"></a>线程中的并发安全</h2><h3 id=\"synchronized-关键字底层原理\"><a href=\"#synchronized-关键字底层原理\" class=\"headerlink\" title=\"synchronized 关键字底层原理\"></a>synchronized 关键字底层原理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Synchronized 【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</span><br><span class=\"line\">它底层是由 Monitor 实现的， Monitor 是 JVM 级别的对象（C++实现的）线程获得锁需要使用对象锁来关联 Monitor</span><br><span class=\"line\">在 Monitor 内部有三个属性，分别是 owner、entryList、waiset</span><br><span class=\"line\">其中 owner 是关联的获得锁线程，并且只能关联一个线程、entry 关联的是处于阻塞状态的线程，外套 set 关联的是处于 Waiting 状态的线程 </span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Monitor重量级锁</strong><img src=\"/posts/51401971/image-20230730151902018.png\" alt=\"image-20230730151902018\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当一个线程进入 synchronized 代码块中，会让对象锁和 Monitor 进行关联，检查一下 Monitor 中的 Owner 是否为 null ，如果为 null，则让当前线程持有，如果不为 null 则让线程去 EntryList 中进行等待，也就是阻塞，最后如果线程执行了 wait() 方法，则会进入 WaitSet 中</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"谈谈JMM（Java内存模型）\"><a href=\"#谈谈JMM（Java内存模型）\" class=\"headerlink\" title=\"谈谈JMM（Java内存模型）\"></a>谈谈JMM（Java内存模型）</h3><p><strong>Java内存模型</strong> <img src=\"/posts/51401971/image-20230730195405751.png\" alt=\"image-20230730195405751\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JMM（Java Memory Model）Java内存模型，定义了 共享内存 中 多线程程序读写操作 的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</span><br><span class=\"line\">JMM 把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</span><br><span class=\"line\">线程跟线程之间是相互隔离，线程跟线程交互需要通过主线程</span><br></pre></td></tr></table></figure>\n<h3 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAS 是基于乐观锁的思想：</span><br><span class=\"line\">\t最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点在重试呗</span><br><span class=\"line\">Synchronized 是基于悲观锁的思想：</span><br><span class=\"line\">\t最悲观的估计，得防着其他线程来修改共享变量，我上锁了你们都别想改，我改完了解开锁，你们才有机会。</span><br></pre></td></tr></table></figure>\n<h3 id=\"CAS-你知道嘛？\"><a href=\"#CAS-你知道嘛？\" class=\"headerlink\" title=\"CAS 你知道嘛？\"></a>CAS 你知道嘛？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAS全程是：</span><br><span class=\"line\">\tCompare And Swap （比较在交换）；它体现的是一种乐观锁的思想，在无所状态下保证线程操作数据的原子性</span><br><span class=\"line\">\tCas 使用到的地方很多： AQS框架 AtomicXxx类</span><br><span class=\"line\">\t在操作共享变量的时候使用的自旋锁，效率上更高一些</span><br><span class=\"line\">\tCAS 的底层是调用的 Unsafe 类中的方法，都是操作系统提供的，其他语言实现的</span><br></pre></td></tr></table></figure>\n<h3 id=\"请谈谈你对-volatile-的理解\"><a href=\"#请谈谈你对-volatile-的理解\" class=\"headerlink\" title=\"请谈谈你对 volatile 的理解\"></a>请谈谈你对 volatile 的理解</h3><p><img src=\"/posts/51401971/image-20230731112245241.png\" alt=\"image-20230731112245241\"></p>\n<p><img src=\"/posts/51401971/image-20230731112001825.png\" alt=\"image-20230731112001825\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后</span><br><span class=\"line\"></span><br><span class=\"line\">1.保证线程间的可见性</span><br><span class=\"line\">\t用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t有可能线程读到的变量没有共享到，是因为   JVM   虚拟机中有一个  JIT（即时编译器）给代码做了优化</span><br><span class=\"line\">\t解决方案一：\t</span><br><span class=\"line\">\t\t在程序运行的时候加入 vm 参数 -Xint 表示禁用即时编译器，不推荐</span><br><span class=\"line\">\t解决方案二：</span><br><span class=\"line\">\t\t在修饰  计划共享变量的时候  加上  volatile  ，告诉 jit，不要对 volatile修饰的变量做优化</span><br><span class=\"line\">\t</span><br><span class=\"line\">2.禁止进行指令重排序</span><br><span class=\"line\">\t 指令重排：</span><br><span class=\"line\">\t \t用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是-AQS\"><a href=\"#什么是-AQS\" class=\"headerlink\" title=\"什么是 AQS\"></a>什么是 AQS</h3><pre><code>全程是 Abstract Queued Synchronized ，即抽象队列同步器。它是构建锁或者其他同步组件的基础框架\n</code></pre>\n","more":"<h1 id=\"多线程篇\"><a href=\"#多线程篇\" class=\"headerlink\" title=\"多线程篇\"></a>多线程篇</h1><h2 id=\"线程的基础知识\"><a href=\"#线程的基础知识\" class=\"headerlink\" title=\"线程的基础知识\"></a>线程的基础知识</h2><h3 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h3><pre><code>二者对比：\n    进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务\n    不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间\n    线程更轻量，线程上下文切换成本一般上要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）\n</code></pre>\n<h3 id=\"并行和并发有什么区别？\"><a href=\"#并行和并发有什么区别？\" class=\"headerlink\" title=\"并行和并发有什么区别？\"></a>并行和并发有什么区别？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并发：</span><br><span class=\"line\">\t同一时间应对多件事情的能力（轮流交替执行）【多个线程轮流使用一个或多个 CPU 】</span><br><span class=\"line\">并行：</span><br><span class=\"line\">\t同一时间动手做多件事情的能力（一起执行）【4核 CPU 同时执行4个线程】</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建线程的方式有哪些？\"><a href=\"#创建线程的方式有哪些？\" class=\"headerlink\" title=\"创建线程的方式有哪些？\"></a>创建线程的方式有哪些？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">继承 Thread 类</span><br><span class=\"line\">实现 runnable 接口</span><br><span class=\"line\">实现 Callable 接口</span><br><span class=\"line\">线程池创建线程</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/posts/51401971/image-20230729175351086.png\" alt=\"image-20230729175351086\"></p>\n<p><img src=\"/posts/51401971/image-20230729175326764.png\" alt=\"image-20230729175326764\"></p>\n<p><img src=\"/posts/51401971/image-20230729175508967.png\" alt=\"image-20230729175508967\"></p>\n<p><img src=\"/posts/51401971/image-20230729175559633.png\" alt=\"image-20230729175559633\"></p>\n<h3 id=\"runnable和Callable有什么区别\"><a href=\"#runnable和Callable有什么区别\" class=\"headerlink\" title=\"runnable和Callable有什么区别\"></a>runnable和Callable有什么区别</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.runnable 接口 run 方法没有返回值</span><br><span class=\"line\">2.Callable 接口 call() 方法有返回值,是个泛型,和 Future\\FutureTask 配合可以用来获取异步执行结果</span><br><span class=\"line\">3.Callable 接口 call() 方法允许抛出异常，而 Runnable 接口的 run() 方法的异常只能内部消化，不允许上抛</span><br></pre></td></tr></table></figure>\n<h3 id=\"在启动线程的时候可以使用-run-方法嘛？run-和-start-有什么区别？\"><a href=\"#在启动线程的时候可以使用-run-方法嘛？run-和-start-有什么区别？\" class=\"headerlink\" title=\"在启动线程的时候可以使用 run 方法嘛？run 和 start 有什么区别？\"></a>在启动线程的时候可以使用 run 方法嘛？run 和 start 有什么区别？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start():</span><br><span class=\"line\">\t用来启动线程，通过该线程调用 run 方法执行 run 方法中所定义的逻辑代码，start 方法只能被调用一次</span><br><span class=\"line\">run():</span><br><span class=\"line\">\t封装了要被线程执行的代码，可以被调用多次</span><br></pre></td></tr></table></figure>\n<h3 id=\"线程包括那些状态，状态之间是如何变化的？\"><a href=\"#线程包括那些状态，状态之间是如何变化的？\" class=\"headerlink\" title=\"线程包括那些状态，状态之间是如何变化的？\"></a>线程包括那些状态，状态之间是如何变化的？</h3><p><img src=\"/posts/51401971/image-20230730101644568.png\" alt=\"image-20230730101644568\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.创建线程对象的时候是\t新建状态</span><br><span class=\"line\">2.调用 start() 方法后转变为\t可执行状态</span><br><span class=\"line\">3.线程获得 CPU 执行权，执行结束是\t终止状态</span><br><span class=\"line\">4.在可执行状态的过程中，如果没有获取 CPU 的执行权，可能会切换到其他状态</span><br><span class=\"line\">\t4.1如果没有获取锁（ synchronized 或者 lock ）进入\t阻塞状态，获得锁切换为可执行状态</span><br><span class=\"line\">\t4.2如果线程调用了 wait() 方法进入\t等待状态，其他线程调用 notify() 唤醒后可切换为可执行状态</span><br><span class=\"line\">\t4.3如果线程调用了 sleep(50) 方法，进入\t计时状态，到时间后切换为可执行状态</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建T1、T2、T3三个线程，如何保证它们按照顺序执行？\"><a href=\"#新建T1、T2、T3三个线程，如何保证它们按照顺序执行？\" class=\"headerlink\" title=\"新建T1、T2、T3三个线程，如何保证它们按照顺序执行？\"></a>新建T1、T2、T3三个线程，如何保证它们按照顺序执行？</h3><p><strong>可使用线程中的join方法解决</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果在 T2 线程中加入如下方法</span><br><span class=\"line\">\tT1.join();\t\t// 那么 T2 线程阻塞，进入\t计时等待状态，等 T1 线程执行完，那么 T2 线程继续执行</span><br></pre></td></tr></table></figure>\n<h3 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify() 和 notifyAll() 有什么区别？\"></a>notify() 和 notifyAll() 有什么区别？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">notifyAll()：</span><br><span class=\"line\">\t唤醒所有 wait 的线程</span><br><span class=\"line\">notify：</span><br><span class=\"line\">\t只随机唤醒一个 wait 线程</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java-中-wait-和-sleep-方法的不同？\"><a href=\"#Java-中-wait-和-sleep-方法的不同？\" class=\"headerlink\" title=\"Java 中 wait 和 sleep 方法的不同？\"></a>Java 中 wait 和 sleep 方法的不同？</h3><p><strong>共同点</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wait(), wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</span><br></pre></td></tr></table></figure>\n<p><strong>不同点</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.方法归属不同</span><br><span class=\"line\">\tsleep(long) 是 Thread 的静态方法</span><br><span class=\"line\">\twait(),wait(long) 是 Object 的成员方法，每个对象都有</span><br><span class=\"line\">2.醒来时机不同</span><br><span class=\"line\">\t执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</span><br><span class=\"line\">\twait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</span><br><span class=\"line\">\t它们都可以被打断唤醒</span><br><span class=\"line\">3.锁特性不同（重点）</span><br><span class=\"line\">\twait 方法的调用必须先获取 wait 对象的锁，而 sleep 则没有这样的限制</span><br><span class=\"line\">\twait 方法执行后会释放对象锁，允许其他线程获得该对象锁，也就是说（我放弃 CPU，但是你们还可以使用）</span><br><span class=\"line\">\tsleep 如果在 synchronized 代码块中执行，并不会释放对象锁，也就是说（我放弃了 CPU，但是你们也用不了）</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程中的并发安全\"><a href=\"#线程中的并发安全\" class=\"headerlink\" title=\"线程中的并发安全\"></a>线程中的并发安全</h2><h3 id=\"synchronized-关键字底层原理\"><a href=\"#synchronized-关键字底层原理\" class=\"headerlink\" title=\"synchronized 关键字底层原理\"></a>synchronized 关键字底层原理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Synchronized 【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</span><br><span class=\"line\">它底层是由 Monitor 实现的， Monitor 是 JVM 级别的对象（C++实现的）线程获得锁需要使用对象锁来关联 Monitor</span><br><span class=\"line\">在 Monitor 内部有三个属性，分别是 owner、entryList、waiset</span><br><span class=\"line\">其中 owner 是关联的获得锁线程，并且只能关联一个线程、entry 关联的是处于阻塞状态的线程，外套 set 关联的是处于 Waiting 状态的线程 </span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Monitor重量级锁</strong><img src=\"/posts/51401971/image-20230730151902018.png\" alt=\"image-20230730151902018\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当一个线程进入 synchronized 代码块中，会让对象锁和 Monitor 进行关联，检查一下 Monitor 中的 Owner 是否为 null ，如果为 null，则让当前线程持有，如果不为 null 则让线程去 EntryList 中进行等待，也就是阻塞，最后如果线程执行了 wait() 方法，则会进入 WaitSet 中</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"谈谈JMM（Java内存模型）\"><a href=\"#谈谈JMM（Java内存模型）\" class=\"headerlink\" title=\"谈谈JMM（Java内存模型）\"></a>谈谈JMM（Java内存模型）</h3><p><strong>Java内存模型</strong> <img src=\"/posts/51401971/image-20230730195405751.png\" alt=\"image-20230730195405751\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JMM（Java Memory Model）Java内存模型，定义了 共享内存 中 多线程程序读写操作 的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</span><br><span class=\"line\">JMM 把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</span><br><span class=\"line\">线程跟线程之间是相互隔离，线程跟线程交互需要通过主线程</span><br></pre></td></tr></table></figure>\n<h3 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAS 是基于乐观锁的思想：</span><br><span class=\"line\">\t最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点在重试呗</span><br><span class=\"line\">Synchronized 是基于悲观锁的思想：</span><br><span class=\"line\">\t最悲观的估计，得防着其他线程来修改共享变量，我上锁了你们都别想改，我改完了解开锁，你们才有机会。</span><br></pre></td></tr></table></figure>\n<h3 id=\"CAS-你知道嘛？\"><a href=\"#CAS-你知道嘛？\" class=\"headerlink\" title=\"CAS 你知道嘛？\"></a>CAS 你知道嘛？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAS全程是：</span><br><span class=\"line\">\tCompare And Swap （比较在交换）；它体现的是一种乐观锁的思想，在无所状态下保证线程操作数据的原子性</span><br><span class=\"line\">\tCas 使用到的地方很多： AQS框架 AtomicXxx类</span><br><span class=\"line\">\t在操作共享变量的时候使用的自旋锁，效率上更高一些</span><br><span class=\"line\">\tCAS 的底层是调用的 Unsafe 类中的方法，都是操作系统提供的，其他语言实现的</span><br></pre></td></tr></table></figure>\n<h3 id=\"请谈谈你对-volatile-的理解\"><a href=\"#请谈谈你对-volatile-的理解\" class=\"headerlink\" title=\"请谈谈你对 volatile 的理解\"></a>请谈谈你对 volatile 的理解</h3><p><img src=\"/posts/51401971/image-20230731112245241.png\" alt=\"image-20230731112245241\"></p>\n<p><img src=\"/posts/51401971/image-20230731112001825.png\" alt=\"image-20230731112001825\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后</span><br><span class=\"line\"></span><br><span class=\"line\">1.保证线程间的可见性</span><br><span class=\"line\">\t用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t有可能线程读到的变量没有共享到，是因为   JVM   虚拟机中有一个  JIT（即时编译器）给代码做了优化</span><br><span class=\"line\">\t解决方案一：\t</span><br><span class=\"line\">\t\t在程序运行的时候加入 vm 参数 -Xint 表示禁用即时编译器，不推荐</span><br><span class=\"line\">\t解决方案二：</span><br><span class=\"line\">\t\t在修饰  计划共享变量的时候  加上  volatile  ，告诉 jit，不要对 volatile修饰的变量做优化</span><br><span class=\"line\">\t</span><br><span class=\"line\">2.禁止进行指令重排序</span><br><span class=\"line\">\t 指令重排：</span><br><span class=\"line\">\t \t用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是-AQS\"><a href=\"#什么是-AQS\" class=\"headerlink\" title=\"什么是 AQS\"></a>什么是 AQS</h3><pre><code>全程是 Abstract Queued Synchronized ，即抽象队列同步器。它是构建锁或者其他同步组件的基础框架\n</code></pre>\n","categories":[],"tags":[]}