{"title":"八股文(MySQL篇)","slug":"八股文-MySQL篇","date":"2023-07-22T03:29:44.000Z","updated":"2025-11-16T16:53:55.316Z","comments":true,"path":"api/articles/八股文-MySQL篇.json","excerpt":null,"covers":["/posts/a981c63a/image-20230722114559967.png","/posts/a981c63a/image-20230722114745412.png","/posts/a981c63a/image-20230722115055809.png","/posts/a981c63a/image-20230722120440772.png","/posts/a981c63a/image-20230722120552081.png","/posts/a981c63a/image-20230722145956998.png","/posts/a981c63a/image-20230722150942267.png","/posts/a981c63a/image-20230722150900582.png","/posts/a981c63a/image-20230722151337492.png","/posts/a981c63a/image-20230722151744402.png","/posts/a981c63a/image-20230722152022622.png","/posts/a981c63a/image-20230722152441013.png","/posts/a981c63a/image-20230722152926369.png","/posts/a981c63a/image-20230722154259439.png","/posts/a981c63a/image-20230722160021105.png","/posts/a981c63a/image-20230722160318754.png","/posts/a981c63a/image-20230723121537774.png","/posts/a981c63a/image-20230723143012977.png","/posts/a981c63a/image-20230723143246259.png","/posts/a981c63a/image-20230723143732614.png","/posts/a981c63a/image-20230723143953083.png","/posts/a981c63a/image-20230723144137791.png","/posts/a981c63a/image-20230723154445552.png","/posts/a981c63a/image-20230723154852733.png","/posts/a981c63a/image-20230723163939303.png","/posts/a981c63a/image-20230723164102215.png","/posts/a981c63a/image-20230723164511393.png","/posts/a981c63a/image-20230723165007068.png","/posts/a981c63a/image-20230723165737796.png"],"content":"<h1 id=\"MySQL篇\"><a href=\"#MySQL篇\" class=\"headerlink\" title=\"MySQL篇\"></a>MySQL篇</h1><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p><img src=\"/posts/a981c63a/image-20230722114559967.png\" alt=\"image-20230722114559967\"></p>\n<h2 id=\"慢查询\"><a href=\"#慢查询\" class=\"headerlink\" title=\"慢查询\"></a>慢查询</h2><p><img src=\"/posts/a981c63a/image-20230722114745412.png\" alt=\"image-20230722114745412\"></p>\n<h3 id=\"MySQL自带慢日志\"><a href=\"#MySQL自带慢日志\" class=\"headerlink\" title=\"MySQL自带慢日志\"></a>MySQL自带慢日志</h3><p><img src=\"/posts/a981c63a/image-20230722115055809.png\" alt=\"image-20230722115055809\"></p>\n<p><img src=\"/posts/a981c63a/image-20230722120440772.png\" alt=\"image-20230722120440772\"></p>\n<h3 id=\"e-g\"><a href=\"#e-g\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230722120552081.png\" alt=\"image-20230722120552081\"></p>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p><img src=\"/posts/a981c63a/image-20230722145956998.png\" alt=\"image-20230722145956998\"></p>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B 树\"></a>B 树</h3><p><img src=\"/posts/a981c63a/image-20230722150942267.png\" alt=\"image-20230722150942267\"></p>\n<h3 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+ 树\"></a>B+ 树</h3><p><img src=\"/posts/a981c63a/image-20230722150900582.png\" alt=\"image-20230722150900582\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B+ 树非叶子节点都是指针，只有叶子节点才是数据（并且叶子节点之间连接的是双向链表），所以读写速度更快，便于扫库和区间查询，</span><br><span class=\"line\">MySQL 默认引擎 InnoDB 用的数据结构就是 B+ 树</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"e-g-1\"><a href=\"#e-g-1\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230722151337492.png\" alt=\"image-20230722151337492\"></p>\n<h2 id=\"聚簇索引，非聚簇索引（聚集索引-二级索引）\"><a href=\"#聚簇索引，非聚簇索引（聚集索引-二级索引）\" class=\"headerlink\" title=\"聚簇索引，非聚簇索引（聚集索引,二级索引）\"></a>聚簇索引，非聚簇索引（聚集索引,二级索引）</h2><p><img src=\"/posts/a981c63a/image-20230722151744402.png\" alt=\"image-20230722151744402\"></p>\n<h3 id=\"什么是聚簇索引和非聚簇索引\"><a href=\"#什么是聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"什么是聚簇索引和非聚簇索引\"></a>什么是聚簇索引和非聚簇索引</h3><p><img src=\"/posts/a981c63a/image-20230722152022622.png\" alt=\"image-20230722152022622\"></p>\n<h3 id=\"回表查询\"><a href=\"#回表查询\" class=\"headerlink\" title=\"回表查询\"></a>回表查询</h3><p><img src=\"/posts/a981c63a/image-20230722152441013.png\" alt=\"image-20230722152441013\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回表查询也就是说，先根据二级索引查询到要查询的主键值，然后根据聚集索引查询（因为聚集索引的叶子节点有全部的数据）数据</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"e-g-2\"><a href=\"#e-g-2\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230722152926369.png\" alt=\"image-20230722152926369\"></p>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p><img src=\"/posts/a981c63a/image-20230722154259439.png\" alt=\"image-20230722154259439\"></p>\n<h3 id=\"MySQL-超大分页处理\"><a href=\"#MySQL-超大分页处理\" class=\"headerlink\" title=\"MySQL 超大分页处理\"></a>MySQL 超大分页处理</h3><p><img src=\"/posts/a981c63a/image-20230722160021105.png\" alt=\"image-20230722160021105\"></p>\n<h3 id=\"补充-（为什么实际开发不用-select-from-……）\"><a href=\"#补充-（为什么实际开发不用-select-from-……）\" class=\"headerlink\" title=\"补充  （为什么实际开发不用 select * from ……）\"></a>补充  （为什么实际开发不用 select * from ……）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">覆盖索引是指，查询使用了索引，返回的列，必须在索引中全部能够找到</span><br><span class=\"line\">但是  select * from 的话必然  要进行回表查询  所以查询效率比较低</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"e-g-3\"><a href=\"#e-g-3\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230722160318754.png\" alt=\"image-20230722160318754\"></p>\n<h2 id=\"索引失效问题\"><a href=\"#索引失效问题\" class=\"headerlink\" title=\"索引失效问题\"></a>索引失效问题</h2><h3 id=\"1-违反了最左前缀法则\"><a href=\"#1-违反了最左前缀法则\" class=\"headerlink\" title=\"1.违反了最左前缀法则\"></a>1.<strong>违反了最左前缀法则</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最左前缀法则：</span><br><span class=\"line\">\t指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/posts/a981c63a/image-20230723121537774.png\" alt=\"image-20230723121537774\"></p>\n<h3 id=\"2-范围查询右边的列，不能使用索引\"><a href=\"#2-范围查询右边的列，不能使用索引\" class=\"headerlink\" title=\"2.范围查询右边的列，不能使用索引\"></a>2.范围查询右边的列，不能使用索引</h3><p><img src=\"/posts/a981c63a/image-20230723143012977.png\" alt=\"image-20230723143012977\"></p>\n<h3 id=\"3-不要在索引列上进行运算操作，索引将失效\"><a href=\"#3-不要在索引列上进行运算操作，索引将失效\" class=\"headerlink\" title=\"3.不要在索引列上进行运算操作，索引将失效\"></a>3.不要在索引列上进行运算操作，索引将失效</h3><p><img src=\"/posts/a981c63a/image-20230723143246259.png\" alt=\"image-20230723143246259\"></p>\n<h3 id=\"4-字符串不加单引号，造成索引失效（类型转换）\"><a href=\"#4-字符串不加单引号，造成索引失效（类型转换）\" class=\"headerlink\" title=\"4.字符串不加单引号，造成索引失效（类型转换）\"></a>4.字符串不加单引号，造成索引失效（类型转换）</h3><p><img src=\"/posts/a981c63a/image-20230723143732614.png\" alt=\"image-20230723143732614\"></p>\n<h3 id=\"5-模糊查询有可能导致索引失效（以-开头的模糊查询）\"><a href=\"#5-模糊查询有可能导致索引失效（以-开头的模糊查询）\" class=\"headerlink\" title=\"5.模糊查询有可能导致索引失效（以 % 开头的模糊查询）\"></a>5.模糊查询有可能导致索引失效（以 % 开头的模糊查询）</h3><p><img src=\"/posts/a981c63a/image-20230723143953083.png\" alt=\"image-20230723143953083\"></p>\n<h3 id=\"e-g-4\"><a href=\"#e-g-4\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230723144137791.png\" alt=\"image-20230723144137791\"></p>\n<h2 id=\"SQL的优化\"><a href=\"#SQL的优化\" class=\"headerlink\" title=\"SQL的优化\"></a>SQL的优化</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表的设计优化</span><br><span class=\"line\">索引优化</span><br><span class=\"line\">SQL语句优化</span><br><span class=\"line\">主从复制，读写分离</span><br><span class=\"line\">分库分表</span><br></pre></td></tr></table></figure>\n<h3 id=\"表的设计优化（参考《阿里巴巴开发手册》（嵩山版））\"><a href=\"#表的设计优化（参考《阿里巴巴开发手册》（嵩山版））\" class=\"headerlink\" title=\"表的设计优化（参考《阿里巴巴开发手册》（嵩山版））\"></a>表的设计优化（参考《阿里巴巴开发手册》（嵩山版））</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如设置合适的数值（tinyint int bigint）要根据实际情况选择</span><br><span class=\"line\">比如设置合适的字符串类型（char和varChar）char定长效率高，varChar可变长度，效率稍低</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SQL语句优化\"><a href=\"#SQL语句优化\" class=\"headerlink\" title=\"SQL语句优化\"></a>SQL语句优化</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select语句务必指明字段名称（避免直接使用select *）</span><br><span class=\"line\">SQL语句要避免造成索引失效的写法</span><br><span class=\"line\">尽量用union all 代替union union会多一次过滤，效率低</span><br><span class=\"line\">避免在where子句中对字段进行表达式操作</span><br><span class=\"line\">Join优化能用innerjoin就不用left join  right join 如必须使用一定要小表为驱动</span><br><span class=\"line\">内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边，left join或right join，不会重新调整顺序</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"主从复制、读写分离\"><a href=\"#主从复制、读写分离\" class=\"headerlink\" title=\"主从复制、读写分离\"></a>主从复制、读写分离</h3><p><img src=\"/posts/a981c63a/image-20230723154445552.png\" alt=\"image-20230723154445552\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离的架构，读写分离解决的是，数据库的写入，影响了查询的效率</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"e-g-5\"><a href=\"#e-g-5\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230723154852733.png\" alt=\"image-20230723154852733\"></p>\n<h2 id=\"事务（ACID）\"><a href=\"#事务（ACID）\" class=\"headerlink\" title=\"事务（ACID）\"></a>事务（ACID）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务：</span><br><span class=\"line\">\t事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</span><br><span class=\"line\">一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</span><br><span class=\"line\">隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</span><br><span class=\"line\">持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"并发事务问题\"><a href=\"#并发事务问题\" class=\"headerlink\" title=\"并发事务问题\"></a>并发事务问题</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">脏读：一个事务读到另一个事务还没有提交的数据。</span><br><span class=\"line\">不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</span><br><span class=\"line\">幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h4><p><img src=\"/posts/a981c63a/image-20230723163939303.png\" alt=\"image-20230723163939303\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务B  读（select）到了事务A还没提交的数据</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h4><p><img src=\"/posts/a981c63a/image-20230723164102215.png\" alt=\"image-20230723164102215\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A  第一次读（select）到一条数据</span><br><span class=\"line\">事务B 紧接着修改（update）了这条数据并且commit了数据</span><br><span class=\"line\">事务A又一次读到了这条数据</span><br><span class=\"line\">但是事务A 两次查询数据不一样叫做不可重复读</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h4><p><img src=\"/posts/a981c63a/image-20230723164511393.png\" alt=\"image-20230723164511393\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A 首先查询id为1的数据发现数据库中没有该条数据</span><br><span class=\"line\">事务B 插入一条数据id为1   并且提交到数据库中’</span><br><span class=\"line\">事务A 插入一条数据id为1   但是报错   说数据库中已经有id为1的数据</span><br><span class=\"line\">事务A 又一次查询id为1的数据 但是还是没有查到   </span><br><span class=\"line\">（疑问？    不可重复读中，不是可以查询到事务B中提交的数据么）在幻读中我们的前提就是已经解决了不可重复读的问题</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解决并发事务问题\"><a href=\"#解决并发事务问题\" class=\"headerlink\" title=\"解决并发事务问题\"></a>解决并发事务问题</h3><p><img src=\"/posts/a981c63a/image-20230723165007068.png\" alt=\"image-20230723165007068\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">未提交读：什么也解决不了（不用）</span><br><span class=\"line\">读已提交：解决了脏读</span><br><span class=\"line\">可重复读：解决了脏读和不可重复读（MySQL默认隔离级别）</span><br><span class=\"line\">串行化：解决了所有问题，安全级别最高，但是效率最低（不推荐使用）只有一条事务提交，另外的事务才可以进行操作</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"e-g-6\"><a href=\"#e-g-6\" class=\"headerlink\" title=\"e.g\"></a>e.g</h4><p><img src=\"/posts/a981c63a/image-20230723165737796.png\" alt=\"image-20230723165737796\"></p>\n<h3 id=\"事务的隔离性是如何保证的\"><a href=\"#事务的隔离性是如何保证的\" class=\"headerlink\" title=\"事务的隔离性是如何保证的\"></a>事务的隔离性是如何保证的</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">锁：排他锁（如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁）</span><br><span class=\"line\">mvcc: 多版本并发控制</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3>","more":"<h1 id=\"MySQL篇\"><a href=\"#MySQL篇\" class=\"headerlink\" title=\"MySQL篇\"></a>MySQL篇</h1><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p><img src=\"/posts/a981c63a/image-20230722114559967.png\" alt=\"image-20230722114559967\"></p>\n<h2 id=\"慢查询\"><a href=\"#慢查询\" class=\"headerlink\" title=\"慢查询\"></a>慢查询</h2><p><img src=\"/posts/a981c63a/image-20230722114745412.png\" alt=\"image-20230722114745412\"></p>\n<h3 id=\"MySQL自带慢日志\"><a href=\"#MySQL自带慢日志\" class=\"headerlink\" title=\"MySQL自带慢日志\"></a>MySQL自带慢日志</h3><p><img src=\"/posts/a981c63a/image-20230722115055809.png\" alt=\"image-20230722115055809\"></p>\n<p><img src=\"/posts/a981c63a/image-20230722120440772.png\" alt=\"image-20230722120440772\"></p>\n<h3 id=\"e-g\"><a href=\"#e-g\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230722120552081.png\" alt=\"image-20230722120552081\"></p>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p><img src=\"/posts/a981c63a/image-20230722145956998.png\" alt=\"image-20230722145956998\"></p>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B 树\"></a>B 树</h3><p><img src=\"/posts/a981c63a/image-20230722150942267.png\" alt=\"image-20230722150942267\"></p>\n<h3 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+ 树\"></a>B+ 树</h3><p><img src=\"/posts/a981c63a/image-20230722150900582.png\" alt=\"image-20230722150900582\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B+ 树非叶子节点都是指针，只有叶子节点才是数据（并且叶子节点之间连接的是双向链表），所以读写速度更快，便于扫库和区间查询，</span><br><span class=\"line\">MySQL 默认引擎 InnoDB 用的数据结构就是 B+ 树</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"e-g-1\"><a href=\"#e-g-1\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230722151337492.png\" alt=\"image-20230722151337492\"></p>\n<h2 id=\"聚簇索引，非聚簇索引（聚集索引-二级索引）\"><a href=\"#聚簇索引，非聚簇索引（聚集索引-二级索引）\" class=\"headerlink\" title=\"聚簇索引，非聚簇索引（聚集索引,二级索引）\"></a>聚簇索引，非聚簇索引（聚集索引,二级索引）</h2><p><img src=\"/posts/a981c63a/image-20230722151744402.png\" alt=\"image-20230722151744402\"></p>\n<h3 id=\"什么是聚簇索引和非聚簇索引\"><a href=\"#什么是聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"什么是聚簇索引和非聚簇索引\"></a>什么是聚簇索引和非聚簇索引</h3><p><img src=\"/posts/a981c63a/image-20230722152022622.png\" alt=\"image-20230722152022622\"></p>\n<h3 id=\"回表查询\"><a href=\"#回表查询\" class=\"headerlink\" title=\"回表查询\"></a>回表查询</h3><p><img src=\"/posts/a981c63a/image-20230722152441013.png\" alt=\"image-20230722152441013\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回表查询也就是说，先根据二级索引查询到要查询的主键值，然后根据聚集索引查询（因为聚集索引的叶子节点有全部的数据）数据</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"e-g-2\"><a href=\"#e-g-2\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230722152926369.png\" alt=\"image-20230722152926369\"></p>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p><img src=\"/posts/a981c63a/image-20230722154259439.png\" alt=\"image-20230722154259439\"></p>\n<h3 id=\"MySQL-超大分页处理\"><a href=\"#MySQL-超大分页处理\" class=\"headerlink\" title=\"MySQL 超大分页处理\"></a>MySQL 超大分页处理</h3><p><img src=\"/posts/a981c63a/image-20230722160021105.png\" alt=\"image-20230722160021105\"></p>\n<h3 id=\"补充-（为什么实际开发不用-select-from-……）\"><a href=\"#补充-（为什么实际开发不用-select-from-……）\" class=\"headerlink\" title=\"补充  （为什么实际开发不用 select * from ……）\"></a>补充  （为什么实际开发不用 select * from ……）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">覆盖索引是指，查询使用了索引，返回的列，必须在索引中全部能够找到</span><br><span class=\"line\">但是  select * from 的话必然  要进行回表查询  所以查询效率比较低</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"e-g-3\"><a href=\"#e-g-3\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230722160318754.png\" alt=\"image-20230722160318754\"></p>\n<h2 id=\"索引失效问题\"><a href=\"#索引失效问题\" class=\"headerlink\" title=\"索引失效问题\"></a>索引失效问题</h2><h3 id=\"1-违反了最左前缀法则\"><a href=\"#1-违反了最左前缀法则\" class=\"headerlink\" title=\"1.违反了最左前缀法则\"></a>1.<strong>违反了最左前缀法则</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最左前缀法则：</span><br><span class=\"line\">\t指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/posts/a981c63a/image-20230723121537774.png\" alt=\"image-20230723121537774\"></p>\n<h3 id=\"2-范围查询右边的列，不能使用索引\"><a href=\"#2-范围查询右边的列，不能使用索引\" class=\"headerlink\" title=\"2.范围查询右边的列，不能使用索引\"></a>2.范围查询右边的列，不能使用索引</h3><p><img src=\"/posts/a981c63a/image-20230723143012977.png\" alt=\"image-20230723143012977\"></p>\n<h3 id=\"3-不要在索引列上进行运算操作，索引将失效\"><a href=\"#3-不要在索引列上进行运算操作，索引将失效\" class=\"headerlink\" title=\"3.不要在索引列上进行运算操作，索引将失效\"></a>3.不要在索引列上进行运算操作，索引将失效</h3><p><img src=\"/posts/a981c63a/image-20230723143246259.png\" alt=\"image-20230723143246259\"></p>\n<h3 id=\"4-字符串不加单引号，造成索引失效（类型转换）\"><a href=\"#4-字符串不加单引号，造成索引失效（类型转换）\" class=\"headerlink\" title=\"4.字符串不加单引号，造成索引失效（类型转换）\"></a>4.字符串不加单引号，造成索引失效（类型转换）</h3><p><img src=\"/posts/a981c63a/image-20230723143732614.png\" alt=\"image-20230723143732614\"></p>\n<h3 id=\"5-模糊查询有可能导致索引失效（以-开头的模糊查询）\"><a href=\"#5-模糊查询有可能导致索引失效（以-开头的模糊查询）\" class=\"headerlink\" title=\"5.模糊查询有可能导致索引失效（以 % 开头的模糊查询）\"></a>5.模糊查询有可能导致索引失效（以 % 开头的模糊查询）</h3><p><img src=\"/posts/a981c63a/image-20230723143953083.png\" alt=\"image-20230723143953083\"></p>\n<h3 id=\"e-g-4\"><a href=\"#e-g-4\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230723144137791.png\" alt=\"image-20230723144137791\"></p>\n<h2 id=\"SQL的优化\"><a href=\"#SQL的优化\" class=\"headerlink\" title=\"SQL的优化\"></a>SQL的优化</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表的设计优化</span><br><span class=\"line\">索引优化</span><br><span class=\"line\">SQL语句优化</span><br><span class=\"line\">主从复制，读写分离</span><br><span class=\"line\">分库分表</span><br></pre></td></tr></table></figure>\n<h3 id=\"表的设计优化（参考《阿里巴巴开发手册》（嵩山版））\"><a href=\"#表的设计优化（参考《阿里巴巴开发手册》（嵩山版））\" class=\"headerlink\" title=\"表的设计优化（参考《阿里巴巴开发手册》（嵩山版））\"></a>表的设计优化（参考《阿里巴巴开发手册》（嵩山版））</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如设置合适的数值（tinyint int bigint）要根据实际情况选择</span><br><span class=\"line\">比如设置合适的字符串类型（char和varChar）char定长效率高，varChar可变长度，效率稍低</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SQL语句优化\"><a href=\"#SQL语句优化\" class=\"headerlink\" title=\"SQL语句优化\"></a>SQL语句优化</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select语句务必指明字段名称（避免直接使用select *）</span><br><span class=\"line\">SQL语句要避免造成索引失效的写法</span><br><span class=\"line\">尽量用union all 代替union union会多一次过滤，效率低</span><br><span class=\"line\">避免在where子句中对字段进行表达式操作</span><br><span class=\"line\">Join优化能用innerjoin就不用left join  right join 如必须使用一定要小表为驱动</span><br><span class=\"line\">内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边，left join或right join，不会重新调整顺序</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"主从复制、读写分离\"><a href=\"#主从复制、读写分离\" class=\"headerlink\" title=\"主从复制、读写分离\"></a>主从复制、读写分离</h3><p><img src=\"/posts/a981c63a/image-20230723154445552.png\" alt=\"image-20230723154445552\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离的架构，读写分离解决的是，数据库的写入，影响了查询的效率</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"e-g-5\"><a href=\"#e-g-5\" class=\"headerlink\" title=\"e.g\"></a>e.g</h3><p><img src=\"/posts/a981c63a/image-20230723154852733.png\" alt=\"image-20230723154852733\"></p>\n<h2 id=\"事务（ACID）\"><a href=\"#事务（ACID）\" class=\"headerlink\" title=\"事务（ACID）\"></a>事务（ACID）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务：</span><br><span class=\"line\">\t事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</span><br><span class=\"line\">一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</span><br><span class=\"line\">隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</span><br><span class=\"line\">持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"并发事务问题\"><a href=\"#并发事务问题\" class=\"headerlink\" title=\"并发事务问题\"></a>并发事务问题</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">脏读：一个事务读到另一个事务还没有提交的数据。</span><br><span class=\"line\">不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</span><br><span class=\"line\">幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h4><p><img src=\"/posts/a981c63a/image-20230723163939303.png\" alt=\"image-20230723163939303\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务B  读（select）到了事务A还没提交的数据</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h4><p><img src=\"/posts/a981c63a/image-20230723164102215.png\" alt=\"image-20230723164102215\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A  第一次读（select）到一条数据</span><br><span class=\"line\">事务B 紧接着修改（update）了这条数据并且commit了数据</span><br><span class=\"line\">事务A又一次读到了这条数据</span><br><span class=\"line\">但是事务A 两次查询数据不一样叫做不可重复读</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h4><p><img src=\"/posts/a981c63a/image-20230723164511393.png\" alt=\"image-20230723164511393\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A 首先查询id为1的数据发现数据库中没有该条数据</span><br><span class=\"line\">事务B 插入一条数据id为1   并且提交到数据库中’</span><br><span class=\"line\">事务A 插入一条数据id为1   但是报错   说数据库中已经有id为1的数据</span><br><span class=\"line\">事务A 又一次查询id为1的数据 但是还是没有查到   </span><br><span class=\"line\">（疑问？    不可重复读中，不是可以查询到事务B中提交的数据么）在幻读中我们的前提就是已经解决了不可重复读的问题</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解决并发事务问题\"><a href=\"#解决并发事务问题\" class=\"headerlink\" title=\"解决并发事务问题\"></a>解决并发事务问题</h3><p><img src=\"/posts/a981c63a/image-20230723165007068.png\" alt=\"image-20230723165007068\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">未提交读：什么也解决不了（不用）</span><br><span class=\"line\">读已提交：解决了脏读</span><br><span class=\"line\">可重复读：解决了脏读和不可重复读（MySQL默认隔离级别）</span><br><span class=\"line\">串行化：解决了所有问题，安全级别最高，但是效率最低（不推荐使用）只有一条事务提交，另外的事务才可以进行操作</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"e-g-6\"><a href=\"#e-g-6\" class=\"headerlink\" title=\"e.g\"></a>e.g</h4><p><img src=\"/posts/a981c63a/image-20230723165737796.png\" alt=\"image-20230723165737796\"></p>\n<h3 id=\"事务的隔离性是如何保证的\"><a href=\"#事务的隔离性是如何保证的\" class=\"headerlink\" title=\"事务的隔离性是如何保证的\"></a>事务的隔离性是如何保证的</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">锁：排他锁（如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁）</span><br><span class=\"line\">mvcc: 多版本并发控制</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3>","categories":[],"tags":[]}