{"title":"八股文-集合篇","slug":"八股文-集合篇","date":"2023-07-28T10:01:25.000Z","updated":"2025-11-16T16:53:56.184Z","comments":true,"path":"api/articles/八股文-集合篇.json","excerpt":null,"covers":["/posts/724f0833/image-20230728194105302.png","/posts/724f0833/image-20230729111016097.png","/posts/724f0833/image-20230729115750891.png"],"content":"<h1 id=\"集合篇\"><a href=\"#集合篇\" class=\"headerlink\" title=\"集合篇\"></a>集合篇</h1><p><strong><img src=\"/posts/724f0833/image-20230728194105302.png\" alt=\"image-20230728194105302\"></strong></p>\n<p><strong>数组</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组是一种 用连续的内存空间 存储  相同数据类型  数据的线性数据结构</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><h4 id=\"ArrayList的底层的实现原理是什么\"><a href=\"#ArrayList的底层的实现原理是什么\" class=\"headerlink\" title=\"ArrayList的底层的实现原理是什么\"></a>ArrayList的底层的实现原理是什么</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList底层是用动态数组实现的</span><br><span class=\"line\">ArrayList初始容量是0，当第一次添加元素的时候才会初始化容量为10</span><br><span class=\"line\">ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组（a &gt;&gt; 1）就是除2操作</span><br><span class=\"line\">ArrayList在添加数据的时候</span><br><span class=\"line\">\t确保数组已使用长度加1之后足够存下 下一个数据</span><br><span class=\"line\">\t计算数组的容量，如果当前数组已使用长度加1后的大于当前数组长度，则调用grow方法扩容（原来的1.5倍）</span><br><span class=\"line\">\t确保新增的数据有地方存储后，则将新元素添加到位于size的位置上</span><br><span class=\"line\">\t返回添加成功布尔值</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Array-List和LinkedList的区别是什么\"><a href=\"#Array-List和LinkedList的区别是什么\" class=\"headerlink\" title=\"Array List和LinkedList的区别是什么\"></a>Array List和LinkedList的区别是什么</h3><ul>\n<li><p>底层数据结构</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList是基于动态数组的数据结构</span><br><span class=\"line\">LinkedList是基于双向链表的数据结构</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>效率</p>\n</li>\n<li><p>空间</p>\n</li>\n<li><p>线程是否安全</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList和LinkedList都不是线程安全的</span><br><span class=\"line\">  \t如果要保证线程安全，有两种方案：</span><br><span class=\"line\">  \t\t在方法内部使用，也就是说局部变量，局部变量是线程安全的</span><br><span class=\"line\">  \t\t使用线程安全的ArrayList和LinkedList</span><br><span class=\"line\">  \t\tCollections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class=\"line\">  \t\tCollections.synchronizedList(new LinkedList&lt;&gt;());</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><h4 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a><strong>散列表</strong></h4><pre><code>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表\n</code></pre>\n<h4 id=\"HashMap实现原理\"><a href=\"#HashMap实现原理\" class=\"headerlink\" title=\"HashMap实现原理\"></a><strong>HashMap实现原理</strong></h4><p><img src=\"/posts/724f0833/image-20230729111016097.png\" alt=\"image-20230729111016097\"></p>\n<p><strong>HashMap的put流程</strong></p>\n<p><img src=\"/posts/724f0833/image-20230729115750891.png\" alt=\"image-20230729115750891\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.判断键值对数组table是否为空或者为null，不是空的话执行resize()进行扩容（初始化）</span><br><span class=\"line\">2.根据键值key计算hash值得到数组索引</span><br><span class=\"line\">3.判断table[i] == null条件成立，直接新建节点添加</span><br><span class=\"line\">4.如果table[i] == null不成立</span><br><span class=\"line\">\t4.1判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</span><br><span class=\"line\">\t4.2判断table[i]是否为红黑树，如果是红黑树，则直接在树上插入键值对</span><br><span class=\"line\">\t4.3遍历table[i]链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转化为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</span><br><span class=\"line\">5.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshol（数组长度*0.75）如果超过，进行扩容</span><br></pre></td></tr></table></figure>\n\n","more":"<h1 id=\"集合篇\"><a href=\"#集合篇\" class=\"headerlink\" title=\"集合篇\"></a>集合篇</h1><p><strong><img src=\"/posts/724f0833/image-20230728194105302.png\" alt=\"image-20230728194105302\"></strong></p>\n<p><strong>数组</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组是一种 用连续的内存空间 存储  相同数据类型  数据的线性数据结构</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><h4 id=\"ArrayList的底层的实现原理是什么\"><a href=\"#ArrayList的底层的实现原理是什么\" class=\"headerlink\" title=\"ArrayList的底层的实现原理是什么\"></a>ArrayList的底层的实现原理是什么</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList底层是用动态数组实现的</span><br><span class=\"line\">ArrayList初始容量是0，当第一次添加元素的时候才会初始化容量为10</span><br><span class=\"line\">ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组（a &gt;&gt; 1）就是除2操作</span><br><span class=\"line\">ArrayList在添加数据的时候</span><br><span class=\"line\">\t确保数组已使用长度加1之后足够存下 下一个数据</span><br><span class=\"line\">\t计算数组的容量，如果当前数组已使用长度加1后的大于当前数组长度，则调用grow方法扩容（原来的1.5倍）</span><br><span class=\"line\">\t确保新增的数据有地方存储后，则将新元素添加到位于size的位置上</span><br><span class=\"line\">\t返回添加成功布尔值</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Array-List和LinkedList的区别是什么\"><a href=\"#Array-List和LinkedList的区别是什么\" class=\"headerlink\" title=\"Array List和LinkedList的区别是什么\"></a>Array List和LinkedList的区别是什么</h3><ul>\n<li><p>底层数据结构</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList是基于动态数组的数据结构</span><br><span class=\"line\">LinkedList是基于双向链表的数据结构</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>效率</p>\n</li>\n<li><p>空间</p>\n</li>\n<li><p>线程是否安全</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList和LinkedList都不是线程安全的</span><br><span class=\"line\">  \t如果要保证线程安全，有两种方案：</span><br><span class=\"line\">  \t\t在方法内部使用，也就是说局部变量，局部变量是线程安全的</span><br><span class=\"line\">  \t\t使用线程安全的ArrayList和LinkedList</span><br><span class=\"line\">  \t\tCollections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class=\"line\">  \t\tCollections.synchronizedList(new LinkedList&lt;&gt;());</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><h4 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a><strong>散列表</strong></h4><pre><code>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表\n</code></pre>\n<h4 id=\"HashMap实现原理\"><a href=\"#HashMap实现原理\" class=\"headerlink\" title=\"HashMap实现原理\"></a><strong>HashMap实现原理</strong></h4><p><img src=\"/posts/724f0833/image-20230729111016097.png\" alt=\"image-20230729111016097\"></p>\n<p><strong>HashMap的put流程</strong></p>\n<p><img src=\"/posts/724f0833/image-20230729115750891.png\" alt=\"image-20230729115750891\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.判断键值对数组table是否为空或者为null，不是空的话执行resize()进行扩容（初始化）</span><br><span class=\"line\">2.根据键值key计算hash值得到数组索引</span><br><span class=\"line\">3.判断table[i] == null条件成立，直接新建节点添加</span><br><span class=\"line\">4.如果table[i] == null不成立</span><br><span class=\"line\">\t4.1判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</span><br><span class=\"line\">\t4.2判断table[i]是否为红黑树，如果是红黑树，则直接在树上插入键值对</span><br><span class=\"line\">\t4.3遍历table[i]链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转化为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</span><br><span class=\"line\">5.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshol（数组长度*0.75）如果超过，进行扩容</span><br></pre></td></tr></table></figure>\n\n","categories":[],"tags":[]}