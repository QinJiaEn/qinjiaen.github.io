[{"title":"换新笔记本了需要下载的软件","slug":"装机软件","url":"/posts/345213/","content":"## 便捷软件\n\n~~~\n步骤如下：\n\t1.修改配置文件\n\t\t修改_config.yml 里的 post_asset_folder: 这个选项设置为True\n\t2.在_post的同级目录下创建download的文件夹。\n\t3.在文章里引用文件，通过如[点击下载](/download/xx.zip)这样的链接。\n\t4.在文章中引用图片，通过 ![pic](/download/image-20191211200232715.png)这样写入。\n~~~\n\n\n\n[bypass](/download/Bypass_1.14.98.zip)\n\n\n\n~~~\n这是一个typora的激活插件\n~~~\n[NavicatCrack下载链接](/download/NavicatCrack.zip)\n~~~\n这是一个Navicat破解的软件\n~~~\n\n\n![pic](下载尝试/2-1684200807297-1.png)","tags":["下载"]},{"title":"BigeMap 获取行政区域","slug":"获取geo-json数据","url":"/posts/e627e35/","content":"\n## 如何在BigeMap中获取行政区域的json方法\n\n### ###配置地图资源\n\n[资源下载](/download/地图配置.zip)\n\n![image-20230907113811526](获取geo-json数据/image-20230907113811526.png)\n\n\n\n#### 1.打开软件，地图左上角选择地图\n\n![image-20230907113952794](获取geo-json数据/image-20230907113952794.png)\n\n#### 2.配置资源文件\n\n![image-20230907114056444](获取geo-json数据/image-20230907114056444.png)\n\n## 详细步骤配截图\n\n~~~\n目前为止，直接导出kml数据开始收费了，无法使用。需要迂回一下，先导出bmv格式数据，再通过此软件转换，得到每个街道或者乡、镇的kml数据，步骤如下：\n~~~\n\n\n\n### 1.在BigeMap中选择需要的行政区域，并导出该区所有街道的bmv格式数据，保存好。\n\n![image-20230907114307768](获取geo-json数据/image-20230907114307768.png)\n\n### 2. 将第一步导出的bmv格式数据，用Bigemap GIS打开\n\n![image-20230907114441172](获取geo-json数据/image-20230907114441172-1694058281617-1.png)\n\n### 3. 打开bmv格式文件后，在左侧图层管理里面，找到该bmv文件对应的边界。\n\n~~~\n“我的图层”--> 新建图层 --> Xxx。右键点击下载地图。\n~~~\n\n![image-20230907114607404](获取geo-json数据/image-20230907114607404.png)\n\n![image-20230907114658666](获取geo-json数据/image-20230907114658666.png)\n\n### 4. 打开下载的地图，得到一个文件夹\n\n~~~\n文件夹里**.kml**文件就是我们想要的边界数据。\n~~~\n\n![image-20230907114800183](获取geo-json数据/image-20230907114800183.png)\n\n### 5.打开 geojson.io\n\n###### [http://geojson.io](https://link.zhihu.com/?target=http%3A//geojson.io) （[https://geojson.io/#map](https://link.zhihu.com/?target=https%3A//geojson.io/%23map)）\n\n~~~\n在界面中逐一打开所有kml数据，至此获得对应行政区域的边界json\n~~~\n\n![image-20230907114800183](获取geo-json数据/image-20230907115202353.png)\n"},{"title":"八股文-多线程篇","slug":"八股文-多线程篇","url":"/posts/51401971/","content":"\n# 多线程篇\n## 线程的基础知识\n### 线程和进程的区别？\n\t二者对比：\n\t\t进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务\n\t\t不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间\n\t\t线程更轻量，线程上下文切换成本一般上要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）\n### 并行和并发有什么区别？\n~~~\n并发：\n\t同一时间应对多件事情的能力（轮流交替执行）【多个线程轮流使用一个或多个 CPU 】\n并行：\n\t同一时间动手做多件事情的能力（一起执行）【4核 CPU 同时执行4个线程】\n~~~\n### 创建线程的方式有哪些？\n~~~\n继承 Thread 类\n实现 runnable 接口\n实现 Callable 接口\n线程池创建线程\n~~~\n\n![image-20230729175351086](八股文-多线程篇/image-20230729175351086.png)\n\n![image-20230729175326764](八股文-多线程篇/image-20230729175326764.png)\n\n![image-20230729175508967](八股文-多线程篇/image-20230729175508967.png)\n\n![image-20230729175559633](八股文-多线程篇/image-20230729175559633.png)\n### runnable和Callable有什么区别\n~~~\n1.runnable 接口 run 方法没有返回值\n2.Callable 接口 call() 方法有返回值,是个泛型,和 Future\\FutureTask 配合可以用来获取异步执行结果\n3.Callable 接口 call() 方法允许抛出异常，而 Runnable 接口的 run() 方法的异常只能内部消化，不允许上抛\n~~~\n### 在启动线程的时候可以使用 run 方法嘛？run 和 start 有什么区别？\n~~~\nstart():\n\t用来启动线程，通过该线程调用 run 方法执行 run 方法中所定义的逻辑代码，start 方法只能被调用一次\nrun():\n\t封装了要被线程执行的代码，可以被调用多次\n~~~\n### 线程包括那些状态，状态之间是如何变化的？\n\n![image-20230730101644568](八股文-多线程篇/image-20230730101644568.png)\n~~~\n1.创建线程对象的时候是\t新建状态\n2.调用 start() 方法后转变为\t可执行状态\n3.线程获得 CPU 执行权，执行结束是\t终止状态\n4.在可执行状态的过程中，如果没有获取 CPU 的执行权，可能会切换到其他状态\n\t4.1如果没有获取锁（ synchronized 或者 lock ）进入\t阻塞状态，获得锁切换为可执行状态\n\t4.2如果线程调用了 wait() 方法进入\t等待状态，其他线程调用 notify() 唤醒后可切换为可执行状态\n\t4.3如果线程调用了 sleep(50) 方法，进入\t计时状态，到时间后切换为可执行状态\n~~~\n### 新建T1、T2、T3三个线程，如何保证它们按照顺序执行？\n**可使用线程中的join方法解决**\n~~~\n如果在 T2 线程中加入如下方法\n\tT1.join();\t\t// 那么 T2 线程阻塞，进入\t计时等待状态，等 T1 线程执行完，那么 T2 线程继续执行\n~~~\n### notify() 和 notifyAll() 有什么区别？\n~~~\nnotifyAll()：\n\t唤醒所有 wait 的线程\nnotify：\n\t只随机唤醒一个 wait 线程\n~~~\n### Java 中 wait 和 sleep 方法的不同？\n**共同点**\n~~~\nwait(), wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。\n~~~\n**不同点**\n~~~\n1.方法归属不同\n\tsleep(long) 是 Thread 的静态方法\n\twait(),wait(long) 是 Object 的成员方法，每个对象都有\n2.醒来时机不同\n\t执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来\n\twait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去\n\t它们都可以被打断唤醒\n3.锁特性不同（重点）\n\twait 方法的调用必须先获取 wait 对象的锁，而 sleep 则没有这样的限制\n\twait 方法执行后会释放对象锁，允许其他线程获得该对象锁，也就是说（我放弃 CPU，但是你们还可以使用）\n\tsleep 如果在 synchronized 代码块中执行，并不会释放对象锁，也就是说（我放弃了 CPU，但是你们也用不了）\n~~~\n## 线程中的并发安全\n### synchronized 关键字底层原理\n\n~~~\nSynchronized 【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】\n它底层是由 Monitor 实现的， Monitor 是 JVM 级别的对象（C++实现的）线程获得锁需要使用对象锁来关联 Monitor\n在 Monitor 内部有三个属性，分别是 owner、entryList、waiset\n其中 owner 是关联的获得锁线程，并且只能关联一个线程、entry 关联的是处于阻塞状态的线程，外套 set 关联的是处于 Waiting 状态的线程 \n~~~\n\n\n\n**Monitor重量级锁**![image-20230730151902018](八股文-多线程篇/image-20230730151902018.png)\n\n~~~\n当一个线程进入 synchronized 代码块中，会让对象锁和 Monitor 进行关联，检查一下 Monitor 中的 Owner 是否为 null ，如果为 null，则让当前线程持有，如果不为 null 则让线程去 EntryList 中进行等待，也就是阻塞，最后如果线程执行了 wait() 方法，则会进入 WaitSet 中\n~~~\n\n### 谈谈JMM（Java内存模型）\n**Java内存模型** ![image-20230730195405751](八股文-多线程篇/image-20230730195405751.png)\n\n~~~\nJMM（Java Memory Model）Java内存模型，定义了 共享内存 中 多线程程序读写操作 的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性\nJMM 把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）\n线程跟线程之间是相互隔离，线程跟线程交互需要通过主线程\n~~~\n### 乐观锁和悲观锁\n~~~\nCAS 是基于乐观锁的思想：\n\t最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点在重试呗\nSynchronized 是基于悲观锁的思想：\n\t最悲观的估计，得防着其他线程来修改共享变量，我上锁了你们都别想改，我改完了解开锁，你们才有机会。\n~~~\n### CAS 你知道嘛？\n~~~\nCAS全程是：\n\tCompare And Swap （比较在交换）；它体现的是一种乐观锁的思想，在无所状态下保证线程操作数据的原子性\n\tCas 使用到的地方很多： AQS框架 AtomicXxx类\n\t在操作共享变量的时候使用的自旋锁，效率上更高一些\n\tCAS 的底层是调用的 Unsafe 类中的方法，都是操作系统提供的，其他语言实现的\n~~~\n### 请谈谈你对 volatile 的理解\n\n![image-20230731112245241](八股文-多线程篇/image-20230731112245241.png)\n\n![image-20230731112001825](八股文-多线程篇/image-20230731112001825.png)\n\n~~~\n一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后\n\n1.保证线程间的可见性\n\t用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见\n\t\n\t\n\t有可能线程读到的变量没有共享到，是因为   JVM   虚拟机中有一个  JIT（即时编译器）给代码做了优化\n\t解决方案一：\t\n\t\t在程序运行的时候加入 vm 参数 -Xint 表示禁用即时编译器，不推荐\n\t解决方案二：\n\t\t在修饰  计划共享变量的时候  加上  volatile  ，告诉 jit，不要对 volatile修饰的变量做优化\n\t\n2.禁止进行指令重排序\n\t 指令重排：\n\t \t用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。\n~~~\n### 什么是 AQS\n~~~\n全程是 Abstract Queued Synchronized ，即抽象队列同步器。它是构建锁或者其他同步组件的基础框架"},{"title":"八股文-集合篇","slug":"八股文-集合篇","url":"/posts/724f0833/","content":"\n# 集合篇\n\n**![image-20230728194105302](八股文-集合篇/image-20230728194105302.png)**\n\n\n\n**数组**\n\n~~~\n数组是一种 用连续的内存空间 存储  相同数据类型  数据的线性数据结构\n~~~\n\n### ArrayList\n\n#### ArrayList的底层的实现原理是什么\n\n~~~\nArrayList底层是用动态数组实现的\nArrayList初始容量是0，当第一次添加元素的时候才会初始化容量为10\nArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组（a >> 1）就是除2操作\nArrayList在添加数据的时候\n\t确保数组已使用长度加1之后足够存下 下一个数据\n\t计算数组的容量，如果当前数组已使用长度加1后的大于当前数组长度，则调用grow方法扩容（原来的1.5倍）\n\t确保新增的数据有地方存储后，则将新元素添加到位于size的位置上\n\t返回添加成功布尔值\n~~~\n\n### Array List和LinkedList的区别是什么\n\n- 底层数据结构\n\t~~~\n\tArrayList是基于动态数组的数据结构\n\tLinkedList是基于双向链表的数据结构\n\t~~~\n\n- 效率\n\n- 空间\n\n- 线程是否安全\n\n  ~~~\n  ArrayList和LinkedList都不是线程安全的\n    \t如果要保证线程安全，有两种方案：\n    \t\t在方法内部使用，也就是说局部变量，局部变量是线程安全的\n    \t\t使用线程安全的ArrayList和LinkedList\n    \t\tCollections.synchronizedList(new ArrayList<>());\n    \t\tCollections.synchronizedList(new LinkedList<>());\n  ~~~\n\n### HashMap\n#### **散列表**\n\t在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表\n#### **HashMap实现原理**\n\n![image-20230729111016097](八股文-集合篇/image-20230729111016097.png)\n\n**HashMap的put流程**\n\n![image-20230729115750891](八股文-集合篇/image-20230729115750891.png)\n\n~~~ == \n1.判断键值对数组table是否为空或者为null，不是空的话执行resize()进行扩容（初始化）\n2.根据键值key计算hash值得到数组索引\n3.判断table[i] == null条件成立，直接新建节点添加\n4.如果table[i] == null不成立\n\t4.1判断table[i]的首个元素是否和key一样，如果相同直接覆盖value\n\t4.2判断table[i]是否为红黑树，如果是红黑树，则直接在树上插入键值对\n\t4.3遍历table[i]链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转化为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value\n5.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshol（数组长度*0.75）如果超过，进行扩容\n~~~\n\n"},{"title":"八股文-Redis篇","slug":"八股文-Redis篇","url":"/posts/5d16a534/","content":"\n# Redis 篇\n\n![image-20230721115118730](八股文-Redis篇/image-20230721115118730.png)\n\n![image-20230721120007468](八股文-Redis篇/image-20230721120007468.png)\n\n\n\n\n\n\n\n\n\n## 缓存问题\n\n### 缓存穿透\n\n![image-20230721115131432](八股文-Redis篇/image-20230721115131432.png)\n\n#### 方案一：缓存空数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n![image-20230721114538562](八股文-Redis篇/image-20230721114538562.png)\n\n#### 方案二：布隆过滤器\n\n![image-20230721114924136](八股文-Redis篇/image-20230721114924136.png)\n\n#### 什么是布隆过滤器\n\n![image-20230721115220031](八股文-Redis篇/image-20230721115220031.png)\n\n\n\n\n\n\n\n### 缓存击穿\n\n**![image-20230721114214034](八股文-Redis篇/image-20230721114214034.png)**![image-20230721114447532](八股文-Redis篇/image-20230721114447532.png)\n\n~~~\n其中互斥锁：强一致、性能差\n逻辑过期：  高可用、性能优\n~~~\n\n\n\n\n\n\n\n\n\n\n\n### 缓存雪崩\n\n![image-20230721115635567](八股文-Redis篇/image-20230721115635567.png)\n\n![image-20230721115506034](八股文-Redis篇/image-20230721115506034.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 双写一致\n\n![image-20230721120215526](八股文-Redis篇/image-20230721120215526.png)\n\n![image-20230721120455765](八股文-Redis篇/image-20230721120455765.png)\n\n### 问题？是先删除缓存还是先修改数据库？\n\n#### 先删除缓存，在操作数据库有两种情况\n\n![image-20230721120928537](八股文-Redis篇/image-20230721120928537.png)\n\n![image-20230721121028252](八股文-Redis篇/image-20230721121028252.png)\n\n#### 先修改数据库，在删除缓存\n\n![image-20230721121132314](八股文-Redis篇/image-20230721121132314.png)\n\n\n\n![image-20230721121729727](八股文-Redis篇/image-20230721121729727.png)\n\n### 如果要保持强一致，加锁\n\n![image-20230721122141511](八股文-Redis篇/image-20230721122141511.png)\n\n### 允许延迟\n\n#### 基于MQ\n\n![image-20230721122301976](八股文-Redis篇/image-20230721122301976.png)\n\n#### 基于 Canal\n\n![image-20230721122334453](八股文-Redis篇/image-20230721122334453.png)\n\n#### e.g\n\n![image-20230721122613562](八股文-Redis篇/image-20230721122613562.png)\n\n\n\n\n\n\n\n## Redis 持久化\n\n### RDB\n\n![image-20230721152708702](八股文-Redis篇/image-20230721152708702.png)\n\n#### RDB的执行原理\n\n![image-20230721153130474](八股文-Redis篇/image-20230721153130474.png)\n\n### AOF\n\n![image-20230721153307831](八股文-Redis篇/image-20230721153307831.png)\n\n![image-20230721153342444](八股文-Redis篇/image-20230721153342444.png)\n\n![image-20230721153628006](八股文-Redis篇/image-20230721153628006.png)\n\n#### RDB和AOF的对比\n\n![image-20230721153850193](八股文-Redis篇/image-20230721153850193.png)\n\n\n\n\n\n\n\n\n\n## Redis 的数据过期策略\n\n![image-20230721154024992](八股文-Redis篇/image-20230721154024992.png)\n\n\n\n\n\n### 惰性删除\n\n![image-20230721154901642](八股文-Redis篇/image-20230721154901642.png)\n\n\n\n\n\n### 定期删除\n\n![image-20230721155134720](八股文-Redis篇/image-20230721155134720.png)\n\n\n\n\n\n\n\n### e.g\n\n![image-20230721155429708](八股文-Redis篇/image-20230721155429708.png)\n\n\n\n\n\n\n\n## Redis 的数据淘汰策略\n\n![image-20230721155812984](八股文-Redis篇/image-20230721155812984.png)\n\n#### e.g\n\n![image-20230721160432401](八股文-Redis篇/image-20230721160432401.png)\n\n![image-20230721160448534](八股文-Redis篇/image-20230721160448534.png)\n\n\n\n\n\n\n\n\n\n\n\n## Redis 的分布式锁\n\n![image-20230721175254947](八股文-Redis篇/image-20230721175254947.png)\n\n\n\n#### e.g\n\n![image-20230721175554263](八股文-Redis篇/image-20230721175554263.png)\n\n\n\n\n\n\n\n\n\n## Redis 集群\n\n![image-20230721175832796](八股文-Redis篇/image-20230721175832796.png)\n\n### 主从复制\n\n![image-20230721180023425](八股文-Redis篇/image-20230721180023425.png)\n\n##### 全量同步\n\n![image-20230721182042182](八股文-Redis篇/image-20230721182042182.png)  \n\n##### 增量同步\n\n![image-20230721182249354](八股文-Redis篇/image-20230721182249354.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 哨兵模式\n\n\n\n![image-20230721211412045](八股文-Redis篇/image-20230721211412045.png)\n\n##### 服务状态监控\n\n![image-20230721211929068](八股文-Redis篇/image-20230721211929068.png)\n\n##### 哨兵模式（脑裂）\n\n![image-20230721212233383](八股文-Redis篇/image-20230721212233383.png)\n\n~~~\nmaster因为网络或者其他原因暂时不能和Sentinel通信，导致从节点中产生了新的master，等网络恢复之后，会产生两个master，那么之前的master会降级为slave，（那么这个过程中客户端到老master中存入的数据就会永久丢失）\n~~~\n\n\n\n\n\n##### e.g\n\n![image-20230722102959972](八股文-Redis篇/image-20230722103032370.png)\n\n\n\n### 分片集群\n\n![image-20230722103507730](八股文-Redis篇/image-20230722103507730.png)\n\n##### 分片集群结构-数据读写（哈希槽）\n\n![image-20230722104106658](八股文-Redis篇/image-20230722104106658.png)\n\n##### e.g\n\n![image-20230722104456988](八股文-Redis篇/image-20230722104456988.png)\n\n\n\n\n\n\n\n## Redis 单线程\n\n![image-20230722104858964](八股文-Redis篇/image-20230722104858964.png)\n\n\n\n\n\n### 用户空间和内核空间\n\n![image-20230722105348983](八股文-Redis篇/image-20230722105348983.png)\n\n\n\n\n\n### 阻塞 I/O\n\n![image-20230722105633698](八股文-Redis篇/image-20230722105633698.png)\n\n\n\n\n\n\n\n### 非阻塞 I/O\n\n![image-20230722110334906](八股文-Redis篇/image-20230722110334906.png)\n\n\n\n\n\n\n\n\n\n### I/O 多路复用\n\n![image-20230722111138343](八股文-Redis篇/image-20230722111138343.png)\n\n![image-20230722111618596](八股文-Redis篇/image-20230722111618596.png)\n\n\n\n\n\n\n\n\n\n### Redis 的网络模型\n\n![image-20230722112415285](八股文-Redis篇/image-20230722112415285.png)\n\n\n\n\n\n### e.g\n\n![image-20230722112450017](八股文-Redis篇/image-20230722112450017-1690452640159-54.png)\n"},{"title":"八股文-微服务篇","slug":"八股文-微服务篇","url":"/posts/52d9fea0/","content":"\n# 微服务篇\n\n![image-20230727182142156](八股文-微服务篇/image-20230727182142156.png)\n\n## Spring Cloud\n\n![image-20230727182200600](八股文-微服务篇/image-20230727182200600.png)\n\n### Spring Cloud五大组件\n\n~~~\n服务注册：Nacos\n负载均衡：Ribbon\n远程调用：Feign\n服务熔断：Sentinel\n网关：Gateway\n~~~\n\n\n\n### 服务注册\n\n#### Nacos & Eureka\n\n![image-20230727194640479](八股文-微服务篇/image-20230727194640479.png)\n\n![image-20230727194725590](八股文-微服务篇/image-20230727194725590.png)\n\n### 负载均衡\n\n#### Ribbon负载均衡策略\n\n![image-20230727200238614](八股文-微服务篇/image-20230727200238614.png)\n\n![image-20230727200808854](八股文-微服务篇/image-20230727200808854.png)\n\n#### 自定义负载均衡策略\n\n![image-20230727200206252](八股文-微服务篇/image-20230727200206252.png)\n\n### 熔断、降级\n\n**服务降级**\n\n![image-20230727202321219](八股文-微服务篇/image-20230727202321219.png)\n\n![image-20230727201612176](八股文-微服务篇/image-20230727201612176.png)\n\n![image-20230728150340613](八股文-微服务篇/image-20230728150340613.png)\n\n### 监控\n\n#### skywalking\n\n~~~\nAPM(分布式系统的应用程序性能监控工具)，提供了完善的链路追踪能力，appache的顶级项目\n~~~\n\n![image-20230728152002437](八股文-微服务篇/image-20230728152002437.png)\n\n## 业务相关\n\n### 限流\n\n#### Nginx 漏桶算法\n\n**控制速率**\n\n![image-20230728152618493](八股文-微服务篇/image-20230728152618493.png)\n\n![image-20230728155844488](八股文-微服务篇/image-20230728155844488.png)\n\n#### 令牌桶算法\n\n### 分布式事务\n\n#### 分布式理论CAP、BASE\n\n**CAP**\n\n~~~\nConsistency(一致性)：\n\t用户访问分布式中的任意节点，得到的结果都是一样的\nAvailability(可用性)：\n\t用户访问集群中的任意健康节点，必须能得到响应，而不是超时或者拒绝\nPartition tolerance(分区容错性)：\n\tPartition：\n\t\t因为网络故障或者其他原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区\n\ttolerance：\n\t\t在集群出现分区时，整个系统也要持续对外提供服务\nCP:强一致\nAP:高可用\n~~~\n\n**BASE**\n\n~~~\nBasically Available(基本可用)：\n\t分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。\nSoft State(软状态)：\n\t在一定时间内，允许出现中间状态，比如临时的不一致状态\nEventually Consistent(最终一致性)：\n\t虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致\n~~~\n\n![image-20230728172610771](八股文-微服务篇/image-20230728172610771.png)\n\n\n\n### 分布式任务调度\n\n#### xxl-job\n\n![image-20230728175759803](八股文-微服务篇/image-20230728175759803.png)\n\n## \n"},{"title":"八股文-框架篇","slug":"八股文-框架篇","url":"/posts/90abcb0a/","content":"\n# 框架篇\n\n![image-20230724174617036](八股文-框架篇/image-20230724174617036.png)\n\n## Spring\n\n### Spring框架中的单例Bean是线程安全的吗？\n\n![image-20230724175230927](八股文-框架篇/image-20230724175230927.png)\n\n~~~\n不是线程安全的\nSpring框架中有一个 @Scope 注解，默认的值就是 singleton 单例的，因为一般在 Spring 的 bean 中都是注入无状态的对象，没有线程安全问题，如果在 bean 中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决\n~~~\n\n#### e.g\n\n![image-20230724175410989](八股文-框架篇/image-20230724175410989.png)\n\n### AOP\n\n![image-20230724175759872](八股文-框架篇/image-20230724175759872.png)\n\n![image-20230724180948505](八股文-框架篇/image-20230724180948505.png)\n\n### Spring中的事务如何实现\n\n![image-20230724180552118](八股文-框架篇/image-20230724180552118.png)\n\n### Spring中事务失效场景\n\n**异常捕获处理**\n\n![image-20230724182222137](八股文-框架篇/image-20230724182222137.png)\n\n~~~~\n原因：\n\t自己手动处理了异常try掉了，没有抛出异常\n解决：\n\t手动抛出异常\n~~~~\n\n\n\n**抛出检查异常**\n\n![image-20230724182512757](八股文-框架篇/image-20230724182512757.png)\n\n~~~~java\n原因：\n\tSpring默认只会回滚非检查异常\n解决:\n\t配置rollbackFor属性\n\t@Transaction(rollbackFor = Exception.class)\n~~~~\n\n\n\n**非public方法**\n\n![image-20230724194544508](八股文-框架篇/image-20230724194544508.png)\n\n~~~\n原因：\n\tSpring 为方法创建代理，添加事务通知，前提条件都是该方法是public的\n\t\n解决：\n\t改为public   不写默认是defult\n~~~\n\n### Spring 中 Bean 的生命周期\n\n![image-20230724203138282](八股文-框架篇/image-20230724203138282.png)\n\n![image-20230724204637165](八股文-框架篇/image-20230724204637165.png)\n\n### Spring 的循环引用\n\n![image-20230724210930952](八股文-框架篇/image-20230724210930952.png)\n\n#### 三级缓存解决循环依赖\n\n![image-20230724211242950](八股文-框架篇/image-20230724211242950.png)\n\n![image-20230724212156129](八股文-框架篇/image-20230724212156129.png)\n\n**用一级缓存和二级缓存解决**\n\n![image-20230724211516842](八股文-框架篇/image-20230724211516842.png)\n\n#### 构造方法出现循环依赖\n\n![image-20230724212300102](八股文-框架篇/image-20230724212300102.png)\n\n### Spring MVC 的执行流程\n\n#### 视图阶段(JSP)\n\n![image-20230727110216531](八股文-框架篇/image-20230727110216531.png)\n\n#### 前后端分离阶段（接口开发，异步请求）\n\n![image-20230727110548350](八股文-框架篇/image-20230727110548350.png)\n\n![image-20230727111652765](八股文-框架篇/image-20230727111652765.png)\n\n### Spring Boot 自动配置原理\n\n![image-20230727113821618](八股文-框架篇/image-20230727113821618.png)\n\n![image-20230727114228908](八股文-框架篇/image-20230727114228908.png)\n\n### 常见注解\n\n#### Spring中常见注解\n\n![image-20230727114334823](八股文-框架篇/image-20230727114334823.png)\n\n#### SpringMVC 常见注解\n\n![image-20230727114511263](八股文-框架篇/image-20230727114511263.png)\n\n#### SpringBoot 常见注解\n\n![image-20230727114649280](八股文-框架篇/image-20230727114649280.png)\n\n## Mybatis\n\n### Mybatis的执行流程\n\n![image-20230727115716199](八股文-框架篇/image-20230727115716199.png)\n\n![image-20230727115821892](八股文-框架篇/image-20230727115821892.png)\n\n### Mybatis延迟加载\n\n![image-20230727121957399](八股文-框架篇/image-20230727121957399.png)\n\n![image-20230727122106946](八股文-框架篇/image-20230727122106946.png)\n\n### Mybatis的一级缓存和二级缓存\n\n#### 一级缓存\n\n![image-20230727122434434](八股文-框架篇/image-20230727122434434.png)\n\n#### 二级缓存\n\n![image-20230727171428335](八股文-框架篇/image-20230727171428335.png)\n\n![image-20230727172538700](八股文-框架篇/image-20230727172538700.png)\n\n![image-20230727172642563](八股文-框架篇/image-20230727172642563.png)"},{"title":"八股文(MySQL篇)","slug":"八股文-MySQL篇","url":"/posts/a981c63a/","content":"\n# MySQL篇\n\n## 概览\n\n![image-20230722114559967](八股文-MySQL篇/image-20230722114559967.png)\n\n\n\n## 慢查询\n\n![image-20230722114745412](八股文-MySQL篇/image-20230722114745412.png)\n\n### MySQL自带慢日志\n\n![image-20230722115055809](八股文-MySQL篇/image-20230722115055809.png)\n\n\n\n![image-20230722120440772](八股文-MySQL篇/image-20230722120440772.png)\n\n### e.g\n\n![image-20230722120552081](八股文-MySQL篇/image-20230722120552081.png)\n\n## 索引\n\n![image-20230722145956998](八股文-MySQL篇/image-20230722145956998.png)\n\n### B 树\n\n![image-20230722150942267](八股文-MySQL篇/image-20230722150942267.png)\n\n### B+ 树\n\n![image-20230722150900582](八股文-MySQL篇/image-20230722150900582.png)\n\n~~~\nB+ 树非叶子节点都是指针，只有叶子节点才是数据（并且叶子节点之间连接的是双向链表），所以读写速度更快，便于扫库和区间查询，\nMySQL 默认引擎 InnoDB 用的数据结构就是 B+ 树\n~~~\n\n### e.g\n\n![image-20230722151337492](八股文-MySQL篇/image-20230722151337492.png)\n\n## 聚簇索引，非聚簇索引（聚集索引,二级索引）\n\n![image-20230722151744402](八股文-MySQL篇/image-20230722151744402.png)\n\n### 什么是聚簇索引和非聚簇索引\n\n![image-20230722152022622](八股文-MySQL篇/image-20230722152022622.png)\n\n### 回表查询\n\n![image-20230722152441013](八股文-MySQL篇/image-20230722152441013.png)\n\n~~~\n回表查询也就是说，先根据二级索引查询到要查询的主键值，然后根据聚集索引查询（因为聚集索引的叶子节点有全部的数据）数据\n~~~\n\n### e.g\n\n![image-20230722152926369](八股文-MySQL篇/image-20230722152926369.png)\n\n### 覆盖索引\n\n![image-20230722154259439](八股文-MySQL篇/image-20230722154259439.png)\n\n\n\n### MySQL 超大分页处理\n\n![image-20230722160021105](八股文-MySQL篇/image-20230722160021105.png)\n\n### 补充  （为什么实际开发不用 select * from ……）\n\n~~~\n覆盖索引是指，查询使用了索引，返回的列，必须在索引中全部能够找到\n但是  select * from 的话必然  要进行回表查询  所以查询效率比较低\n~~~\n\n### e.g\n\n![image-20230722160318754](八股文-MySQL篇/image-20230722160318754.png)\n\n## 索引失效问题\n\n### 1.**违反了最左前缀法则** \n\n~~~\n最左前缀法则：\n\t指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则。\n~~~\n\n![image-20230723121537774](八股文-MySQL篇/image-20230723121537774.png)\n\n### 2.范围查询右边的列，不能使用索引\n\n![image-20230723143012977](八股文-MySQL篇/image-20230723143012977.png)\n### 3.不要在索引列上进行运算操作，索引将失效\n\n![image-20230723143246259](八股文-MySQL篇/image-20230723143246259.png)\n\n### 4.字符串不加单引号，造成索引失效（类型转换）\n\n![image-20230723143732614](八股文-MySQL篇/image-20230723143732614.png)\n### 5.模糊查询有可能导致索引失效（以 % 开头的模糊查询）\n\n![image-20230723143953083](八股文-MySQL篇/image-20230723143953083.png)\n\n### e.g\n\n![image-20230723144137791](八股文-MySQL篇/image-20230723144137791.png)\n## SQL的优化\n~~~\n表的设计优化\n索引优化\nSQL语句优化\n主从复制，读写分离\n分库分表\n~~~\n### 表的设计优化（参考《阿里巴巴开发手册》（嵩山版））\n~~~\n比如设置合适的数值（tinyint int bigint）要根据实际情况选择\n比如设置合适的字符串类型（char和varChar）char定长效率高，varChar可变长度，效率稍低\n~~~\n\n### SQL语句优化\n~~~\nselect语句务必指明字段名称（避免直接使用select *）\nSQL语句要避免造成索引失效的写法\n尽量用union all 代替union union会多一次过滤，效率低\n避免在where子句中对字段进行表达式操作\nJoin优化能用innerjoin就不用left join  right join 如必须使用一定要小表为驱动\n内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边，left join或right join，不会重新调整顺序\n~~~\n\n### 主从复制、读写分离\n\n![image-20230723154445552](八股文-MySQL篇/image-20230723154445552.png)\n\n~~~\n\t如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离的架构，读写分离解决的是，数据库的写入，影响了查询的效率\n~~~\n\n### e.g\n\n![image-20230723154852733](八股文-MySQL篇/image-20230723154852733.png)\n\n## 事务（ACID）\n\n~~~\n事务：\n\t事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n~~~\n\n### ACID\n\n~~~\n原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。\n一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\n隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\n持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n~~~\n\n### 并发事务问题\n\n~~~\n脏读：一个事务读到另一个事务还没有提交的数据。\n不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。\n幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”\n~~~\n\n#### 脏读\n\n![image-20230723163939303](八股文-MySQL篇/image-20230723163939303.png)\n\n~~~\n事务B  读（select）到了事务A还没提交的数据\n~~~\n\n#### 不可重复读\n\n![image-20230723164102215](八股文-MySQL篇/image-20230723164102215.png)\n\n~~~\n事务A  第一次读（select）到一条数据\n事务B 紧接着修改（update）了这条数据并且commit了数据\n事务A又一次读到了这条数据\n但是事务A 两次查询数据不一样叫做不可重复读\n~~~\n\n#### 幻读\n\n![image-20230723164511393](八股文-MySQL篇/image-20230723164511393.png)\n\n~~~\n事务A 首先查询id为1的数据发现数据库中没有该条数据\n事务B 插入一条数据id为1   并且提交到数据库中’\n事务A 插入一条数据id为1   但是报错   说数据库中已经有id为1的数据\n事务A 又一次查询id为1的数据 但是还是没有查到   \n（疑问？    不可重复读中，不是可以查询到事务B中提交的数据么）在幻读中我们的前提就是已经解决了不可重复读的问题\n~~~\n\n### 解决并发事务问题\n\n![image-20230723165007068](八股文-MySQL篇/image-20230723165007068.png)\n\n~~~\n未提交读：什么也解决不了（不用）\n读已提交：解决了脏读\n可重复读：解决了脏读和不可重复读（MySQL默认隔离级别）\n串行化：解决了所有问题，安全级别最高，但是效率最低（不推荐使用）只有一条事务提交，另外的事务才可以进行操作\n~~~\n\n\n\n#### e.g\n\n![image-20230723165737796](八股文-MySQL篇/image-20230723165737796.png)\n\n### 事务的隔离性是如何保证的\n\n~~~\n锁：排他锁（如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁）\nmvcc: 多版本并发控制\n~~~\n\n### MVCC\n\n\n\n\n\n"},{"title":"微服务实战","slug":"微服务实战","url":"/posts/a219ce80/","content":"\n# 实战内容\n\n## 1.搭建环境\n\n~~~~xml-dtd\n搭建环境\n1.没什么好说的，导入 SQL\n2.导入项目\n3.nginx 发布前端页面\n\t需要注意的是在 nginx.conf 配置（如下图）\n\t在http{\n\t\tserver{\n\t\t// 这里写\n\t\t}\n\t}\n\t\n\t中配置server{\n\t\tlisten  端口号;\n\t\tserver_name  localhost;\n\t\t\n\t\tlocation /{\n\t\t   root   前端项目路径;\n\t\t}\n\t}\n4.配置 nacos\n\t首先引入依赖\n<!--nacos服务注册发现依赖-->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n\n\t然后在 application.yml 中配置 nacos 的相关配置\n\n\tspring:\n  \t\tapplication:\n    \t\tname: 服务名称\n\t\tcloud:\n    \t\tnacos:\n      \t\tdiscovery:\n        \tserver-addr: localhost:8848 # nacos地址\n5.配置网关服务\n\t新建 gateway 网关模块并引入依赖（同时注册进 nacos 方便拉取2服务）\n\t\t<!-- Spring Cloud Gateway -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n        <!-- Nacos 服务注册与发现 -->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n\t并在 application.yml 中写入 gateway 相关配置\n\nserver:\n  port: 10010\nspring:\n  application:\n    name: gateway\n  cloud:\n    gateway:\n      default-filters:\n        - AddRequestHeader=authorization,2  #往请求中加请求头\n      routes:\n        - id: userservice\n          uri: lb://userservice # 路由的地址，lb，负载均衡\n          predicates:\n            - Path=/user/**,/address/**\n\n      globalcors: # 全局的跨域处理\n        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n\n        corsConfigurations:\n          '[/**]':\n            allowedOrigins: # 允许哪些网站的跨域请求\n              - \"http://localhost:9001\"\n              - \"http://localhost:9002\"\n            allowedMethods: # 允许的跨域ajax的请求方式\n              - \"GET\"\n              - \"POST\"\n              - \"DELETE\"\n              - \"PUT\"\n              - \"OPTIONS\"\n            allowedHeaders: \"*\" # 允许在请求中携带的头信息\n            allowCredentials: true # 是否允许携带cookie\n            maxAge: 360000 # 这次跨域检测的有效期\n~~~~\n\n![image-20230710083244286](微服务实战/image-20230710083244286.png)\n\n![image-20230710083425232](微服务实战/image-20230710083425232.png)\n\n### 1.1 Feign 的远程调用\n\n~~~~~~\n1.创建 Feign 模块\n2.引入 Feign 的依赖\n\t<dependency>\n\t    <groupId>org.springframework.cloud</groupId>\n\t    <artifactId>spring-cloud-starter-openfeign</artifactId>\n\t</dependency>\n3.声明服务的接口 XxxFeignClient\n\t将服务暴露的接口写入其中 路径名、方法名、请求类型、参数类型都要相同\n4.在需要远程调用其他接口的服务中引入 Feign 的依赖\n\t自动注入 XxxFeignClient 然后调用方法\n~~~~~~\n\n![image-20230710092437011](微服务实战/image-20230710092437011.png)\n\n![image-20230710092518955](微服务实战/image-20230710092518955.png)\n\n### 1.2 网关 Gateway 配置\n\n~~~xml-dtd\n1.创建Gateway模块\n2.导入依赖\n\t<!-- Spring Cloud Gateway -->\n\t<dependency>\n\t    <groupId>org.springframework.cloud</groupId>\n\t    <artifactId>spring-cloud-starter-gateway</artifactId>\n\t</dependency>\n\t<!-- Nacos 服务注册与发现 -->\n\t<dependency>\n\t    <groupId>com.alibaba.cloud</groupId>\n\t    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n\t</dependency>\n\n\n3.配置 application.yml \n\tserver:\n\t  port: 10010\n\tspring:\n\t  application:\n\t    name: gateway\n\t  cloud:\n\t    gateway:\n\t      default-filters:\n\t        - AddRequestHeader=authorization,2\n\t      routes:\n\t        - id: userservice\n\t          uri: lb://userservice # 路由的地址，lb，负载均衡\n\t          predicates:\n\t            - Path=/user/**,/address/**\n\t        - id: orderservice\n\t          uri: lb://orderservice\n\t          predicates:\n\t            - Path=/order/**,/pay/**\n\t        - id: itemservice\n\t          uri: lb://itemservice\n\t          predicates:\n\t            - Path=/item/**\n\t        - id: searchservice\n\t          uri: lb://searchservice\n\t          predicates:\n\t            - Path=/search/**\n\t\n\t      globalcors: # 全局的跨域处理\n\t        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n\t\n\t        corsConfigurations:\n\t          '[/**]':\n\t            allowedOrigins: # 允许哪些网站的跨域请求\n\t              - \"http://localhost:9001\"\n\t              - \"http://localhost:9002\"\n\t            allowedMethods: # 允许的跨域ajax的请求方式\n\t              - \"GET\"\n\t              - \"POST\"\n\t              - \"DELETE\"\n\t              - \"PUT\"\n\t              - \"OPTIONS\"\n\t            allowedHeaders: \"*\" # 允许在请求中携带的头信息\n\t            allowCredentials: true # 是否允许携带cookie\n\t            maxAge: 360000 # 这次跨域检测的有效期\n\t\n~~~\n\n### 1.3 配置 ES 客户端\n\n~~~\n1.引入依赖\n\n<!--elasticsearch-->\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-high-level-client</artifactId>\n</dependency>\n2.编写配置类\n\n@Configuration\npublic class ElasticsearchConfig {\n\n    @Bean\n    public RestHighLevelClient restHighLevelClient() {\n        return new RestHighLevelClient(RestClient.builder(\n                HttpHost.create(\"http://192.168.150.105:9200\")\n        ));\n    }\n}\n\n然后在其他地方\n@Autowired\nprivate RestHighLevelClient restHighLevelClient;\n注入\n~~~\n\n### 1.4 配置RabbitMQ\n\n~~~\n1. 引入依赖\n<!--amqp-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\n2.编写MQ的监听（将交换机和队列进行绑定，基于注解方式）\n\n@Component\npublic class ItemLinstter {\n\n    @Autowired\n    private SearchService searchService;\n\n    @RabbitListener(bindings = @QueueBinding(\n            exchange = @Exchange(name = MqConstants.HMALL_EXCHANGE, type = ExchangeTypes.TOPIC),\n            value = @Queue(name = MqConstants.HMALL_INSERT_QUEUE),\n            key = {MqConstants.HMALL_INSERT_KEY}\n    ))\n    public void linsterIemUp(Long id) {\n        searchService.saveItemById(id);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = MqConstants.HMALL_DELETTE_QUEUE),\n            exchange = @Exchange(name = MqConstants.HMALL_EXCHANGE, type = ExchangeTypes.TOPIC),\n            key = {MqConstants.HMALL_DELETE_KEY}\n    ))\n    public void linsterIemDown(Long id) {\n        searchService.deleteItemById(id);\n    }\n\n}\n~~~\n\n\n\n\n\n## 2.商品管理服务\n\n~~~\n今天没什么好写的，因为用了 MP 框架\n对于单表的增删改查很容易\n要注意\n在 XxxMapper 的接口上要 extends BaseMapper<实体类名>\n（数据库的实体类映射）\n在 XxxService 的接口上是 extends IService<实体类名>\n在 XxxServiceImpl 的实现类上是 extends ServiceImpl<XxxMapper,实体类> 并且同时 implements XxxService\n~~~\n\n![image-20230710084856174](微服务实战/image-20230710084856174.png)\n\n![image-20230710084913048](微服务实战/image-20230710084913048.png)\n\n![image-20230710084925142](微服务实战/image-20230710084925142.png)\n\n## 3.搜索业务\n\n~~~\n上强度开始\n1.创建索引库\n\t首先根据数据库表结构设计出 ES 的索引表结构\n\t\t其中设计了后边要用的关键字搜索 \n\t\t设计了 all 字段，参与搜索\n\t\t\"all\": {\n        \t\"type\": \"text\",\n        \t\"analyzer\": \"text_analyzer\",\n        \t\"search_analyzer\": \"ik_smart\"\n     \t }\n    \t在其他字段下 写  ”copy_to“: \"all\"\n    \t使其他字段在查询的时候参与查询\n    同时还设置了 py 分词器，以便在搜索框搜索的时候可以使用拼音搜索\n    \n2.导入数据\n\t大体思路就是\n\t\t2.1将其他服务写好的查询数据库的全部数据的接口暴露给 Feign\n\t\t2.2然后在需要导入数据的服务中引入 Feign 的依赖\n\t\t2.3调用 Feign 的接口\t（Feign如何操作见1.1模块）\n\t\t2.4通过 RestHighLevelClient 给 ES 发送请求 （配置见1.3）\n3.关键字搜索\n\t// 1.创建请求对象\n    SearchRequest request = new SearchRequest(\"hmall\");\n    // 2.多个条件判断\n    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n    // key健壮性判断\n    if (StringUtils.isNotEmpty(params.getKey())) {\n        boolQuery.must(QueryBuilders.matchQuery(\"all\", params.getKey()));\n    } else {\n        boolQuery.must(QueryBuilders.matchAllQuery());\n    }\n   \t……\n   \t// 其他条件的判断\n   \t……\n   \t// 3.发送请求\n   \tSearchResponse response = client.search(request, RequestOptions.DEFAULT);\n   \t// 4.解析数据\n   \t…… 固定套路（剥洋葱）……\n\n4.过滤查询\n\t聚合操作通常包括以下几个步骤：\n\t\t1.创建一个 SearchRequest 对象，指定要执行聚合的索引和类型。\n\t\t2.构建查询条件（如果需要），可以使用 QueryBuilders 类提供的方法创建各种类型的查询条件。\n\t\t3.创建一个 AggregationBuilder 对象，指定要执行的聚合类型和聚合字段。\n\t\t4.将聚合对象添加到 SearchRequest 对象中的 AggregationBuilder 列表中。\n\t\t5.执行搜索请求，将 SearchRequest 对象传递给 Elasticsearch 客户端的 search 方法。\n\t\t6.从 SearchResponse 对象中提取聚合结果。\n5.销量和价格排序\n\t// 排序\n    String sortBy = params.getSortBy();\n    if (\"sold\".equals(sortBy)){\n        request.source().sort(sortBy, SortOrder.DESC);\n    }else if (\"price\".equals(sortBy)){\n        request.source().sort(sortBy, SortOrder.ASC);\n    }\n    // 发送请求\n    client.search(request, RequestOptions.DEFAULT);\n~~~\n\n![image-20230710085209091](微服务实战/image-20230710085209091.png)\n\n![image-20230710085236250](微服务实战/image-20230710085236250.png)\n\n![image-20230710090109319](微服务实战/image-20230710090109319.png)\n\n### 3.1数据同步\n\n~~~\n基于 RabbitMQ 实现数据库 elasticsearch 的数据同步，要求如下：\nES配置见1.3\nRabbitMQ配置见1.4\n- 商品上架时：search-service新增商品到elasticsearch\n- 商品下架时：search-service删除elasticsearch中的商品\n~~~\n\n![image-20230710120135885](微服务实战/image-20230710120135885.png)\n\n\n\n## 4.登录信息获取\n\n~~~java\n1.网关配置(见1.2)\n2.在 application.yml 中添加如下配置\n\tspring:\n\t  cloud:\n\t    gateway:\n\t      default-filters:\n\t        - AddRequestHeader=authorization,2\n3.在服务中编写拦截器\n\n/*\n* 拦截器类，在WebMvc中添加了拦截规则之后，前置拦截请求，添加请求头\n* */\n@Component\npublic class AuthorizationInterceptor implements HandlerInterceptor  {\n    /*\n    * 前置拦截\n    *\n    * */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // String authorizationHeader = request.getHeader(\"authorization\");\n        // 在这里使用authorization头进行相应的处理\n        String userID = request.getHeader(\"authorization\");\n        MyThreadLocal.setUserId(userID);\n        return true;\n    }\n}\n\n4.编写拦截器配置类并将拦截器注册到容器中\n/*\n* 需要将拦截器注册到MVC中\n* */\n@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n    @Autowired\n    private AuthorizationInterceptor authorizationInterceptor;\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(authorizationInterceptor).addPathPatterns(\"/**\");\n    }\n}\n~~~\n\n### 4.1 Feign 的请求头\n\n![image-20230710121258644](微服务实战/image-20230710121258644.png)\n\n![image-20230710121318486](微服务实战/image-20230710121318486.png)\n\n~~~\n这两段代码是用于配置和添加自定义的 Feign 拦截器。\n\n首先，FeignInterceptor 是一个实现了 RequestInterceptor 接口的拦截器类。在 apply 方法中，我们可以对请求进行一些自定义操作，比如添加请求头信息。通过调用 template.header(\"authorization\",\"2\") 方法，向请求添加了一个名为 \"authorization\" 的请求头，值为\"2\"。\n\n接下来，FeignConfig 是一个配置类，用于配置 Feign 客户端的一些参数和属性。通过使用 @EnableFeignClients 注解指定了 Feign 客户端的基础包路径，告诉 Spring Boot 在哪些包下寻找 Feign 客户端接口进行代理。\n\n在 FeignConfig 中，通过使用 @Bean 注解来声明一个名为 feignInterceptor 的 Bean ，该 Bean 是 FeignInterceptor 类型的实例。这样，SpringBoot 会自动将该拦截器添加到 Feign 的拦截器链中，使其生效。\n\n通过这样的配置和自定义拦截器，我们可以在Feign客户端发送请求前进行一些预处理操作，比如添加认证信息、日志记录等。\n~~~\n\n\n\n## 5.用户服务\n\n~~~\n略~~~\n~~~\n\n\n\n## 6.订单服务\n\n~~~\n创建订单业务比较复杂，流程如下：\n\n- 1）根据雪花算法生成订单 id\n\t因为导入了 MP 所以有\n\t    @TableId(type = IdType.ASSIGN_ID)\n\t或者网上搜一个雪花算法的工具类掉方法\n\t\n- 2）商品微服务提供 FeignClient ，实现根据 id 查询商品的接口\n\t将 ItemService 中的根据 id 获取对象的接口暴露给 Feign 通过(1.1 Feign 的远程调用实现)\n\t\n- 3）根据 itemId 查询商品信息\n\t// 1.根据 id 查询出商品信息\n    Item item = itemFeignClient.selectById(params.getItemId());\n    \n- 4）基于商品价格、购买数量计算商品总价：totalFee\n\n- 5）封装 Order 对象，初识 status 为未支付\n\tOrder.setXxx();\n\t\n- 6）将 Order 写入数据库 tb_order 表中\n\tsave(order);\n\t\n- 7）将商品信息、orderId 信息封装为 OrderDetail 对象，写入 tb_order_detail 表\n\torderDetail.setXxx();\n\tsave(orderDetail);\n\t\n- 8）将 user-service 的根据id查询地址接口封装为 FeignClient\n\t通过(1.1 Feign 的远程调用实现)\n\t\n- 9）根据 addressId 查询 user-service 服务，获取地址信息\n\t同上……\n- 10）将地址封装为 OrderLogistics 对象，写入 tb_order_logistics 表\n\t同上……\n- 11）在 item-service 提供减库存接口，并编写 FeignClient\n\t同上……\n- 12）调用 item-service 的减库存接口\n\t同上……\n~~~\n\n### 6.1 清理超时未支付订单\n\n~~~java\n1.原计划用延迟队列，但是突发奇想，想看看 SpringTask 可不可以实现，以下是对 SpringTask 的尝试\n\n2.创建 SpringTask 的模块\n\n3.引入 SpringTask 的起步依赖\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n</dependencies>\n\n4.启动类上添加@EnableScheduling\n@EnableScheduling：启动定时任务，放在启动类的上面\n\n@EnableScheduling\n@EnableFeignClients(clients = {OrderFeignClient.class})\n@SpringBootApplication\npublic class TaskSpringBootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(TaskSpringBootApplication.class, args);\n    }\n}\n\n\n5.编写业务代码(欠缺考虑增加库存数量)\n\n@Component\npublic class MyScheduledTask {\n    @Autowired\n    private OrderFeignClient orderFeignClient;\n    // 优化性能 用计数器来 控制\n    private int counter = 0;\n\n    @Scheduled(fixedRate = 10000)\n    public void task(){\n        if (counter < 5) {\n            counter++;\n            return;\n        }\n\n        List<Order> orderList = orderFeignClient.getOrderList();\n        Date currentTime = new Date();\n\n        for (Order order : orderList) {\n            Date createTime = order.getCreateTime();\n            Calendar calendar = Calendar.getInstance();\n            calendar.setTime(createTime);\n            calendar.add(Calendar.MINUTE, 30);\n            Date targetTime = calendar.getTime();\n\n            boolean isPast30Minutes = currentTime.after(targetTime);\n\n            if (isPast30Minutes) {\n                // 执行支付状态更改逻辑\n                orderFeignClient.updateOrder(order.getId());\n            }\n        }\n\n        counter = 0; // 重置计数器\n    }\n}\n~~~\n\n## 7.贴心小贴士\n\n([Shared Chat (zhile.io)](https://chat-shared2.zhile.io/shared.html?v=2) \"好东西\")。\n\n","tags":["微服务实战"]},{"title":"AOP笔记","slug":"AOP笔记记录","url":"/posts/fd57f765/","content":"\n# 事务管理&AOP笔记\n\n## Spring事务管理（@Transactional）\n\n~~~\n注解：\n\t@Transactional\n位置：\n\t业务(Service)层的方法上、类上、接口上\n作用：\n\t将当前方法交给Spring进行事务管理、方法执行前、开启事务;\n\t成功执行完毕，提交事务：\n\t出现异常，回滚事务；\n\t\n开启Spring事务管理日志：\nlogging:\n  level:\n    org.springframework.jdbc.support.JdbcTransactionManager: debug\n\n~~~\n\n### 事务属性-回滚（rollbackFor）\n\n~~~\n默认情况下：\n\t只有出现RuntimeException才回滚异常\n\t\n\trollbackFor属性用于控制出现何种异常类型，回滚事务\n\t\n@Transactional(rollbackFor = Exception.class)\n~~~\n\n### 事务属性-传播（propagation）\n\n~~~\n事务传播行为：\n\t值的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制\n\t\t加入：\n\t\t\t@Transactional(propagation = Propagation.REQUIRED)  默认值需要事务，有则加入，无则创建新事务\n\t\t新建：\n\t\t\t@Transactional(propagation = Propagation.REQUIRES_NEW)  需要新事务，不管有没有，总是创建新事物\n~~~\n\n## AOP\n\n### AOP概述\n\n~~~\nAOP：\n\tAspect Oriented Progaramming(面向切面编程)  ，就是面向特定方法进行编程\n~~~\n\n### AOP快速入门\n\n#### 1.在pom.xml中导入依赖\n\n~~~xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n~~~\n\n#### 2.编写AOP程序：针对于特定方法根据业务需要进行编程\n\n### AOP使用场景及优势\n\n~~~\n场景：\n\t记录操作日志\n\t权限控制\n\t事务管理\n\n优势：\n\t代码无侵入\n\t减少重复代码\n\t提高开发效率\n\t维护方便\n~~~\n\n### AOP核心概念！！！\n\n~~~\n连接点：\n\tJoinPoint，可以被AOP控制的方法\n通知：\n\tAdvice，指哪些重复的逻辑，也就是共性的功能\n切入点：\n\tPointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用\n切面：\n\tAspect，通知+切入点（描述通知与切入点的对应关系）\n目标对象：\n\tTarget，通知所应用的对象\n~~~\n\n### 通知类型\n\n~~~\n@Around:\n\t环绕通知，此注解标注的通知方法在目标方法前，后都被执行（方法的前后）\n\t\n@Around的注意事项：\n\t@Around环绕通知需要自己调用ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法执行\n\t@Around环绕通知方法的返回值，必须指定为object，来接受原始方法的返回值\n\t\n\t\n@Before(前置通知)\n@After(后置通知)\n@Around(环绕通知！！！重点)\n@AfterReturning(返回后通知，了解)\n@AfterThrowing(异常后通知，了解)\n~~~\n\n### 切入点表达式\n\n~~~\n切入点表达式：\n\t描述切入点方法的一种表达式\n作用：\n\t主要用来决定项目中的那些方法需要加入通知\n常见形式：\n\texecution(...):根据方法的签名来匹配\n\t@annotation(...):根据注解匹配\n~~~\n\n\n\n### @PointCut\n\n~~~java\n该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可\n@PointCut(\"execution(* com.itheima.service.impl.Xxximpl.*(..))\")\npublic void pt(){}\n\n@Around(\"pt()\")\npublic Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable{\n    \n}\n~~~\n\n","tags":["记录、笔记"]},{"title":"SpringBoot注解总结","slug":"SpringBoot注解总结","url":"/posts/2d62ae04/","content":"\n# 注解总结\n\n## 1. 把对象放到Spring容器中\n\n~~~\n@Component\n@Controller\n@Service\n@Repository\n@Bean：管理第三方bean，把当前方法返回值放到Spring容器中\n@Scope：设置bean作用范围\n~~~\n\n## 2. 依赖注入\n\n~~~\n@Autowired 按类型装配\n\n@Qualifier 按名称装配，必须和@Autowired配合使用\n\n@Resource 按名称装配，如果按名称找不到就按类型\n~~~\n\n## 3. 配置类注解\n\n~~~\n@Configuration：表明此类是一个配置类，Spring的注解\n@Import：把配置类或bean导入Spring容器中，\n@Value：读取配置文件中的单个值\n@ConfigurationProperties(prefix=\"\")  读取配置文件中的值到实体类中 批量读取属性\n@SpringBootApplication：Springboot核心注解\n@SpringBootConfiguration：表明此类是一个SpringBoot配置类，SpringBoot的注解\n@ComponentScan：配置路径扫描\n@EnableAutoConfiguration：自动配置\n~~~\n\n## 4. 请求与响应\n\n~~~\n@RestController = @Controller + @ResponseBody\n@RequestMapping ：请求路径\n@PostMapping：请求方式为post，并设置请求路径，用于新增操作\n@PutMapping：请求方式为put，并设置请求路径，用于修改操作\n@DeleteMapping：请求方式为delete，并设置请求路径，用于删除操作\n@GetMapping：请求方式为get，并设置请求路径，用于查询操作\n@RequestParams：请求参数和形参不一致时使用\n@RequestBody：接收json传参\n@ResponseBody：把当前方法返回值放到响应体中，如果返回值是实体类，则自动转换为json类型数据\n@DateTimeFormat：接收日期类型传参\n~~~\n\n\n\n## 5. 过滤器、全局异常处理器\n\n```\n过滤器\n\t@WebFilter(urlPatterns=\"\")：配置过滤器过滤的路径\n\t@ServletComponentScan：开启Servlet组件扫描\n```\n\n```\n全局异常处理器\n\t@RestControllerAdvice：放在类上，标明此类是一个异常处理器类\n\t@ExceptionHandler(Exception.class)：放在方法上，指定当前方法捕获哪一类异常\n```\n\n## 6. AOP及事务\n\n```\nAOP\n\t@Aspect：代表当前类是aop类\n\t@PointCut：切点表达式注解\n```\n\n```\n通知\n\t前置通知：@Before\n\t后置通知：@After\n\t环绕通知：@Around\n\t返回后通知：@AfterReturning\n\t异常后通知：@AfterThrowing\n```\n\n```\n事务\n\t@Transational：事务注解\n```\n\n## 7. Mybatis及MybatisPlus\n\n```\n@Insert\n@Delete\n@Update\n@Select\n\n@TableId：设置主键生成策略\n@TableLogic：逻辑删除\n@Version：版本号\n\n@TableName：设置数据库表名字\n@TableField(value=\"\",select=\"\",exist=\"\") \n\tvalue：设置表字段和实体类字段映射\n\tselect：设置不查询表中某字段\n\texist：设置实体类中字段在表中不存在\n```\n\n","tags":["注解"]},{"title":"Redis数据库","slug":"Redis数据库","url":"/posts/eb52a7b2/","content":"\n\n\n\n\n## Redis常用指令\n\n![](Redis数据库/qwe.png)\n\n### 字符串操作命令\n\n~~~\nSET key value  \t\t\t\t设置指定key的值\nGET key \t   \t\t\t\t获取指定key的值\nSETEX key seconds value\t\t设置指定key的值，并将key的过期时间设置为seconds秒\nSETNX key value\t\t\t\t只有在key不存在时，设置keyd\n~~~\n\n### 哈希操作命令\n\n~~~\nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象，常用命令\n\nHSET key field value \t将哈希表key中的字段field的值设为value\nHGET key field \t\t\t获取存储在哈希表中指定字段的值\nHDEL key field \t\t\t删除存储在哈希表中的指定字段\nHKEYS key \t   \t\t\t获取哈希表中所有字段\nHVALS key \t   \t\t\t获取哈希表中所有值\n~~~\n\n### 列表操作命令\n\n~~~\nRedis列表是简单的字符串列表，按照插入顺序排序，常用命令\n\nLPUSH key value1 [value2]  将一个或多个值插入到列表头部\nLRANGE key start stop \t   获取列表指定范围内的元素\nRPOP key \t\t\t\t   移除并获取列表最后一个元素\nLLEN key\t\t\t\t   获取列表长度\n~~~\n\n### 集合操作命令\n\n~~~\nRedis set是string类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据，常用命令\n\nSADD key member1 [member2]\t\t向集合添加一个或多个成员\nSMEMBERS key\t\t\t\t\t返回集合中所有的成员\nSCARD key\t\t\t\t\t\t获取集合的成员数\nSINTER key1 [key2]\t\t\t\t返回给定所有集合的交集\nSUNION key1 [key2]\t\t\t\t返回所有给定集合的并集\nSREM key member1 [member2]\t\t删除集合中一个或多个成员\n~~~\n\n### 有序集合操作命令\n\n~~~\nRedis有序集合是string类型元素的集合，且不允许有重复成员，每个元素都会关联一个double类型的分数，常用命令\n\nZADD key score1 member1 [score2 member2]\t向有序集合添加一个或多个成员\nZRANGE key start stop [WITHSCORES] \t\t\t通过索引区间返回有序集合中指定区间内的成员\nZINCRBY key increament member\t\t\t\t有序集合中对指定成员的分数加上增量increment\nZREM key member [member……]\t\t\t\t\t移除有序集合中的一个或多个成员\n~~~\n\n### 通用命令\n\n~~~\nRedis的通用命令是不分数据类型的，都可以使用的命令\n\nKEYS pattern \t\t查找所有符合给定模式(pattern)的key\nEXISTS key \t\t\t检查给定key是否存在\nTYPE key\t\t\t返回key所存储的值的类型\nDEL key \t\t\t该命令用于在key存在时删除key\n~~~\n\n","tags":["redis"]},{"title":"Spring面试题","slug":"Spring面试题","url":"/posts/489ef953/","content":"\n### 面试题1：如果别人给我了一个项目，都已经打成jar包了（没有提供源码），发现其中的一项参数不对，能不能在外部直接修改项目配置项的内容，如何实现？\n\n~~~\n当然可以\n\tjava -Dserver.port=9000 jar jar包  --server.port=9001\n~~~\n\n\n\n### 面试题2：Spring容器中的bean对象是什么时候创建的 ？[包括: 默认单例 以及 非单例]\n\n~~~\n单例作用域（Singleton）\n\t对于默认的单例作用域，Spring容器在启动时会创建并初始化所有单例的Bean对象\n\t\n非单例作用域（Prototype）\n\t对于非单例作用域，Spring容器在接收到相应的请求时，才会创建新的Bean实例\n~~~\n\n\n\n### 面试题3：简单聊聊你对SpringBoot框架的理解 / SpringBoot自动配置的原理是什么?\n\n~~~\n对于SpringBoot框架的理解：\n\tSpringBooot就是基于Spring Framework的一款开源框架，简化了项目的开发，最大特点就是有AOP以及IOC，极大程度的简化了，应用的开发，秉承着约定大于配置的原则，使程序员不用在关心各种各样的配置，而专心写业务逻辑。\n\t\n对于SpringBoot自动配置的原理：\n\t说到SpringBoot的自动配置，我想到了一个注解@EnableAutoConfiguration，这个注解底层封装了一个@import注解，通过import来导入指定的Bean或者配置类，这个注解导入了AutoConfigurationImportSelector他是ImportSelector的实现类，这个importSelector接口中有一个selectImports方法返回一个String[]数组（那些类需要导入到IOC容器当中，里边封装的就是这些类的全类名）\n\tMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports \n\tMETA-INF/spring.factories\n~~~\n\n\n\n### 面试题4：SpringBoot框架与Spring Framework的关系能详细的描述一下吗? 为什么现在项目开发都基于SpringBoot进行 ?\n\n~~~\n\tSpringBooot就是基于Spring Framework的一款开源框架，简化了项目的开发，最大特点就是有AOP以及IOC，极大程度的简化了应用的开发，秉承着约定大于配置的原则，使程序员不用在关心各种各样的配置，而专心写业务逻辑的代码。\n~~~\n\n\n\n### 面试题5：有没有在项目中自己定义过 starter，如果让你来定义starter，能描述下大概的思路吗？ \n\n~~~\n1. 确定功能和用途：确定Starter要提供的功能和用途。可以根据项目的需求或特定领域的需求来定义功能范围。\n\n2. 定义核心依赖：确定Starter的核心依赖，这些依赖将作为应用程序使用该Starter时需要引入的依赖。\n\n3. 编写自动配置：编写自动配置类，为Starter提供默认的配置和功能。在自动配置类中，可以使用条件化配置来决定是否应用配置。\n\n4. 定义配置属性：定义一组配置属性，让使用者可以通过配置文件或其他方式进行自定义。可以使用Spring Boot的配置属性注解来定义和绑定配置属性。\n~~~\n\n","tags":["面试题"]},{"title":"JavaSE阶段笔记","slug":"java笔记","url":"/posts/737a1d7/","content":"# 面向对象编程\n\n## 定义类的补充注意事项\n\n```java\njavabean类：\n\t用来描述一类事物的类，在javabean类中，是不写main方法的\n标准的javabean类：\n\t类名需要见名知意\n\t成员变量需要用private修饰\n\t提供至少两个构造方法\n\t\t无参构造\n\t\t带全部参数的构造方法\n\t成员方法\n\t\t提供每一个成员变量对应的setXxx()和getXxx()\n\t\t如果还有其他行为，也需要写上\n\n测试类：\n\t在以前编写main方法的类，我们可以在测试类中创建javabean类的对象进行赋值调用\n\n\t成员变量的完整定义格式：修饰符 数据类型 变量名称 = 初始化值，一般无需定义初始化值，存在默认值\n```\n\n\n\n## 面向对象三大特征（封装   继承    多态）\n\n### 封装\n\n```java\n告诉我们如何正确的设计对象的属性和方法\n对象代表什么，就得封装对应的数据，并提供数据对应的行为\n\t例如：\n\t\t需求：人画圆，请针对这个需求进行面向对象的设计\n```\n\n### 继承\n\n```java\njava中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系。（java只支持单继承，不支持多继承，但是支持多层继承）\n    每一个类都直接或间接的继承Object\n   \n\tpublic class Student extends Person(){}\nStudent称为子类，Person称为父类\n    \n使用继承的好处\n    可以把多个子类重复的代码抽取到父类中，提高了代码的复用性\n    子类可以在父类的基础上，增加其他的共能，是子类更强大。\n    \n什么时候用继承\n    当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码。\n```\n\n### 多态\n\n```\n什么是多态？\n\t同类型的对象，表现出的不同的形态。\n\n多态的表现形式\n\t父类类型 对象名称 = 子类对象;\n\n多态的前提\n\t有继承/实现（接口）关系\n\t有父类引用指向子类对象\n\t有方法重写\n\t\n多态的好处\n\t使用父类型作为参数，可以接收所有的子类对象，体现多态的扩展与便利 \n\t在多态形式下，右边对象可以实现解耦合，便于扩展和维护\n\t\n多态的弊端\n\t不能使用子类独有的方法\n解决方法\n\t转换成真正的子类类型，从而调用子类独有的功能\n\t转换类型与真实对象类型不一致会报错\n\t转换时用instanceof关键字进行判断\n\t\n调用成员变量的特点：\n\t编译看左边，运行也看左边\n调用成员方法的特点：\n\t编译看左边，运行看右边\n```\n\n\n\n## 关键字还有修饰符\n\n### private < 空着不写 < protected < public   \n\n```java\nprivate关键字：\n\t是一个权限修饰符\n\t可以修饰成员（成员变量和成员方法）\n\t被  private  修饰的成员只能在本类中才能访问\n\t针对private   修饰的成员变量，如果要被其他类使用，应该提供相应的操作\n\t\t提供“setXxx(参数)”方法，用于给成员变量赋值，方法用public修饰\n\t\t提供\"getXxx()\"方法，用于获取成员变量的值，方法用public修饰\n\n实际开发中，一般只用private和public\n    成员变量私有\n    方法公开\n```\n\n### this\n\n```java\nthis关键字   （表示当前方法调用者的地址值）\n\t可以区分成员变量(在类中不在方法中的变量)和局部变量(方法中的变量就叫局部变量)\n```\n\n### this和super使用总结\n\n```\n表示当前方法调用者的地址值\n这个this是由虚拟机赋值的 \n\nthis\n\t理解为一个变量，表示当前方法调用者的地址\nsuper\n\t代表父类存储空间\n```\n\n\n\n### static\n\n```\nstatic表示静态，是java中的一个修饰符，可以修饰成员方法和成员变量\n\n被static修饰的成员变量  静态变量\n\t特点：\n\t\t被该类所有的对象共享\n\t\t不属于对象，属于类\n\t\t随着类的加载而加载，优先于对象存在\n\t调用方式：\n\t\t类名调用和对象名调用\n\n被static修饰的成员方法  静态方法\n\t特点：\n\t\t多用在测试类和工具类中\n\t\tjavabean类中很少会用\n\t调用方式：a\n\t\t类名调用和对象名调用\n```\n\n### static注意事项\n\n```\n静态方法中，只能访问静态\n非静态方法可以访问所有\n静态方法中没有this关键字\n```\n\n### final\n\n```\n可修饰  方法  类   变量\n一旦用final修饰\n\t方法\n\t\t该方法是最终方法，不能被重写\n\t类\n\t\t该类值最终类，不能被继承\n\t变量\n\t\t叫做常量，只能被赋值一次\n\t\tfinal修改基本数据类型，记录的值不能发生改变\n\t\tfinal修改引用数据类型，记录的地址值不能发生改变，内部的属性值还是可以改变的\n\t\t\n```\n\n### instanceof\n\n```\ninstanceof   \n\t用来判断对象和类型是否一致     对象   instanceof   类型\n```\n\n\n\n## 构造方法（构造器，构造函数）\n\n```java\n作用：\n\t在创建对象时，虚拟机（jvm）会自动调用构造方法，作用是给成员变量进行赋值的\n\t\t例如：\n\t\t\tpublic class Student{\n\t\t\t\t修饰符     方法名与类名相同  (参数){\n\t\t\t\t\t方法体;\n\t\t\t\t}\n\t\t\t}\n特点：\n\t方法名与类名相同大小写也要一致\n\t没有返回值类型，没有void\n\t没有具体的返回值(不能由return返回具体的数据)\n\n\n注意事项：\n\t构造方法的定义：\n\t\t如果没有定义构造方法，系统将会给出一个默认的无参构造\n\t\t\t无参构造：\n\t\t\t\t在初始化对象的时候，成员变量的数据均采用默认值\n\t\t如果自己给出了构造方法，系统将不会提供默认的构造方法\n\t\t\t有参构造：\n\t\t\t\t在初始化对象的时候，同时可以给成员变量进行赋值\n\t构造方法的重载：\n\t\t带参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这就叫做构造方法的重载\n\t推荐使用方式：\n\t\t无论是否使用，都手动书写无参构造方法，和带全部参数的构造方法\n```\n\n## 一个对象的内存图\n\n![](java笔记/Snipaste_2023-02-19_15-50-31.png)\n\n\n\n## ==号到底比的是什么？\n\n![](java笔记/Snipaste_2023-02-28_20-54-06.png)\n\n\n\n\n\n# String概述\n\n## 创建String对象的两种方式\n\n```java\n1。直接赋值\n\tString name = \"Mq\";\n2.new\n\tpublic String()  //空参构造\n\tpublic String(char[] chs)  //根据字符数组，创建字符串对象\n\tpublic String(byte[] chs)  //根据字节数字，创建字符串对象\n\n```\n\n### 第二种创建方式\n\n![](java笔记/Snipaste_2023-02-28_20-43-55.png)\n\n\n\n## String的一些方法\n\n### 字符串比较\n\n```java\nboolean equals方法(要比较的字符串)   完全一样结果才是true，否则就是false\n\nboolean equalslgnoreCase(要比较的字符串)  忽略大小写比较   //一般都是字符串\n    \n//比较两个字符串字母的大小\ncompareTo(String str)\n    String s1 = \"a\";\n\tString s2 = \"b\";\n\ts1.compareTo(s2);\t//会返回-1\n```\n\n### 遍历字符串\n\n```java\npublic char charAt(int index): 根据索引返回字符\npublic int length(): 返回此字符串的长度\n数组的长度： 数组名.length\n字符串的长度： 字符串对象.length()\n字符串的长度是方法    数组的长度是属性\n```\n\n### 截取字符串\n\n```java\nString substring(int beginIndex,int endIndex)  注意：包头不包尾，包左不包右\nString substring(int beginIndex)  截取到末尾 \n```\n\n### 替换字符串\n\n```java\nString replace(旧值,新值)  //注意：只有返回值才是替换之后的结果\n```\n\n### 字符串原理\n\n```java\n字符串存储的内存原理\n\t直接赋值会复用字符常量池中的\n\tnew出来的不会复用，而是开辟一个新的空间\n==号比较的到底是什么？\n\t基本数据类型比较数据值\n\t引用数据类型比较地址值   .equals()方法\n字符串拼接的底层原理\n\t如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串。\n\t如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存。\n```\n\n### 字符串拼接的底层原理\n\n![](java笔记/Snipaste_2023-03-01_21-59-54.png)\n\n## StringBuilder概述\n\n```java\nStringBuilder可以看成一个容器，创建之后里边的内容是可变的！！！\n\t作用：提高字符串的操作效率\n\t比如单纯的字符串拼接操作会产生新的字符串造成空间的浪费\n\t提高效率的底层原理\n\t\t所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存\n构造方法\n\tpublic StringBuilder()    创建一个空白可变字符串对象，不含有任何内容\n\tpublic StringBuilder(String str) 根据字符串的内容，来创建可变字符串对象\n```\n\n### StringBuilder常用方法\n\n```java\npublic StringBuilder append(任意类型) 添加数据，并返回对象本身\npublic StringBuilder reverse() 反转容器中的内容\npublic int lengh() 返回长度（字符出现的个数）\npublic String toString() 通过toString()就可以实现把StringBuilder转换为String\n```\n\n### StringBuilder源码分析\n\n```java\n默认创建一个长度为16的字节数组\n添加的内容长度小于16，直接存\n添加的内容大于16会扩容（原来的容量*2+2）\n如果扩容之后还不够，以实际长度为准\n```\n\n\n\n## **StringJoiner概述**\n\n```java\nStringJoiner和StringBuilder一样，也可以看成一个容器，创建之后里边的内容是可变的\n\t作用：\n\t\t提高字符串的操作效率，而且代码编写特别简介，但是目前市场上很少有人用。\n\t构造方法\n\tpublic StringJoiner(间隔符号)  创建一个StringJoiner对象，指定拼接时的间隔符号\n\tpublic StringJoiner(间隔符号,开始符号,结束符号) 创建一个StringJoiner对象，指定拼接时的间隔符号开始符号和结束符号\n\n```\n\n### **StringJoiner常用方法**\n\n```java\npublic StringJoiner add(添加的内容)  添加数据，并返回对象本身\npublic int length()  返回长度\npublic String toString()  返回一个字符串该字符串就是拼接后的结果 \n```\n\n## 集合\n\n### Collection单列集合（接口，需要创建实现类对象）\n\n![Snipaste_2023-03-16_14-59-52](java笔记/Snipaste_2023-03-16_14-59-52.png)\n\n```java\nCollection\n\tCollection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。\npublic boolean add(E e)\t\t把给定的对象添加到当前集合中\npublic void clear()\t\t清空集合中所有的元素\npublic boolean remove(E e)\t把给定的对象在当前集合删除\npublic boolean contains(Object obj)\t判断当前集合是否包含给定对象\npublic boolean isEmpty()\t判断当前集合是否为空\npublic int size() \t\t返回集合元素个数\n    \n需要注意：\n     contains底层是依赖equals方法进行判断是否存在的\n        // 所以，如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在javabean类中，一定要重写equals方法\n    \n---------------------------------------------------Collection集合获取迭代器\n \n\tIterator<E> iterator()\t\t返回迭代器对象，默认指向当前集合的0索引\n\n```\n\n\n\n\n\n![](java笔记/Snipaste_2023-03-18_15-02-50.png)\n\n#### List集合（也是接口，需要创建实现类的对象）\n\n```java\nList集合的特点\n\t有序：\n\t\t存和取的元素顺序一致\n\t有索引：\n\t\t可以通过索引操作元素\n\t可重复：\n\t\t存储的元素可以重复\n\nList集合的特有方法\n\tCollection的方法List都继承了\n\tList集合因为有索引，所以多了很多索引操作的方法\n\n方法名称\nvoid add(int index,E element) //在集合中按指定位置插入元素\nE remove(int index)\t//删除指定索引的元素，返回被删除的元素\nE set(int index,E element)\t//修改指定索引的元素，返回被修改的元素\nE get(int index)\t//返回指定索引处的元素\n```\n\n\n\n##### ArrayList集合\n\n##### 集合和数组的对比\n\n```java\n集合\n\t长度可变\n\t可以存引用数据类型（存基本数据类型的话需要包装类）\n    E   泛型：限定集合中存储数据的类型\t\n数组\n\t长度固定\n\t可以存基本数据类型和引用数据类型\n```\n\n##### ArrayList成员方法(增删改查)\n\n```java\nboolean add(E e)  //添加元素，返回值表示是否添加成功\nboolean remove(E e)//删除指定元素，返回值表示是否删除成功\nE remove(int index) //删除指定索引的元素，返回被删除的元素\nE set(int index,E e) //修改指定索引下的元素，返回原来的元素\nE get(int index) //获取指定索引的元素\nint size()  //集合的长度，也就是集合中元素的个数\n```\n\n#### \n\n#### Set系列集合（Set接口中的方法和Collection的Api一致）\n\n```\nSet集合特点：\n\t无序：存取顺序不一致\n\t不重复：可以去除重复\n\t无索引:没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素\n\t\nSet集合的实现类：\n\tHashSet：无序、不重复、无索引\n\tLinkedHashSet：有序、不重复、无索引\n\tTreeSet：可排序、不重复、无索引\n```\n\n#### HashSet\n\n~~~\nHashSet底层原理：\n\tHashSet集合底层采取哈希表存储数据\n\t哈希表是一种对于增删改查数据性能都较好的结构\n\t1.创建一个默认长度16，默认加载因子为0.75的数组，数组名为table\n\t2.根据元素的哈希值跟数组的长度计算出应存入的位置\n\t3.判断当前位置是否为null，如果是null直接存入\n\t4.如果位置不为null，表示有元素，则调用equals方法比较属性值\n\t5.一样： 不存\t\t不一样： 存入数组，形成链表\n\t\tJDK8以前： 新元素存入数组，老元素挂在新元素下面\n\t\tJDK8以后： 新元素直接挂在老元素下面\n\tJDK8以后，当链表长度超过8，而且数组长度大于等于64时，自动转换为红黑树\n\t\n\t如果集合中存储的时自定义对象，必须重写hashCode和equals方法\n\n\nHashSet的三个问题\n\tHashSet为什么存和取的顺序不一样？\n\t\t遍历时从数组的0索引开始，遇到链表先遍历完再进行数组的遍历\n\t\n\tHashSet为什么没有索引？\n\t\t因为HashSet在底层是，数组链表和红黑树组成的的结构，不知道以谁当索引\n\t\n\tHashSet是利用什么机制保证数据去重的？\n\t\tHashSet方法和equals方法\n\n哈希表组成：\n\tJDK8之前：\n\t\t数组+链表\n\tJDK8开始：\n\t\t数组+链表+红黑树\n\n\n哈希值：\n\t对象的整数表现形式\n\t根据hashCode方法算出来的int类型的整数\n\t该方法定义再Object类中，所有对象都可以调用，默认使用地址值进行计算\n\t一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值\n\t\n对象的哈希值特点：\n\t如果没有重写hashCode方法，不同对象计算出的哈希值是不同的\n\t如果已经重写hashCode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的\n\t在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样（哈希碰撞）\n~~~\n\n##### LinkedHashSet\n\n~~~\n继承HashSet直接用HashSet的方法即可\n底层是使用双向链表保证数据的顺序\n特点：\n\t有顺序、不重复、无索引\n~~~\n\n#### TreeSet\n\n~~~java\n特点：\n\t可排序、不重复、无索引\n\t\nTreeSet添加的两种规则：\n\t方式一：\n\t\t默认排序，自然排序：\n\t\t\tJavabean类实现Comparable接口指定比较规则\n\t\t\t\n\t// 返回值：\n    //     负数：认为要添加的元素是小的，存在左边\n    //     正数：认为要添加的元素是大的，存在右边\n    //     0：认为要添加的元素已经存在，舍弃\n    @Override\n    public int compareTo(Student o) {\n        //指定排序的规则\n\t\t//按照年龄比较\n        \n        return this.getAge()-o.getAge();\n        // return 0;\n    }\n\n\n\t方式二：\n        比较器排序：创建TreeSet对象的时候，传递比较器Comparator指定规则\n~~~\n\n### 单列集合总结\n\n~~~\n1.如果想要集合中的元素可重复\n\t用ArrayList集合，基于数组的\n2.如果想要集合中元素重复，而且当前的增删操作明显多于查询\n\t用LinkedList集合，基于链表的\n3.如果想对集合中的元素去重\n\t用HashSet集合，基于哈希表的\n4.如果想对集合中的元素去重，而且保证存取顺序\n\t用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet\n5.如果想对集合中的元素进行排列\n\t用TreeSet集合，基于红黑树，后续也可以用List集合实现排序\n~~~\n\n\n\n### Map双列集合（Map是双列集合的顶层接口，它的共功能是全部双列集合都可以继承使用的）\n\n~~~\n双列集合的特点\n\t双列集合一次需要存一对数据，分别为键和值\n\t键不能重复，值可以重复\n\t键和值是一一对应的，每一个键只能找到自己对应的值\n\t键+值这个整体 我们称之为\"键值对\" 或者 \"键值对对象\"，在java中叫做\"Entry对象\"\n\t\nTreeMap特点：\n\t不重复、无索引、可排序\n\t底层基于红黑树实现排序，增删改查性能好\nTreeMap集合排序的两种方式：\n\t实现Compareble接口，指定比较规则\n\t创建集合时传递Com【arator比较器对象，指定比较规则\n~~~\n\n![Snipaste_2023-03-20_15-15-33](java笔记/Snipaste_2023-03-20_15-15-33.png)\n\n#### Map常见的API\n\n~~~\nV put (K key,V value)\t\t添加元素\nV remove(Object key)\t\t根据键删除键值对元素\nvoid clear()\t\t\t\t移除所有的键值对元素\nboolean containsKey(Object key)\t判断集合是否包含指定的键\nBoolean containsValue(Object value) 判断集合是否包含指定的值\nboolean isEmpty() \t\t\t判断集合是否为空\nint size()\t\t\t\t\t集合的长度，也就是集合中键值对的个数\nint get(Object key)\t\t\t判断键出现的次数\n~~~\n\n##### Map遍历\n\n~~~java\n遍历方式有三种\n\t1.键找值\n\t//获取所有的键，把这些键放到一个集合中\n        Set<String> keySet = m.keySet();\n        然后通过Set集合遍历\n    //利用map中对应的key键获取对应的值value\n        String value = m.get(key);\n        System.out.println(\"key = \"+key+\"  value = \"+value);\n\t2.不推荐\n    3.利用Lambda改写BiConsumer\n        m.forEach((key,value)-> System.out.println(key+\"=\"+value));\n\n\n统计思想，利用map集合进行排序\n    如果题目中没有要求对结果进行排序，默认使用HashMap\n\t如果题目中要求对结果进行排序，默认使用TreeMap\n    \n~~~\n\n\n\n\n\n## 遍历\n\n### Colleation遍历\n\n#### 迭代器遍历\n\n```\n迭代器不依赖索引\nIterator中常用方法\n\nboolean hasNext() 判断当前位置是否有元素，有元素返回true，没有元素返回false\n\nE next() \t获取当前位置的元素，并将迭代器对象移向下一个位置\n```\n\n#### 增强for\n\n```java\n增强for的底层就是迭代器，为了简化迭代器的代码书写的\n他是JDK5以后出现的，其内部原理就是一个Iterator迭代器\n所有的单列集合和数组才能用增强for进行遍历\n\n格式：\n\tfor(元素的数据类型 变量名:数组或集合){\n        \n    }\n例如：\n    for(String s : List){\n        System.out.println(s);\n    }\n\n增强for的细节：\n    \t修改增强for中的变量，不会改变集合中原本的数据\n```\n\n#### Lambda表达式遍历\n\n```\nJDK8开始的新技术Lambda表达式，提供了一种更简单，更直接的遍历集合的方式\n() -> \ndefault void forEach(Consumer<? super T> action) :\t\t结合Lambda遍历集合\n```\n\n\n\n\n\n### 基本数据类型对应包装类\n\n![Snipaste_2023-03-02_21-18-07](java笔记/Snipaste_2023-03-02_21-18-07.png)\n\n## 其他\n\n### 反射\n\n~~~\n什么是反射？\n\t反射允许对封装类的字段（成员变量）\n\t方法（成员方法）\n\t构造函数（构造方法）\n\t的信息进行编程访问\n~~~\n\n\n\n### 多线程\n\n~~~\n什么是多线程？\n\t有了多线程，我们就可以让程序同时做多件事情\n多线程的作用？\n\t提高效率\n多线程的应用场景？\n\t只要你想让多个事情同时运行就需要用到多线程\n~~~\n\n\n\n#### 并发与并行\n\n~~~\n并发：\n\t在同一时刻，有多个指令在单个CPU上   交替   执行\n\t\n并行：\n\t在同一时刻，有多个指令在多个CPU上   同时   执行\n~~~\n\n#### 多线程三种实现方法对比\n\n~~~\n第一种：\n\t继承Thread类\n\t\t优点：\n\t\t\t编程比较简单可以直接使用Thread类中的方法\n\t\t缺点：\n\t\t\t扩展性较差，不能再继承其他类\n第二种：\n\t实现Runnable接口\n\t\t优点：\n\t\t\t扩展性强，实现该接口的同时还可以继承其他的类\n\t\t缺点：\n\t\t\t编程相对复杂，不能直接使用Thread类中的方法\n第三种：\n\t实现Callable接口    （同第二种）\n\t不过可以获取线程运行的结果\n~~~\n\n#### 线程常用的成员方法\n\n~~~java\n// 返回此线程的名称\nString getName()\n\n// 设置线程的名字（构造方法也可以设置名字）\nvoid setName(String name)\n    \n// 获取当前线程的对象\nstatic Thread currentThread()\n    \n// 让线程休眠指定的时间，单位为毫秒\nstatic void sleep(Long time)\n    \n// 设置线程的优先级\nsetPriority(int newPriority)\n    \n// 获取线程的优先级\nfinal int getPriority()\n    \n// 设置为守护线程\nfinal void setDaemon(boolean on)\n    \n// 出让线程/礼让线程\npublic static void yield()\n    \n// 插入线程/插队线程\npublid static void join()\n~~~\n\n#### 线程的生命周期\n\n![Snipaste_2023-03-29_11-50-03](java笔记/Snipaste_2023-03-29_11-50-03.png)\n\n#### 同步代码块\n\n~~~\n把操作共享数据的代码锁起来\n格式：\n\tsynchronized(锁){\n\t\t操作共享数据的代码\n\t}\n特点：\n\t锁默认打开，有一个线程进入，锁自动关闭\n\t里面所有的代码全部执行完毕，线程出来，锁自动打开\n~~~\n\n#### Lock锁\n\n~~~java\nLock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作\nLock中提供了获得锁和释放锁的方法\nvoid locl():获得锁\nvoid unlock():释放锁\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\nReentrantLock的构造方法\nReentrantLock():创建一个ReentrantLock的实例化\n~~~\n\n### 线程池\n\n~~~\nExecuors：\n\t线程池的工具类通过调用方法返回不同类型的线程池对象\n\n线程池代码实现：\n\n// 创建一个没有上线的线程池\npublic static ExecutorService newCachedThreadPool()\n\n// 创建有上限的线程池\npublic static ExecutorService newFixedThreadPool(int nThreads)\n\n\n线程池主要核心原理\n\t1.创建一个池子，池子中是空的\n\t2.提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可\n\t3.但是如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待\n\n\n自定义线程池\n\t小结：\n\t\t1.创建一个空的池子\n\t\t2.有任务提交时，线程池会创建线程去执行任务，执行完毕归还线程\n\t\t\n不断的提交任务，会有三个临界点：\n\t1.当核心线程满时，在提交任务就会排队\n\t2.当核心线程满，队伍满时，会创建临时线程\n\t3.当核心线程满，队伍满，临时线程满时，会触发任务拒绝策略\n~~~\n\n### 网络编程\n\n~~~\n什么是网络编程？\n\t在网络通信协议下，不同计算机上运行的程序，进行的数据传输\n\t\n表示互联网协议（IP）地址的类\n\tInetAddress\n\t\n端口号：\n\t应用程序在设备中的唯一标识\n\t\n\t端口号：\n\t\t由两个字节表示的整数，取值范围：0~65535\n\t\t其中0~1023之间的端口号用于一些知名的网络服务或者应用\n\t\t我们自己使用1024以上的端口号就可以了\n\t注意：\n\t\t一个端口号只能被一个应用程序使用\n\t\t\n\t\t\n协议：\n\t计算机网络中，连接和通信的规则被称为网络通信协议\n\t\n\tUDP协议：\n\t\t用户数据报协议\n\t\tUDP是  面向无连接  通信协议\n\t\t速度快，有大小限制一次最多发送64K，数据不安全，易丢失\n\t\t\n\tUDP的三种通信方式\n\t\t1.单播：\n\t\t\t以前的代码就是单播\n\t\t2.组播：\n\t\t\t组播地址：224.0.0.0 ~ 239.255.255.255\n\t\t\t\t\t其中224.0.0.0 ~ 224.0.0.255为预留的组播地址\n\t\t3.广播：\n\t\t\t广播地址：255.255.255.255\n\tTCP协议：\n\t\t传输控制协议TCP\n\t\tTCP协议是  面向连接  的通信协议\n\t\t速度慢，没有大小限制，数据安全\n\t\t\n客户端：\n\t1.创建客户端的Socket对象与指定服务端连接\n\tSocket(String host,int port)\n\t2.获取输出流，写数据\n\tOutputStream  getOutputStream()\n\t3.释放资源\n\tvoid close()\n\t\n服务器：\n\t1.创建服务器端的Socket对象\n\tServerSocket(int port)\n\t2.监听客户端连接，返回一个Socket对象\n\tSocket accept()\n\t3.获取输入流，读数据，并把数据显示在控制台\n\tInputStream   getInputStream()\n\t4.释放资源\n\tvoid close()\n~~~\n\n#### TCP通信程序（三次握手）\n\n![Snipaste_2023-03-30_09-20-17](java笔记/Snipaste_2023-03-30_09-20-17.png)\n\n#### TCP通信程序（四次挥手）\n\n![Snipaste_2023-03-30_09-23-49](java笔记/Snipaste_2023-03-30_09-23-49.png)\n\n### IO流\n\n~~~\n什么是IO流\n\t存储和读取数据的解决方啊\n\tI:intput\tO:output\n\t流：像水流一样传输数据\n\nIO流的作用：\n\t用于读写数据（本地文件，网络）\n\t\nIO流按照流向可以分类哪两种流\n\t输出流： 程序  ->  文件\n\t输入流： 文件  ->  程序\n\t\nIO流按照操作文件的类型可以分类哪两种流\n\t字节流：可以操作所有类型的文件\n\t字符流：只能操作纯文本文件\n\t\n什么是纯文本文件\n\t用Windows系统自带的记事本打开并且能够读懂的文件\n~~~\n\n\n\n### File\n\n~~~java\nFile表示什么：\n    File对象表示路径，可以是文件，也可以是文件夹。\n    这个路径可以是存在的，也可以是不存在的\n    \n绝对路径和相对路径是什么意思：\n    绝对路径是带盘符的\n    相对路径是不带盘符的，默认到当前项目下去找\n\nFile三种构造方法：    \n\t// 根据文件路径创建文件对象\n\tpublic File(String pathname)\n    \n\t// 根据父路径名字符串和子路径名字符串创建文件对象\n\tpublic File(String parent, String chile)\n    \n\t// 根据父路径对应文件对象和子路径名字符串创建文件对象\n\tpublic File(File parent,String chile)\n    \n~~~\n\n\n\n#### File常见的成员方法\n\n~~~\n// 判断此路径名表示的File是否为文件夹\nboolean isDirectory()\n\n// 判断此路径名表示的File是否为文件\nboolean isFile()\n\n// 判断此路径名表示的File是否为存在\nboolean exists()\n\n// 返回文件的大小(字节数量)\nlong length()\n\n// 返回文件的绝对路径\nString getAbsolutePath()\n\n// 返回定义文件时使用的路径\nString getPath()\n\n// 返回文件的名称，带后缀\nString getName()\n\n// 返回文件的最后修改时间(时间毫秒值)\nLong lastModified()\n\n=================(创建、删除)==============\n// 创建一个新的空的文件\nboolean createNewFile()\n\n// 创建单级文件夹\nboolean mkdir()\n\n// 创建多级文件夹\nboolean mkdirs()\n\n// 删除文件、空文件见！！！注意删除的时候不走回收站\nboolean delete()\n\n=================获取并遍历===============\n// 获取当前该路径下所有内容\nFile[] listFiles()\n~~~\n\n#### FileOutPutStream书写细节（字节流）\n\n~~~\n字节输出流的细节：\n  \t1.创建字节输出流对象\n        细节1：参数是字符串表示的路径或者是File对象都是可以的\n        细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的\n        细节3: 如果文件中存在数据，则会清空数据\n        \n     2.写出数据：\n        细节1：write输入的是整数，但是保存在本地的是ASCII的对应字符\n        \n     3.释放资源：\n        每次使用完流之后都要释放资源\n        \n        \nFileOutPutStream写数据的3中方式\n\n//一次写一个数据\nvoid write(int b)\n\n//一次写一个字节数组数据\nvoid write(byte[] b)\n\n//一次写一个字节数组的部分数据\nvoid write(byte[] b,int off,int len)\n~~~\n\n#### FileInPutStream书写细节（字节流）\n\n~~~\n1.创建字节输入流对象：\n\t细节1：如果文件不存在，就直接报错\n\t\n2.读取数据：\n\t细节1：一次读一个字节，读出来的数据是ASCII上对应的数字\n\t细节2：读到文件末尾了，read方法返回-1\n\n3.释放资源：\n\t细节：每次使用完流必须要释放资源\n~~~\n\n### FileReader（字符流）\n\n~~~java\n//第一步：创建对象\npublic FileReader(File file)        创建字符输入流关联本地文件\n public FileReader(String pathname)  创建字符输入流关联本地文件\n\n//第二步：读取数据\npublic int read()                   读取数据，读到末尾返回-1\npublic int read(char[] buffer)      读取多个数据，读到末尾返回-1\n\n//第三步：释放资源\npublic void close()                 释放资源/关流\n~~~\n\n#### 字符流原理解析\n\n~~~\n1.创建字符输入流对象\n\t底层：关联文件，并创建缓冲区（长度为8192的字节数组）\n\n2.读取数据\n\t底层：\n\t\t1.判断缓冲区中是否有数据可以读取\n\t\t2.缓冲区没有数据：\n\t\t\t\t就从文件中获取，撞到缓冲区中，每次尽可能装满缓冲区 如果文件中也没有数据了，返回-1\n\t\t3.缓冲区有数据：\n\t\t\t\t就从缓冲区读取\n\t\t\t空参的read方法：\n\t\t\t\t一次读取一个字节，遇到中文一次读多个字节，把字节解码并转换成十进制返回\n\t\t\t有参的read方法：\n\t\t\t\t把读取字节，解码，强转三步合并了，强转之后的字符放到数组中\n~~~\n\n\n\n### 缓冲流\n\n~~~\n1.缓冲流有几种\n\t字节缓冲输入流：BufferedInputStream()\n\t字节缓冲输出流：BufferedOutputStream()\n\t字符缓冲输入流：BufferedReader()\n\t字节缓冲输出流：BufferedWriter()\n\n2.缓冲流为什么能提高性能\n\t缓冲流自带长度为8192的缓冲区\n\t可以显著提高字节流的读写性能\n\t对于字符流提升不明显，有两种特有的方法\n\n3.字符缓冲流有两个特有的方法\n\t字符缓冲输入流 BufferedReader: readLine()\n\t字符缓冲输出流 BufferedWriter: newLine()\n~~~\n\n### 转换流\n\n~~~\n转换流的名字：\n\t字符转换输入流：InputStreamReader\n\t字符转换输出流：OutputStreamWriter\n转换流的作用是什么：\n\t指定字符集读写数据\n\t字节流想要使用字符流中的方法\n~~~\n\n### 序列化流/对象操作输出流\n\n~~~\n可以把Java中的对象写到本地文件中\n\n构造方法\n// 把基本流包装成高级流\npublic ObjectOutputStream(OutputStream out)\n\n成员方法\n// 把对象序列化(写出)到文件中去\npublic final void wtiterObject(Object obj)\n\n\n序列化小细节：\n\t使用对象输出流将对象保存到文件时会出现问题\n\n解决方案：\n\t需要让JavaBean类实现Serializable接口\n\t\n如果一个对象的某个成员变量的值不想被序列化\n\t给该成员变量加上transient关键字修饰\n\t该关键字标记的成员变量不参与序列化过程\n~~~\n\n### 打印流\n\n~~~\n分类：\n\t一般是指PintStream，PrintWrite\n特点1：\n\t打印流只操作文件目的地，不操作数据源\n特点2：\n\t特有的写出方法可以实现，数据原样写出\n特点3：\n\t特有的写出方法，可以实现自动刷新，换行\n\t\n字节打印流：\n\t构造方法\n\t//关联字节输出流/文件/文件路径\n\tpublic PrintStream(OutStream/File/String)\n\t//指定字符编码\n\tpublic PrintStream(String fileName, Charset charset)\n\t\n\t成员方法：\n\t//规则和之前一样，将指定的字节写出\n\tvoid write(int b)\n\t\n\t特有方法：\n\t//打印任意数据，自动换行，自动刷新\n\tprintln()\n\t//打印任意数据，不换行\n\tprint()\n\t//带有占位符的打印语句，不换行\n\tprintf(String format, Object... args)\n~~~\n\n\n\n\n\n### 字符集\n\n~~~\n1.在计算机中，任意数据都是以二进制的形式来存储的\n2.计算机中最小的存储单元是一个字节\n3.ASCII字符集中，一个英文占一个字节\n4.简体中文版Windows，默认使用GBK字符集\n5.GBK字符集完全兼容ASCII字符集\n\t一个英文占一个字节，二进制第一位是0\n\t一个中文占两个字节，二进制高位字节的第一位是1\n\t\nUnicode字符集的UTF-8下\n\t一个英文占一个字节，二进制第一位是0\n\t一个中文占3个字节，1110XXXX 10XXXXXX 10XXXXXX（首位是1）\n~~~\n\n\n\n### 异常\n\n~~~\n异常：\n\t就是代表程序出的错误\n\n误区：\n\t不是让我们以后不出异常，而是程序出了异常之后，该如何处理\n\t\n异常体系的最上层父类是谁？异常分为几类？\n\t父类：Exception\n\t异常分为两类：编译时异常、运行时异常\n\n编译时异常和运行时异常的区别\n\t编译时异常：\n\t\t没有继承RuntimeException的异常，直接继承于Exception\n\t\t编译阶段就会错误提示\n\t运行时异常：\n\t\tRuntimeException本身和子类\n\t\t编译阶段没有错误提示，运行时出现的\n\t\n~~~\n\n![Snipaste_2023-03-22_17-41-33](java笔记/Snipaste_2023-03-22_17-41-33.png)\n\n#### 捕获异常\n\n~~~java\n格式：\n    try{\n        可能出现异常的代码;\n    } catch(异常类名 变量名) {\n        异常的处理代码;\n    }\n目的：\n    当代码出现异常时，可以让程序继续往下执行\n~~~\n\n![Snipaste_2023-03-22_18-23-55](java笔记/Snipaste_2023-03-22_18-23-55.png)\n\n### 方法引用\n\n~~~\n1.什么是方法引用？\n\t把已经存在的方法拿过来用，当作函数式接口中抽象方法的方法体\n2.::是什么符号？\n\t方法引用符\n3.方法引用时需要注意什么？\n\t需要有函数式接口\n\t被引用方法必须已经存在\n\t被引用方法的形参和返回值需要跟抽象方法保持一致\n\t被引用方法的功能要满足当前的需求\n\t\n\t\n=================================================================\n1.引用静态方法\n\t类名::静态方法\n2.引用成员方法\n\t对象::成员方法\n\tthis::成员方法\n\tsuper::成员方法\n3.引用构造方法\n\t类名::new\n4.使用类名引用成员方法\n\t类名::成员方法\n5.引用数组的构造方法\n\t数据类型[]::new\n~~~\n\n\n\n### Stream流\n\n~~~\nStream流的思想\n\nStream流的作用：\n\t结合了Lambda表达式，简化集合，数组的操作\n\t\nStream流的使用步骤：\n\t1.先得到一条Stream流（流水线），并把数据放上去\n\t2.利用Stream流中的API进行各种操作\n\t过滤\t\t转换\t\t中间方法   方法调用完毕之后，还可以调用其他方法\n\t统计\t\t打印\t\t终结方法   最后一步，调用完毕之后，不能调用其他方法\n\t\n使用流程：\n获取方式\t\t方法名\t\t\t  \t\t\t\t\t说明\n单列集合\tdefault Stream<E> stream()\t\tCollection中的默认方法\n双列集合\t\t无\t\t\t\t\t\t\t无法直接使用Stream流\n数组\t\tpublic static<T>Stream<T>stream(T[] Array)\tArray工具类\n一堆零散的数据\t\t\tStream<T>of(T...values)\tStream接口的静态方法\n~~~\n\n### Stream流的中间方法\n\n~~~\n过滤\n\tStream<T>filter(Predicate<? super T>predicate) \n\t\n获取前几个元素\n\tStream<T>limit(long maxSize)\n\t\n跳过前几个元素\n\tStream<T>skip(long n)\n\t\n元素去重，依赖（hashCode和equals方法）\n\tStream<T>distinct()\n\t\n合并a和b两个流为一个流\n\tstatic<T>Stream<T>concat(Stream a,Stream b)\n\t\n转换流中的数据类型\n\tStream<R>map(Function<T,R> mapper)\n\t\n注意点：\n\t1.中间方法，返回新的Stream流，原来的Stream流只能用一次，建议使用链式编程\n\t2.修改Stream流中的数据，不会影响原来集合或者数组中的数据\n~~~\n\n### Stream流的终结方法\n\n~~~java\n遍历\nvoid forEach(Consumer action)\n\n统计\nlong count()\n\n收集流中的数据，放到数组中\ntoArray()\n\n收集流中的数据，放到集合中\ncollect(Collector collector)\n~~~\n\n\n\n### 不可变集合\n\n~~~\n在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合\n\n方法：\nstatic <E> List<E> of(E...elements) 创建一个具有指定元素的List集合对象\nstatic <E> Set<E> of(E...elements) 创建一个具有指定元素的Set集合对象\nstatic <E,V> Map<K,V> of(E...elements) 创建一个具有指定元素的Map集合对象\n\n注意：\n\t这个集合不能添加，不能删除，不能修改\n\t\n\t\n不可变集合的特点：\n\t定义完成后不可以修改，或者添加，删除\n如何创建不可变集合：\n\tList，Set，Map接口中，都存在of方法可以创建不可变集合\n三种方式的细节：\n\tList：\n\t\t直接用\n\tSet：\n\t\t元素不能重复\n\tMap：\n\t\t元素不重复，键值对数量最多是10个\n\t\t超过10个用ofEntries方法\n\t\t（如果JDK超过10  可以用copyOf方法）\n\t\tMap<String, String> map = Map.copyOf(hashMap);\n~~~\n\n\n\n\n\n### Collections工具类\n\n~~~ \n作用：\n\tCollections不是集合，而是集合的工具类\n\t\nCollections常用的API\n\n方法名称\npublic static <T> boolean addAll(Collection<T> c,T...elements)\n\t批量添加元素\npublic static void shuffke(List<?> list) \n\t打乱list集合元素的顺序。\npublic static <T> void sort(List<T> List)\n\t排序\npublic static <T> void sort(List<T> List,Comparator<T> c)\n\t根据指定的规则进行排序\npublic static <T> int binarySearch(List<T>, T key)\n\t以二分查找法查找元素\npublic static <T> void copy(List<T> dest,List<T> src)\n\t拷贝集合中的元素\npublic static <T> int fill(List<T> list,T obj)\n\t使用指定的元素填充集合\npublic static <T> void max/min(Collection<T> coll)\n\t根据默认的自然排序获取最大/最小值\npublic static <T> void swap(List<?> list,int i,int j)\n\t交换集合中指定位置的元素\n~~~\n\n\n\n### 可变参数\n\n~~~\nJDK5\n可变参数\n方法形参的个数时可以发生变化的0 1 2 3......\n\n作用：\n\t在形参中接收多个数据\n\n格式：\n\t数据类型...名字\n\n\n底层：\n\t可变参数底层就是一个数组\n\t只不过不需要我们自己创建了，java会帮我们创建好\n\t\npublic static int getSum(int...args){\n\n}\n\n\n小细节：\n\t在方法的形参中可变参数最多可以写一个\n\t如果在方法中除了可变参数还有其他形参，那么可变参数要写在最后\n~~~\n\n\n\n### 泛型\n\n```\n泛型：\n\t是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查\n\t\n泛型的格式：\n\t<数据类型>\n注意：\n\t泛型只能支持引用数据类型\n\t如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合添加任意的数据类型，带来一个坏处，我们在获取数据的时候，无法使用他的特有行为\n\t\n\t\n扩展知识：\n\tJava中的泛型是伪泛型\n\t在Java文件中泛型存在，编译后泛型就不存在了\n\t叫做泛型的擦除\n\n泛型的细节：\n\t泛型中不能写基本数据类型\n\t指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型\n\t如果不写泛型，类型默认是Object\n\t\n泛型方法：\n\t方法中形参类型不确定时\n\t\t方案1：\n\t\t\t使用类名后面定义的泛型\t\t本类中所有的方法都能用\n\t\t方案2：\n\t\t\t在方法申明上定义自己的泛型\t只有本方法可以用\n\t\t\t\n泛型方法格式：\n\t修饰符<类型>返回值类型 方法名(类型 变量名){\n\t\n\t}\n\t\n\t//K T V E\n\tpublic <T> void show(T,t){\n\t\n\t}\n\t\n泛型接口：\n\t格式：\n\t\t修饰符 interface 接口名<类型>{\n\t\t\n\t\t}\n\t举例：\n\t\tpublic interface List<E>{\n\t\t\n\t\t}\n\t\t\n重点：\n\t如何使用一个带泛型的接口\n\t\n方式1：\n\t实现类给出具体类型\n方式2：\n\t实现类延续泛型，创建对象时再确定\n```\n\n\n\n### Lanmbda表达式\n\n```java\nLambda的省略规则\n    1.参数类型可以省略不写\n\t2.如果只有一个参数，参数类型可以省略，同时()也可以省略\n\t3.如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略\n    \nlambda表达式的标准格式\n\t() -> {\n    \n\t}\nLambda表达式的基本作用：\n\tLambda表达式可以用来简化匿名内部类的书写\n\tLambda表达式只能简化函数式接口的匿名内部类的书写\n\nLambda表达式有什么使用前提：\n    必须式接口的匿名内部类，接口中只能有一个抽象方法\n    \nLambda的好处：\n    Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，它可以写出更简洁，更灵活的代码，作为一种更紧凑的代码风格，使Java语言表达能力得到了提升\n```\n\n\n\n### 计算机存储规则\n\n![Snipaste_2023-03-04_14-40-29](java笔记/Snipaste_2023-03-04_14-40-29.png)\n\n### 重新认识main方法\n\n```\npublic:\n\t被jvm调用，访问权限足够大\nstatic：\n\t被jvm调用，不用创建对象，直接类名访问\n\t因为main方法是静态的，所以测试类中其他方法也需要是静态的\nvoid：\n\t被jvm调用，不需要给返回值\nmain：\n\t一个通用的名称，虽然不是关键字，但是被jvm识别\nString[] args：\n\t以前用于接收键盘录入数据的，现在没用\n```\n\n### 重写\n\n```\n方法的重写\n\t当父类的方法不能满足子类现在的需求时，需要进行方法的重写\n书写格式\n\t在继承体系中，子类出现了和父类一样的方法声明，我们就称为子类这个方法是重写的方法\n\n@Override重写注解\n\t1.@Override是重写后的方法上，校验子类重写时语法是否正确\n\t2.加上注解后如果有红色波浪线，表示语法错误\n\t3.建议重写方法都加@Override注解，代码安全，优雅。\n```\n\n\n\n### 注解\n\n```\n@Override重写注解\n\t1.@Override是重写后的方法上，校验子类重写时语法是否正确\n\t2.加上注解后如果有红色波浪线，表示语法错误\n\t3.建议重写方法都加@Override注解，代码安全，优雅。\n\n@FunctionalInterface函数式接口（Lambda表达式的时候使用）\n\t有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加\t@FunctionalInterface注解判断\n```\n\n### 包\n\n```\n使用其他类的规则\n\t使用同一个包中的类时，不需要导包\n\t使用java.lang包中的类时，不需要导包\n\t其他情况都需要导包\n\t如果同时使用两个包中的同名类，需要使用全类名\n```\n\n### 代码块\n\n```java\n代码块的分类\n\t局部代码块，构造代码块，静态代码块\n\t\n局部代码块\n\t提前结束变量的生命周期（已经淘汰）\n构造代码块\n\t抽取构造方法中的重复代码（不够灵活）\n\t\t\t{\n    \n\t\t}\n静态代码块\n\t数据的初始化 \n\t\tstatic{\n\t\t\n\t\t}\n```\n\n### 抽象类（abstract）\n\n```\n抽象类的作用是什么\n\t抽取共性时，无法确定方法体，就把方法定义为抽象的。\n\t强制让子类按照某种格式重写\n\t抽象方法所在的类，必须时抽象类\n\n抽象类和抽象方法的格式\n\tpublic abstract 返回值类型 方法名(参数列表);\n\tpublic abstract class 类名{}\n\n继承抽象类有哪些要注意\n\t要么重写抽象类中所有的方法\n\t要么时抽象类\n```\n\n### 设计模式\n\n```\n设计模式是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性，程序的重用性\n```\n\n#### 适配器设计模式\n\n```\n解决接口与接口实现类之间的矛盾问题\n\t\n当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以适配器设计模式\n\t\n书写步骤 \n\t编写中间类XXXAdapter，实现对应的接口\n\t对接口中的抽象方法进行空实现\n\t让真正的实现类继承中间类，并重写需要用的方法\n\t为了避免其他类创建适配器类的对象，中间的适配器类\n\t用abstract进行修饰\n```\n\n### 内部类\n\n```\n类的五大成员：\n\t属性，方法，构造方法，代码块，内部类\n\t\n\n内部类\n\t表示的事物是外部类的一部分\n\t内部类单独出现没有意义\n\t\n内部类的访问特点\n\t内部类可以直接访问外部类的成员，包括私有\n\t外部类要访问内部类的成员，必须创建对象\n\t\n成员内部类\n\t写在成员位置，属于外部类的成员\n\t\n\t获取成员内部类对象的两种方式\n\t\t方式一：\n\t\t\t当成员内部类被private修饰时\n\t\t\t在外部类中编写方法，对外提供内部类的对象\n\t\t方式二：\n\t\t\t当成员内部类被非私有修饰时，直接创建对象\n\t\t\tOuter.Inner oi = new Outter().new Inner();直接创建对象\n\t外部类成员变量和内部类成员变量重名时，在内部类中如何访问\n\t\tSystem.out.pringln(Outer.this.变量名);\n\t\t\n静态内部类\n\n局部内部类\n\n匿名内部类\n\t什么是匿名内部类：\n\t\t隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置\n\t匿名内部类的格式：\n\t\tnew 类名或者接口名(){\n\t\t\t重写方法;\n\t\t}\n\t格式的细节\n\t\t包含了继承或实现，方法重写，创建对象。\n\t\t整体就是一个类的子类对象或者接口的实现类对象\n\t使用场景\n\t\t当方法的参数是接口或者类时\n\t\t以接口为例，可以传递这个接口的实现类对象，\n\t\t如果实现类只使用一次，就可以用匿名内部类简化代码\n```\n\n### 事件\n\n```\n事件源：\n\t按钮 图片 窗体...\n事件：某些操作\n\t如：鼠标单击，鼠标划入...\n绑定监听：\n\t当事件源上发生了某个事件，则执行某段代码\n\t\nKeryListener\n\t键盘监听\nMouseListener\n\t鼠标监听\n\t\t\t划入动作\n\t\t\t按下动作\n\t\t\t松开动作\n\t\t\thua'chu\nActionListener\n\t动作监听\n```\n\n### API\n\n#### BigInteger\n\n```\nBigInteger构造方法\t\t注意：对象一旦创建，内部的值不能发生改变\n\tpublic BigInteger(int num, Random rnd)\t\t获取随机大整数 范围：[0~2的num次方-1]\n\tpublic BigInteger(String val)\t\t\t\t获取指定的大整数\n\tpublic BigInteger(String val, int radix) \t获取指定进制的大整数\n\t\n\tpublic static BigInteger valueOf(long val)\t静态方法获取BigInteger的对象，内部有优化\n\t\n\tBigInteger构造方法小结\n\t\t如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取\n\t\t如果BigInteger表示的超出long的范围，可以用构造方法获取\n\t\t对象一旦创建，BigInteger内部记录的值不能发生改变\n\t\t只要进行计算都会产生一个新的BigInteger对象\n\t\t\nBigInteger成员方法\n\tpublic BigInteger add(BigInteger val)\t\t\t\t\t加法\n\tpublic BigInteger subtract(BigInteger val)\t\t\t\t减法\n\tpublic BigInteger multiply(BigInteger val)\t\t\t\t乘法\n\tpublic BigInteger divide(BigInteger val)\t\t\t\t除法，获取商\n\tpublic BigInteger divideAndRemainder(BigInteger val)\t除法，获取商和余数\n\tpublic BigInteger equals(Object x)\t\t\t\t\t\t比较是否相同\n\tpublic BigInteger pow(int exponent)\t\t\t\t\t\t次幂\n\tpublic BigInteger max/min(BigInteger val)\t\t\t\t返回较大值/较小值\n\tpublic int intValue(BigInteger val)\t\t\t\t\t\t转为int类型整数，超出范围数据有误\n```\n\n### 包装类\n\n```\n8种包装类中除了Character都有对应的parseXxx的方法进行类型\n```\n\n\n\n#### Integer\n\n```java\nInteger的成员方法\n\tpublic static String ToBinaryString(int i)\t\t\t得到二进制\n\tpublic static String ToOctalString(int i)\t\t\t得到八进制\n\tpublic static String ToHexString(int i)\t\t\t\t得到十六进制\n\tpublic static int parseInt(String s)\t\t\t\t将字符串类型的整数转成int类型的整数\n```\n\n### 快速排序\n\n```java\n第一轮：\n\t把0索引的数字作为基准数，确定基准数在数组中正确的位置。\n\t比基准数小的全部在左边，比基准数大的全部在右边。\n\t代码：\n    public static void quickSort(int[] arr, int i, int j) {\n        // 定义两个变量记录要查找的范围\n        int start = i;\n        int end = j;\n        //递归的出口\n        if (start > end){\n            return;\n        }\n        // 记录基准数的值\n        int baseNumber = arr[i];\n        // 利用循环找到要交换的数字   5   3  2  7  6\n        while (start != end) {\n            // 利用end，从后往前开始找，找比基准数小的数字\n            while (true) {\n                if (end <= start || arr[end] < baseNumber) {\n                    break;\n                }\n                end--;\n            }\n            // 利用start，从前往后找，找比基准数大的数字\n            while (true) {\n                if (start >= end || arr[start] > baseNumber) {\n                    break;\n                }\n                start++;\n            }\n            // 把end和start指向的元素进行交换\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n        }\n        // 当start和end指向了同一个元素的时候，那么上面的循环就会结束\n        // 表示已经找到了基准数在数组中应存的位置\n        // 基准数归位\n        //就是拿着这个范围中的第一个数字，跟start指向的元素进行交换\n        int temp = arr[start];\n        arr[start] = baseNumber;\n        arr[i] = temp;\n        //确定6左边的范围，重复刚刚所做的事情\n        quickSort(arr,i,start-1);\n        //确定6右边的范围，重复刚刚所做的事情\n        quickSort(arr,start+1,j);\n    }\n\t\t\n```\n\n## 工具类\n\n### Arrays\n\n```\n操作数组的工具类：\npublic static String toString(数组)  把数组拼接成一个字符串\npublic static int binarySearch(数组,查找的元素)\t二分法查找元素\npublic static int[] copyOf(原数组, 新数组长度)\t拷贝数组\npublic static int[] copyOfRange(原数组,起始索引，结束索引)\t拷贝数组（指定范围）\npublic static void fill(数组,元素)\t填充数组\npublic static void sort(数组)\t按照默认方式进行数组排序\npublic static void sort(数组,排序规则)\t按照指定的规则排序\n```\n\n### 数据结构（红黑树）\n\n![Snipaste_2023-03-20_08-42-16](java笔记/Snipaste_2023-03-20_08-42-16.png)\n","tags":["小结、复习"]},{"title":"Web阶段注解分析","slug":"Web阶段注解分析","url":"/posts/a85d6283/","content":"\n# @RequestParam,@PathVariable和@RequestBody三者区别\n\n#### @PathVariable\n\n~~~java\n顾名思义：路径变量，即是获取链接url路径上的变量\n  例如\n\thttp://localhost:8090/hello/2\n  代码\n//使用@PathVariable注解获取id\n@RequestMapping(\"/hello/{id}\")\npublic void method(@PathVariable Integer id) {\n\t//则   id的值为2\n}\n注意：\t路径变量名要与参数名要一致\n~~~\n\n#### @RequestParam\n\n~~~java\n顾名思义：获取参数，即是获取传送过来的参数；例如获取下面链接的id参数值\n  例如\n\thttp://localhost:8090/hello?id=2\n  代码\n//使用@RequestParam注解获取id\npublic void method(@RequestParam String id){\n    System.out.println(\"链接中请求参数的id：\"+id);\n    \n}\n//此时@RequestParam的作用就可以获取id下来并且作为形参传给方法体里面的id\n~~~\n\n#### @RequestBody注解\n\n~~~java\n首先说下，@RequestBody注解一般主要是用来处理content-type:\"application/json charset=utf-8\"或者content-type:\"application/xml charset=utf-8\"两种请求数据，一般是异步请求用的比较多些，简而言之就是json和xml。\n    例如\n//异步请求部分代码\n$.ajax({\n　　　　　url:\"/hello\",\n　　　　　type:\"POST\",\n　　　　　data:'{\"id\":\"123\",\"name\":\"Mr.Q\"}',\n　　　　　content-type:\"application/json charset=utf-8\",\n　　　　　success:function(data){\n　　　　　　　alert(data);\n　　}\n});\n\n//@RequestBody注解获取数据代码\n@RequestMapping(\"/hello\")\npublic void hello(@RequestBody Integer id,@RequestBody String name){\n　　　　System.out.println(\"id:\"+id+\";\"+\"name:\"+name);\n}\n\n//需要注意的是 如果有一个User类的话（类中包含id和name的成员变量）\n//那么代码可以写为\n@RequestMapping(\"/hello\")\npublic void hello(@RequestBody User user){\n\t// 此时user中就封装了id和name　　　　　\n}\n~~~\n\n","tags":["注解"]},{"title":"一个关于hexo提供下载的尝试","slug":"下载尝试","url":"/posts/345212/","content":"## 开始动手\n\n~~~\n步骤如下：\n\t1.修改配置文件\n\t\t修改_config.yml 里的 post_asset_folder: 这个选项设置为True\n\t2.在_post的同级目录下创建download的文件夹。\n\t3.在文章里引用文件，通过如[点击下载](/download/xx.zip)这样的链接。\n\t4.在文章中引用图片，通过 ![pic](/download/image-20191211200232715.png)这样写入。\n~~~\n\n\n\n[typora下载链接](/download/x64_Patch.zip)\n~~~\n这是一个typora的激活插件\n~~~\n[NavicatCrack下载链接](/download/NavicatCrack.zip)\n~~~\n这是一个Navicat破解的软件\n~~~\n\n\n![pic](下载尝试/2-1684200807297-1.png)","tags":["尝试"]},{"title":"web总结","slug":"web总结","url":"/posts/8ffbbb9f/","content":"\n# Day01 - HTML&CSS&JS\n\n## 1.web\t\n\n```\n什么是web？\n\t万维网，浏览器可以访问的网站\n```\n\n\n\n## 2.HTML\n\n```\n什么是HTML？\n\t超文本标记语言\n```\n\n```\nHTML的作用？\n\t控制 网页结构\n```\n\n### 2.1 HTML基础标签\n\n```\n【文本标签】\n\t标题：<h1> <h6>\n\t定义文本颜色、大小、字体：<font color=\"\" size=\"\" face=\"\">\n\t斜体：<i>\n\t加粗：<b>\n\t下划线：<u>\n\t居中：<center>\n\t段落：<p>\n\t换行：<br>\n\t水平线：<hr>\n```\n\n```\n【图片及音视频标签】\n\t图片：<img src=\"\" height=\"\" width=\"\">\n\t音频：<audio src=\"\" controls>\n\t视频：<video src=\"\" controls>\n```\n\n```\n【超链接及表格标签】\n\t超链接：<a href=\"\" target=\"\">\n\t表格：<table>\n\t\t行：<tr>\n\t\t单元格：<td>\n\t\t表头：<th>\n```\n\n```\n【布局标签】\n\t定义html中区域：<div>\n\t定义行内元素：<span>\n```\n\n\n\n\n\n### 2.2 HTML表单标签\n\n```\n【表单】：<form action=\"\" method=\"\">\n```\n\n```\n【GET和POST的区别】：\n\tGET：表单数据拼接到url后，有大小限制\n\tPOST：表单数据封装到请求体中，无大小限制\n```\n\n```\n【表单项】：\n\t<input>：表单项，通过type来控制输入形式\n\t\t文本输入框：text\n\t\t密码：password\n\t\t单选按钮：radio\n\t\t复选框：checkbox\n\t\t文件：file\n\t\t隐藏域：hidden\n\t\t提交按钮：submit\n\t\t重置按钮：reset\n\t\t可点击按钮：button\n\t<select>：下拉列表，多个<option>指定下拉列表具体内容\n\t<textarea>：文本域\n```\n\n\n\n## 3. CSS\n\n```\nCSS的作用？\n\t控制页面的样式\n```\n\n```\nCSS三种引入方式？\n\t内联方式：直接在标签中使用style属性配置样式\n\t内部方式：在head标签中使用<style>标签定义样式\n\t外部方式：在head标签中使用<link>标签引入外部css文件 从而引入样式\n```\n\n```\nCSS三种选择器\n\t元素选择器：所有使用了该标签的元素 都会适配 定义的样式 div{}\n\tid选择器：唯一，只能选择上一个元素  #id名{}\n\tclass选择器：可以选择一类元素，也就是多个元素 .class名{}\n```\n\n\n\n## 4. JS\n\n```\nJS的作用？\n\t控制网页的行为\n```\n\n```\nJS的书写语法？\n\t1.区分大小写\n\t2.行尾的可有可无 建议写上\n\t3.注释 单行注释//  多行注释 /* */\n\t4.{}代表代码块\n```\n\n```\nJS声明变量的关键字？\n\t全局变量 var\n\t局部变量 let\n\t常量 const\n```\n\n```\nJS控制语句 哪些会返回false？\n\t0、NaN、空字符串、null、undefined 都返回false，其余都返回 true\n```\n\n\n\n\n\n# Day02 - JS & Vue\n\n## 1. 函数定义\n\n```\nJS中函数定义的两种方式？\nfunction add(a,b){\n    \n}\n\nvar add = function(a,b){\n    \n}\n```\n\n\n\n## 2. JS中的对象\n\n```\n【Array】\n\t属性\n\t\t获取数组长度：length\n\t方法\n\t\t遍历数组：forEach()\n\t\t添加元素到末尾：push()\n\t\t删除元素：splice()\n```\n\n```\n【String】\n\t属性\n\t\t获取字符串长度：length\n\t方法\n\t\t获取指定角标的字符：charAt()\n\t\t获取指定字符串的索引：indexOf()\n\t\t去除字符串两端的空格：trim()\n\t\t字符串截取：subString()\n```\n\n```\n【JSON】\n\t定义json：\n\t\t1. 键值对类型\n\t\t2. 所有键都要用\"\"括起来\n\t\t3. 值：\n\t\t\tString：用\"\"括起来\n\t\t\t数字：直接写\n\t\t\tboolean：直接写true、false\n\t\t\t数组：[]\n\t\t\t对象：{}\n\tjson字符串 转json对象：JSON.parse\n\tjs对象 转 json串：JSON.Stringify()\n```\n\n```\n【BOM】浏览器对象模型\n\twindow对象的方法\n\t\t弹出警告框：alert()\n\t\t弹出对话框：confirm()\n\t\t周期执行的定时器：setInterval()\n\t\t一次性执行的定时器：setTimeout()\n\tlocation对象：\n\t\t设置或者获取url的属性：href\n```\n\n```\n【DOM】文档对象模型\n\t使用document对象获取Element元素对象\n\t\t根据id获取元素：getElementById()\n\t\t根据标签获取元素：getElementsByTagName()\n\t\t根据名称获取元素：getElementsByName()\n\t\t根据类名获取元素：getElementsByClassName()\n```\n\n\n\n## 3. 事件监听\n\n```\n如何为元素绑定事件？\n1.在html标签中 使用 事件属性 进行绑定\n<input type=\"button\" id=\"btn1\" value=\"事件绑定1\" onclick=\"on()\">\n<script>\n    function on(){\n        alert(\"按钮1被点击了...\");\n    }\n</script>\n\n2.使用DOM中的Element元素的事件属性进行绑定\n<input type=\"button\" id=\"btn2\" value=\"事件绑定2\">\ndocument.getElementById('btn2').onclick = function(){\n    alert(\"按钮2被点击了...\");\n}\n```\n\n```\n常见的事件？\n\t鼠标单击：onclick\n\t元素失去焦点：onblur\n\t元素获取焦点：onfocus\n\t页面加载完成：onload\n\t表单提交：onsubmit\n\t键盘的按键被按下：onkeydown\n\t鼠标移到元素上：onmouseover\n\t鼠标从元素上移开：onmouseout\n```\n\n\n\n## 4. Vue\n\n```\nVue常见指令的作用：\n\tv-bind：给html标签中的属性绑定数据模型\n\tv-model：双向绑定，数据模型和view\n\tv-if：条件控制，条件成立则渲染元素，条件不成立则不渲染\n\tv-show：条件控制，不管条件是否成立都会渲染元素，通过display属性控制元素是否要展示\n\tv-for：遍历\n\tv-on：绑定事件\n```\n\n\n\n```\nVue的生命周期方法：Vue挂载完成会调用哪个方法？\nmounted() vue挂载完成/页面加载完成 后会自动调用该方法\n```\n\n\n\n# Day03 - Vue&Element\n\n## 1. Ajax\n\n```\n通过Axios请求发送ajax请求 的两种方式\naxios.get(\"url\").then(result => {\n    \n})\n\naxios.post(\"url\"，\"id=1\").then(result => {\n    \n})\n```\n\n## 2. 前后端分离开发\n\n```\n好处：\n\t便于开发、便于维护\n```\n\n```\n前后端分离的开发模式是什么样的？\n\t前端开发前端代码，后端开发后端代码，后端定义接口文档（请求方式、请求路径、前后端、出参），前后端都按照接口文档进行开发即可\n```\n\n## 3. 前端工程化开发\n\n```\n前端工程化开发的步骤：\n\t1. 安装NodeJs\n\t2. 安装Vue-cli\n\t------上述为一次性操作------\n\t\n\t3. 使用Vue-cli生成vue工程\n```\n\n## 4. ElementUI\n\n```\nElementUI的作用：组件库\n\t让我们可以开发美观的前端页面\n```\n\n```\n如何进行ElementUI开发\n\t1.安装ElementUI\n\t2.在main.js文件中引入了ElementUI\n\t------上述为一次性操作------\n\t\n\t3.开发vue代码 到ElementUI官网复制粘贴\n\t\t（1）Html：template （2）js：script （3）css：style\n\t4.在App.vue中引入.vue文件\n```\n\n## 5. Vue路由\n\n```\nVue路由的作用是什么？\n\tvue路由 是一个路径管理器，它的作用是 当我们点击页面上一个按钮 后url发生变化，在页面中展示对应的视图\n```\n\n## 6. 前端工程打包部署\n\n```\n如何在Nigix服务器上部署前端代码？\n\t1. 打包前端代码，把dist里的代码复制粘贴到 nigix的html目录下\n\t2. 双击nigix.exe启动服务\n```\n\n\n\n\n\n# Day04 - Maven&SpringBootWeb入门\n\n## 1. Maven\n\n```\nMaven的作用是什么？\n\t项目管理和构建工具\n```\n\n```\nMaven的安装与配置\n\t按照文档安装配置即可。如果clean都报错，必定maven配置有问题\n```\n\n```\nMaven的仓库有哪几类？\n\t本地仓库\n\t私服\n\t中央仓库\n```\n\n```\n如何使用Maven配置依赖？如何排除依赖？\n\t<dependencies> \n\t<exclusions>\n```\n\n```\n依赖传递性\n\t如果A依赖B，B依赖C，则A依赖C\n```\n\n```\n依赖的范围有哪些？\n\tcompile（默认）\n\ttest\n\tprovided\n\truntime\n```\n\n```\nMaven常见的生命周期\n\tclean、compile、test、package、install\n```\n\n\n\n## 2.SpringBoot入门程序\n\n```\n（1）创建SpringBoot\n（2）编写请求处理器类 HelloController\n\t@RestController 代表此类是请求处理器类\n\t@RequestMapping 映射请求路径和后端方法\n（3）启动服务\n\t运行SpringBoot主启动类\n\t@SpringBootApplication 标识此类是SpringBoot的主启动类\n\n扩展：pom.xml文件\n\t<parent> 为当前pom制定了父pom，父pom中锁定了依赖的版本号，好处是减少依赖冲突\n\tstarter 起步依赖：帮我们引入了许多依赖，简化了依赖配置\n```\n\n\n\n## 3. HTTP协议\n\n```\n什么是HTTP协议？\n\t超文本传输协议，规定了浏览器和服务器之间数据传输的规则\n```\n\n```\nHTTP请求信息都有哪些部分？\n\t请求行、请求头、请求体\n```\n\n```\nHTTP响应信息都有哪些部分？\n\t响应行、响应头、响应体\n```\n\n```\nHTTP状态码分别代表什么含义？\n1 开头：处理中，临时状态\n2 开头：成功\n3 开头：重定向\n4 开头：浏览器错误\n5 开头：服务器错误\n\n常见的状态：200/404/500\n```\n\n\n\n## 4. Tomcat服务器\n\n```\n安装：解压\n启动：/bin/startup.bat\n部署项目：把项目代码复制到tomcat安装目录下的webapp目录中\n```\n\n\n\n# Day05 - SpringBootWeb请求响应\n\n## 1. PostMan\n\n```\npostman的作用？\n\t做接口测试\n```\n\n### 1.1 不同 请求类型 发送请求\n\n```\nGET：参数放在请求行的url后，使用postman放在param中\nPOST:参数放在请求体中，使用postman放在body\n```\n\n### 1.2 不同 参数类型 发送与接收请求\n\n```\n简单类型/实体类：\n\t前端：前端请求参数 和 后端形参保持一致即可\n\t后端：后端用简单类型或实体类接收，如果参数名不一致，要加 @RequestParam(name=\"前端参数名\")绑定参数\n```\n\n```\n数组/集合：\n\t前端：前端请求参数 和 后端形参保持一致；参数写多个\n\t后端：使用数组或集合接收，如果用集合接收，形参前要加一个@RequestParam绑定参数\n```\n\n```\n日期：\n\t前端：按照后端指定的日期格式进行传参\n\t后端：使用@DateTimeFormat(pattern=\"\")指定日期格式\n```\n\n```\njson格式：\n\t前端：要使用post方式，选择body-》row-》json进行传参\n\t后端：使用实体类接收，实体类前添加@RequestBody注解\n```\n\n```\n路径格式：\n\t前端：/path/1\n\t后端：在路径中使用{id}作为占位符；形参和路径中的参数变量保持一致；形参前要添加@PathVariable\n```\n\n```\n【总结】\n\t前端：\n\t\t前端请求参数 和 后端形参保持一致\n\t\tjson传参：body -》 row -》json\n\t后端：\n\t\t如果请求参数名和形参不一致 或 使用List接收数据 形参前要添加@RequestParam\n\t\t如果是日期传参，要添加 @DateTimeFormat(pattern=\"\")\n\t\t如果是json传参，要添加 @RequestBody\n\t\t如果是路径变量传参：路径要加{}占位符，形参前要添加@PathVariable\n```\n\n### 1.3 返回响应\n\n```\n返回响应需要用到哪个注解？\n\t@ResponseBody把当前方法返回值放在响应体中，如果返回值是实体类或集合，会默认转换成json格式，并放到响应体中\n```\n\n\n\n## 2.分层架构\n\n```\n三层架构中每一层的职责：\n\tcontroller：控制层 用于接收请求和返回响应\n\tservice：业务逻辑处理层\n\tdao：数据操作层（持久层）\n```\n\n```\n分层后各层之间的解耦思路\n\t高内聚低耦合\n\t内聚：单个模块内部功能联系程度，越高越好 UserController内部只处理用户相关功能，不处理其他功能\n\t耦合：各个模块之间功能联系程度，越低越好 UserController和OrderController之间依赖影响越低越好\n\t\n\t实现思路：使用Spring容器中的IOC和DI\n```\n\n```\nSpring容器的作用是什么？\n\t背景：Springboot基于Spring的框架，Spring容器是Spring的组件\n\t作用：创建并管理对象\n```\n\n## 3. IOC和DI\n\n```\n什么是IOC？（Inverse Of Controller）\n\t控制反转，反转的是对象的创建权，从程序员new对象 反转为 Spring容器 new对象\n```\n\n```\n什么是DI？\n\t依赖注入，给容器中bean的属性赋值\n```\n\n```\n声明bean的注解？（即把对象放入容器中的注解）\n@Component\n\t@Controller\n\t@Service\n\t@Repository\n```\n\n```\n依赖注入的注解?\n\t@Autowired：按照类型注入\n\t@Qualifier：按照名称注入 要和@Autowired搭配使用\n\t@Resource：按照名称注入 = @Autowired + @Qualifier\n```\n\n\n\n# Day06 - MySQL\n\n## 1. 概述\n\n```\nMysql数据库的作用\n\t存储和管理数据的仓库\n```\n\n```\nMysql数据库的使用\n安装 ：解压\n启动 ：net start mysql\n连接 ：mysql -uroot -proot\n```\n\n```\n常见Sql语句的分类\n\tDDL：数据库定义语言，对库和表进行增删改查\n\tDML: 数据库操作语言，对表中的数据进行增删改\n\tDQL: 数据库查询语言，对表中数据进行查询\n\tDCL: 数据库控制语言，用于控制权限\n```\n\n## 2.DDL\n\n```\n常见DDL语句\n【数据库】\n\t创建：create database db01;\n\t查询：show databases;\n\t使用：use db01;\n\t删除：drop database db01;\n\t创建：\n\t\tcreate table user(\n\t\t\t字段名 字段类型 [约束]  [comment '字段说明'],\n\t\t\t...\n\t\t\t字段名 字段类型 [约束]  [comment '字段说明']\n\t\t)comment '用户表';\n\t查询 掌握图形化界面使用\n\t修改\n\t删除\n```\n\n```\n约束\n\t非空约束 not null\n\t唯一约束 unique\n\t主键约束 primary key\n\t默认约束 default\n\t外键约束 foreign key\n```\n\n```\n如何根据产品原型和需求设计数据库和表结构？\n\t表结构设计：\n\t\t原型字段：需要哪些字段、字段类型、约束\n\t\t基础字段：id、create_time、update_time\n\t\t表结构：原型字段 + 基础字段\n```\n\n## 3. DML\n\n```\n新增数据：\n\tinsert into 表名(字段列表) values(字段值列表)，(字段值列表)\n```\n\n```\n修改数据：\n\tupdate 表名 set 字段名1=字段值1，字段名2=字段值2 where 条件\n```\n\n```\n删除数据：\n\tdelete from 表名 where 条件\n```\n\n\n\n# Day07 - MySQL多表\n\n## 1. DQL\n\n```\nDQL语法：\n\tselect\n\t\t字段列表\n\tfrom\n\t\t表名列表\n\twhere\n\t\t条件列表\n\tgroup by \n\t\t分组列表\n\thaving\n\t\t分组过滤条件列表\n\torder by\n\t\t排序字段列表\n\tlimit\n\t\t分页参数\n```\n\n\n\n```\n【基础查询】\n\tselect 字段列表 from 表名\n\t\n\tselect * from 表名\n```\n\n```\n【条件查询】\n比较运算符：\n\t数学运算符：> >= < <= =\n\t不等于：!=  <>\n\t范围：between and （包含最大值和最小值）\n\t列表中多选一：in()\n\t模糊查询：like\n\t\t占位符：\n\t\t\t_:一个任意字符\n\t\t\t%:0个或多个任意字符\n\t是null：is null\n逻辑运算符：\t\n\t并且：and\n\t或：or\n\t不是：not !\n```\n\n```\n【聚合】\n\t查询数量：count(*)\n\t最大值：max()\n\t最小值：min()\n\t平均值：avg()\n\t求和：sum()\n```\n\n```\n【分组】\n\tgroup by ... having\n```\n\n```\n【排序】\n\torder by\n\t排序方式：\n\t\tasc:升序 （默认）\n\t\tdesc：降序\n\t如果排序字段有多个，那么先按照第一个字段排序，如果第一个字段相等，再按照第二个字段进行排序\n```\n\n```\n【分页查询】\n\tlimit 起始索引, 每页查询数量\n\t\n\t起始索引 从0开始\n\t起始索引 = （查询页数 - 1） * 每页查询数量\n```\n\n## 2. 多表\n\n```\n表之间的关系有哪三种，分别怎么维护？\n\t一对一：任意在一个表中建立另一个表的外键\n\t一对多：在多对应的表中 建立 一对应的表的外键\n\t多对多：建立中间表，中间表中分别建立另两张表的外键\n```\n\n```\n外键的作用\n\t可以通过外键关联到另外一张表的数据\n```\n\n```\n多表设计的思路和流程\n\t1.根据需求文档和页面原型 分析 表关系\n\t2.根据需求文档和页面原型 分析 表结构\n\t\t字段、字段类型、约束\n\t3.创建表\n```\n\n\n\n# Day08 - MySQL&MyBatis入门\n\n## 1. 多表查询\n\n```\n连接查询的基础语法\n\t内连接：\n\t\t隐式内连接：\n\t\t\tselect * from 表A, 表B where 关联条件\n\t\t显式内连接：\n\t\t\tselect * from 表A\n\t\t\tjoin 表B on 关联条件\n\t外连接：\n\t\t左连接：\n\t\t\tselect * from 表A\n\t\t\tleft join 表B on 关联条件\n```\n\n```\n内连接和外连接的区别？\n\t内连接：取两张表的交集\n\t外连接：取左表的全部数据 和 右表能关联上的数据\n```\n\n```\n子查询\n\t标量子查询：常量 = < <= > >=\n\t列子查询：子查询结果只有一列，可以认为是一个列表   in\n\t行子查询：子查询结果只有一行 \n\t表子查询：子查询结果是一张临时表，可以把子查询结果当做一张临时表使用\n```\n\n```\n如何完成多表查询操作？\n\t1. 分析要查询哪些字段\n\t2. 看这些字段在哪些表中\n\t3. 分析表之间的关联条件\n\t4. 查看是否有其他条件\n```\n\n## 2. 事务\n\n```\n什么是事务？\n\t事务是多个操作的集合，这些操作要么同时成功，要么同时失败\n```\n\n```\n如何开启事务、提交事务、回滚事务？\n\t开启事务：start transation; / begin;\n\t提交事务：commit;\n\t回滚事务：rollback;\n```\n\n```\n事务的四大特性是什么？\n\t原子性、一致性、隔离性、持久性\n```\n\n## 3. 索引\n\n```\n什么是索引？\n\t是一种提高查询效率的数据结构，B+Tree(多路平衡搜索树)\n\t优点：提高查询效率和排序效率\n\t缺点：占用空间，数据增删改的时候维护索引需要性能开销\n```\n\n```\n索引的操作\n\t创建：create index 索引名 on 表名(字段名)\n\t删除：drop index 索引名 on 表名\n\t查询：show index from 表名\n```\n\n```\nMySQL数据库索引的数据结构\n\tB+Tree(多路平衡搜索树)\n\t\t（1）每个节点上有多个key，也就有多路分支\n\t\t（2）所有数据都存储在叶子节点，非叶子节点只存储索引\n\t\t（3）叶子节点是天然有序的双向链表，便于数据的排序和范围查询\n```\n\n## 4. Mybatis入门\n\n~~~\nSpringBoot-Mybatis入门程序\n\t1. 准备工作：创建数据库和表，创建了工程，user实体类\n\t2. 在application.properties中 配置数据库连接：驱动、url、username、password\n\t3. 编写Mapper接口，@Mapper @Select(\"select * from user\")\n\t4. 测试\n~~~\n\n~~~\n什么是数据库驱动？\n\tjava程序连接数据库的工具\n~~~\n\n```\n什么是JDBC ？\n\tJDBC是用于操作 数据库驱动这个工具 的API接口\n```\n\n~~~\n数据库连接池的作用？\n\t数据库连接池 是一个容器，用于创建、管理数据库连接\n~~~\n\n\n\n# Day09 - Mybatis\n\n## 1. Mybatis基础操作\n\n~~~\n预编译SQL的优势是什么？\n\t更高效：把预编译的sql缓存了起来\n\t更安全：防止sql注入，把密码当做一整个字符串传入sql语句，如果密码中有引号，会进行转义\n~~~\n\n~~~\n参数占位符${} 与 #{}的区别\n\t${}：直接把参数拼装到sql中，不能防止sql注入\n\t#{}：使用预编译的方式 把参数做为一个整体 替换 ?, 可以防止sql注入\n~~~\n\n```\nmybatis开发增删改查接口分别使用哪个注解？\n\t增：@Insert\n\t删：@Delete\n\t改：@Update\n\t查：@Select\n```\n\n```\n新增数据如何获取到主键?\n\t@Options(useGeneratedKeys = true, keyProperty = \"id\")\n```\n\n\n\n\n\n## 2. 基于XML开发Mybatis\n\n```\nMybatis中XML映射文件的开发规范\n\t1.同包同名: xml文件和mapper文件的包名、文件名保持一致\n\t2.xml的namespace 和 mapper的全限定类名保持一致\n\t3.xml中的id 和 mapper的方法名保持一致\n只有按照这个格式开发，将来调用到mapper中的方法，才能找到xml文件中对应的sql语句\n```\n\n```\n<if>标签的作用和用法\n\t作用：如果if标签中条件成立，则拼接sql，否则不拼接\n\t用法：<if test=\"name != null\">\n```\n\n```\n<where>和<set>标签的应用场景和作用\n\t应用场景：\n\t\t<where>条件查询 <set>update更新的时候使用\n\t作用：\n\t\t<where>：动态拼接 where，去除多余的AND/OR\n\t\t<set>: 动态拼接set，去除多余的逗号\n```\n\n```\n<foreach>标签的用法\n\t<foreach colletion=\"ids\" item=\"id\" separator=\",\" open=\"(\" close=\")\">\n\t\t#{id}\n\t</foreach>\n```\n\n```\n<sql>和<include>的作用\n\t<sql id=\"aaa\">：抽取公共的sql片段\n\t<include refid=\"aaa\">：使用sql片段\n```\n\n\n\n# Day10 - SpringBootWeb\n\n```\nREST风格\n\t请求路径 + 请求方式 唯一确定一个后端方法\n\t\t\n\t增：POST     /users\n\t删：DELETE   /users/1   \n\t改：PUT      /users\n\t查：GET      /users/1\n\t查全部：GET   /users\n```\n\n\n\n# Day11 - SpringBootWeb - 案例2\n\n## 1. 文件上传\n\n### 1.1 本地文件上传\n\n```\n文件上传 前端页面三要素\n(1) 表单提交方式 必须是 POST\n(2) 表单的encType属性值 必须是 mutipart/form-data\n(3) 表单项的type属性值 必须是 file\n```\n\n```\n文件上传 后端接收文件二要素\n（1）形参类型必须是 MutipartFile\n（2）形参名必须和表单项名称保持一致\n```\n\n### 1.2 阿里云OSS文件上传\n\n```\n文件上传：\n\t1. 注册账号，创建Bucket、AKSK\n\t2. 导入依赖，导入阿里云文件上传工具类 \n\t3. 编写文件上传代码 形参类型为MutipartFile，形参名是image 和前端请求参数保持一致，再调用文件上传工具类即可\n```\n\n\n\n## 2. YML\n\n```\nYML文件的语法格式\n\t（1）以冒号结尾\n\t（2）属性值 和 属性名之间用冒号连接，冒号和属性值之间一定要加一个空格\n\t（3）用空格缩进表示层级关系\n```\n\n```\n读取YML文件的配置信息\n\t@Value：读取配置文件中的值，读取单个属性\n\t@ConfigurationProperties(prefix=\"aliyun.oss\")：读取配置文件中的值到实体类中 批量读取属性\n```\n\n\n\n# Day12 - Web登录认证\n\n## 1.会话技术\n\n```\n什么是会话？\n\t一个浏览器和一个服务器建立一次连接的过程就是一次会话，浏览器或服务器断开连接则会话结束。一次会话中可以有多次请求\n```\n\n```\n会话跟踪技术的作用？\n\t在一次会话的多次请求间共享数据\n```\n\n```\n会话跟踪技术有哪些？\n\tcookie：客户端会话跟踪技术\n\tsession：服务端会话跟踪技术\n```\n\n```\ncookie的原理\n\t多次请求 携带的是同一个 cookie，就在客户端实现了数据共享\n\n缺点：\n\t不能在移动端使用\n\t不安全，因为用户可以禁用cookie\n\t不能跨域\n\t\n【跨域】：\n\t判断两次请求中 协议、ip/域名、端口号 是否不一致，如果不一致则跨域了\n```\n\n```\nsession的原理\n  多次请求在cookie中携带的是同一个sessionId，就能在服务器中找到同一个session，就实现了服务端的数据共享\n\n缺点：\n\t集群中不能使用session共享数据\n\tcookie的所有缺点（因为session是基于cookie实现的）\n```\n\n```\nJWT令牌的三个组成部分\n\theader：令牌类型 和 签名算法\n\tpayload：自定义数据\n\tsignature：签名\n```\n\n```\nJWT令牌的生成和校验\n\t使用Jwts工具类 生成令牌和校验令牌\n```\n\n```\n登录校验中使用令牌\n\t令牌生成：登录成功后 生成令牌 并返回给前端\n\t令牌校验：（除了登录之外的）每次请求都需要校验令牌，统一拦截校验\n```\n\n\n\n## 2. Filter 过滤器\n\n```\n过滤器的作用：\n\t拦截请求 并在放行前后 做一些逻辑处理\n```\n\n```\n过滤器入门程序\n\t1.定义 实现 Filter接口\n\t2.添加注解\n\t\t@WebFilter(urlPatterns=\"/*\")\n\t\t@ServletComponentScan //开启Servlet组件扫描，只有开启了才能扫描到@WebFilter\n```\n\n```\n过滤器的执行流程\n\t1. 放行前逻辑\n\t2. 放行\n\t3. 执行目标方法\n\t4. 放行后逻辑\n```\n\n```\n登录校验过滤器的作用\n\t统一拦截所有请求，并判断令牌的合法性，如果合法则放行，如果并不合法，则返回NOT_LOGIN\n```\n\n\n\n## 3. Interceptor 拦截器\n\n```\n拦截器的入门程序\n \t1.定义拦截器 实现HandlerInterceptor，并重写preHandler、postHander、AfterComplection\n \t2.注册拦截器 定义配置类，并实现WebMvcConfiguer，并添加 @Configuration\n```\n\n```\n拦截器的执行顺序\n\tpreHandler\n\t\treturn true \n\t\t\t执行目标方法\n\t\t\tpostHander\n\t\t\tAfterComplection\n\t\treturn false\n\t\t\t拦截请求\n```\n\n```\n过滤器和拦截器的区别\n\t1. 如果过滤器和拦截器同时存在，那么请求先进入过滤器，过滤器放行再进入拦截器\n\t2. 过滤器实现Filter接口，拦截器实现 HandlerInterceptor接口\n\t3. 过滤器拦截所有请求，拦截器只拦截controller\n\t4. 实现原理不同：过滤器基于回调实现，拦截器基于反射实现\n```\n\n\n\n## 4. 全局异常处理器\n\n```\n定义全局异常处理器\n\t@RestControllerAdvice：放在类上，标明此类是一个异常处理器类\n\t@ExceptionHandler(Exception.class)：放在方法上，指定当前方法捕获哪一类异常\n```\n\n\n\n\n\n# Day13 - 事务管理 & AOP\n\n## 1. 事务\n\n```\n如何在Spring中完成事务管理\n\t@Transactional\n```\n\n```\n事务属性 rollback的作用\n\t指定哪些异常要回滚，一般指定所有异常都要回滚\n```\n\n```\n事务传播行为propagation的作用\n\tpropagation: 控制事务传播行为，当业务层方法之间相互调用发生事务嵌套时，内层事务是否要和外层同成功同失败\n\t- REQUIRED：默认内外层使用同一个事物，同成功同失败\n\t- REQUIRES_NEW：内外层事务之间互不影响\n```\n\n\n\n## 2. AOP\n\n```\n什么是AOP？\n\t面向切面编程\n```\n\n```\nAOP的作用？\n\t在不改变原始代码的基础上进行功能增强\n```\n\n```\nAOP的核心概念\n\t连接点：所有可以进行功能增强的方法都是连接点\n\t切入点：进行了功能增强的方法就是切入点\n\t通知：共性功能\n\t切面：切入点 + 通知\n\t目标对象：通知所应用的对象就是目标对象\n\t切入点表达式：指定哪些方法是切入点\n```\n\n```\nAOP常见通知类型\n\t前置通知：@Before\n\t后置通知：@After\n\t环绕通知：@Around\n\t返回后通知：@AfterReturning\n\t异常后通知：@AfterThrowing\n```\n\n```\n切入点表达式的写法\n\t写法一：@PointCut(\"execution(访问修饰符 返回值 包名.类名.方法名(参数))\")\n\t\t通配符：\n\t\t\t* 单个或半个任意符号 多用于模糊匹配\n\t\t\t.. 多个连续任意符号 多用于参数省略或包名省略\n\t写法二：@PointCut(\"@annotation(注解的全路径类名)\")\n```\n\n```\n通过连接点对象获取目标方法的信息\n\t获取类名：joinPoint.getTarget().getClass().getName()\n\t获取方法名：joinPoint.getSignature().getName()\n\t获取参数：joinPoint.getArgs()\n\t执行目标方法：joinPoint.proceed()\n\t获取返回值：Object result = joinPoint.proceed()\n```\n\n\n\n# Day14 - 自动配置原理\n\n## 1. 配置文件\n\n```\nSpringboot配置文件的优先级\n\tproperties、yml、yaml\n```\n\n```\nSpringBoot的jar包启动\n\tjava -jar xxx.jar \n```\n\n## 2. 管理bean\n\n```\n手动从容器中获取bean\n\tapplicationContext.getBean(\"\")\n```\n\n```\n设置bean的作用域\n\t@Scope\n\t\tsingleton：单例\n\t\tprototype：非单例\n```\n\n```\n@Bean注解的作用\n\t管理第三方bean时使用，作用是：把当前方法的返回值放到Spring容器中\n```\n\n## 3. 自动配置原理\n\n```\n自动配置\n\t在容器启动的时候，自动把一些配置类或bean放到Spring容器中，这些不需要我们手动操作，只需要拿来即用即可\n```\n\n```\n自动配置原理：\n\t在主启动类的核心注解里，有一个自动配置注解@EnableAutoConfiguration，这个注解会自动扫描spring.factories和AutoConfiguration.imports这两个文件，文件内部定义了一些xxxAutoConfiguration，里边使用了@Bean注解把对象放到Spring容器中\n\t\n自动配置注解：@EnableAutoConfiguration\n自动配置文件：spring.factories 和 AutoConfiguration.imports 文件\n自动配置类：xxxAutoConfiguration（@Bean）\n```\n\n```\n@Import注解的作用\n\t把类对应的对象导入到容器中\n```\n\n```\n@Conditional注解的作用\n\t满足条件的bean才会被放到Spring容器中\n```\n\n```\n@Conditional衍生注解\n\t@ConditionalOnClass：环境中存在该字节码对象 才会把bean放到Spring容器中\n\t@ConditionalOnMissingBean：容器中不存在当前bean，才会把bean放到Spring容器中\n\t@ConditionalOnProperty：配置文件中存在指定的属性名和属性值，才会把bean放到Spring容器中\n```\n\n```\n如何自定义starter\n\t1. 编写依赖管理模块（starter），引入依赖即可\n\t2. 编写自动配置模块（autoConfiguer），在starter中引入autoConfiguer模块\n\t3. 在自动配置模块中编写 \n\t\t\t自动配置文件（META-INF/spring/xxxAutoConfiguration.imports）\n\t\t\t自动配置类 （在xxxAutoConfiguration使用@Bean注解把类对应的对象放到Spring容器中）\n```\n\n\n\n# Day15 - MybatisPlus\n\n## 1. 入门案例\n\n```\n入门案例步骤\n\t1. 准备工作：数据库表、创建模块（导入依赖、修改配置文件中的数据库连接信息、添加实体类）\n\t2. 编写UserDao, 继承BaseMapper<User>, 添加@Mapper\n\t3. 测试\n```\n\n\n\n## 2. 标准CRUD操作\n\n```\n新增：insert\n根据id删除：deleteById\n根据id修改：updateById\n根据id查询: selectById\n查列表： selectList\n查分页：selectPage  添加分页拦截器\n\n查询投影：selectMaps\n```\n\n\n\n## 3. 按条件查询\n\n```\n>\tgt\n>=\tge\n<\tlt\n<=\tle\n=\teq\n范围查询：between and\n模糊查询：like\n包含：in\n```\n\n\n\n## 4. 批量操作\n\n```\n根据id批量查询：selectBatchById\n根据id批量删除：deleteBatchById\n```\n\n\n\n## 5. 兼容性匹配\n\n```\n数据库表名 和 实体类名不一致：@TableName\n数据库字段名 和 实体类属性名不一致：@TableField(value=\"\")\n设置不查询某字段：@TableField(select=false)\n设置实体类属性名在数据库中不存在：@TableField(exist=false)\n```\n\n\n\n## 6. id生成策略\n\n```\nid生成策略注解：@TableId\n全局配置：id-type\n```\n\n```\nid生成策略有哪些？\n\tAuto、Assign-id\n```\n\n\n\n## 7. 逻辑删除\n\n```\n逻辑删除注解：\n\t@TableLogic(value=\"0\"，delval=\"1\")\n\n步骤：\n\t1.添加字段\n\t2.添加注解\n```\n\n\n\n## 8. 乐观锁\n\n```\n步骤：\n\t1.添加字段 version 和 添加 @Version注解\n\t2.添加乐观锁拦截器\n\t3.查询数据库中的数据和版本号，调用修改操作，把要修改的数据和刚才查询出来的版本号都设置进去\n```\n\n\n\n\n\n# Day16 - Maven高级\n\n## 1. 分模块开发\n\n```\n分模块开发的好处？\n\t解耦、便于开发、便于维护、便于复用\n```\n\n```\n如何分模块开发？\n\t水平拆分：分层拆分\n\t垂直拆分：按业务拆分\n```\n\n```\n如何在A模块中使用B模块？\n\t<dependency>引入即可\n```\n\n\n\n## 2. 继承\n\n```\n继承的作用？\t\n\t简化了依赖配置\n```\n\n```\n如何实现继承？\n\t1. 在父pom文件中设置打包方式为pom  <packaging>pom</packaging>\n\t2. 在子模块中使用<parent>标签设置父模块\n```\n\n```\n<dependencyManagement>和<dependencies>的区别\n\t<dependencyManagement>：锁定版本号，并没有真正引入依赖。可以减少依赖冲突\n\t<dependencies>: 真正引入依赖\n```\n\n```\n<properties>标签的作用？\n\t配置pom文件中的属性/变量，使用变量${}\n```\n\n\n\n## 3. 聚合\n\n```\n聚合的作用？\n\t构建聚合工程的时候，子工程也会跟着构建\n```\n\n```\n如何用聚合实现多工程统一构建？\n\t在聚合工程中使用<modules>设置聚合工程有几个子工程\n```\n\n```\n聚合和继承的区别？\n\t继承：子模块继承父模块的依赖和配置，在子模块中配置继承关系\n\t聚合：工程的统一构建，在聚合工程中配置聚合关系\n```\n\n\n\n## 4. 私服\n\n```\n私服的作用？\n\t团队间的资源共享\n```\n\n```\n下载：在setting.xml中配置 用户名密码(<server>)、私服仓库的镜像（<mirrors> url）\n上传：在pom.xml文件中配置私服的url路径，点击 install、deploy就可以上传依赖到私服了\n```\n\n\n\n","tags":["web"]},{"title":"面试题库","slug":"面试题库","url":"/posts/c5e9cf91/","content":"\n# 面试题小结\n\n# 1 内存结构\n\n> ### 1、简述一下JVM的内存结构？(高频)\n\nJVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有\n\n区和共享区。\n\n| <img src=\"面试题库/image-20220216222845410.png\" alt=\"image-20220216222845410\" style=\"zoom: 50%;\" /> |\n| ------------------------------------------------------------ |\n\n**线程私有区**：\n\n① 程序计数器\n\n* 作用：是一块较小的内存空间，可以理解为是当前线程所执行程序的字节码文件的行号指示器，存储的是当前线程所执行的**行号**\n* 特点：线程私有 ，唯一一个不会出现内存溢出的内存空间\n\n② 虚拟机栈\n\n* 作用：管理JAVA方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法中变量的变量表、操作数栈、动态链接方法、返回值、返回地址\n\n  等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）\n\n| ![image-20220205133550896](面试题库/image-20220205133550896.png) |\n| ------------------------------------------------------------ |\n\n* 特点：\n\n  1、线程私有\n\n  2、局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）以及对象引用（reference 类\n\n  型）\n\n  3、栈太小或者方法调用过深，都将抛出StackOverflowError异常\n\n* 测试代码\n\n```java\npublic class StackDemo02 {\n\n    // 记录调用了多少次出现了栈内存溢出\n    private static int count = 0 ;\n\n    // 入口方法\n    public static void main(String[] args) {\n\n        try {\n            show() ;\n        }catch (Throwable e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"show方法被调用了:\" + count + \"次\");\n\n    }\n\n    // 测试方法\n    public static void show() {\n        count++ ;\n        System.out.println(\"show方法执行了.....\");\n        show();\n    }\n\n}\n```\n\n配置虚拟机参数-Xss可以指定栈内存大小；例如：-Xss180k\n\n栈内存的默认值问题：\n\n```java\nThe default value depends on the platform: \n* Linux/x64 (64-bit): 1024 KB \n* macOS (64-bit): 1024 KB \n* Oracle Solaris/x64 (64-bit): 1024 KB \n* Windows: The default value depends on virtual memory\n```\n\n③ 本地方法栈：与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。\n\n**线程共享区**：\n\n① 堆内存\n\n* 作用：是Java内存区域中一块用来存放对象实例的区域，新创建的对象，数组都使用堆内存；【从Java7开始，常量池也会使用堆内存】\n\n| <img src=\"面试题库/image-20220216224408053.png\" alt=\"image-20220216224408053\" style=\"zoom:50%;\" /> |\n| ------------------------------------------------------------ |\n\nJava 堆从GC的角度还可以细分为: 新生代( Eden区 、From Survivor区和 To Survivor区 )和老年代。\n\n* 特点：\n\n  1、被线程共享，因此需要考虑线程安全问题\n\n  2、会产生内存溢出问题\n\n* 测试代码：\n\n```java\npublic class HeapDemo01 {\n\n    public static void main(String[] args) {\n\n        // 定义一个变量\n        int count = 0 ;\n\n        // 创建一个ArrayList对象\n        ArrayList arrayList = new ArrayList() ;\n\n        try {\n\n            while(true) {\n                arrayList.add(new Object()) ;\n                count++ ;\n            }\n\n        }catch (Throwable a) {\n            a.printStackTrace();\n            // 输出程序执行的次数\n            System.out.println(\"总共执行了:\" + count + \"次\");\n        }\n\n    }\n\n}\n```\n\n* 虚拟机参数：\n\n​\t-Xms\t设置最小堆内存大小(不能小于1024K); \t-Xms 堆内存初始大小，可以通过jmap工具进行查看\n\n​\t-Xmx\t设置最大堆内存大小(不能小于1024K);     -Xmx 堆内存最大值，可以通过jmap工具进行查看\n\n​\t例如：-Xms1024K -Xmx2048K\n\n\n\n② 方法区\n\n* 作用：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n\n* 特点：\n\n  1、方法区是一块线程共享的内存区域\n\n  2、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出的错误\n\n  3、jdk1.6和jdk1.7方法区也常常被称之为永久区(永久代),大小一般都是几百兆；\n\n  4、jdk1.8已经将方法区取消，替代的是元数据区(元空间),如果不指定大小，默认情况下，虚拟机会耗尽可用系统内存\n\n  5、jdk7以后就将方法区中的常量池移动至**堆内存**\n\n| ![image-20220205140202778](面试题库/image-20220205140202778.png) |\n| ------------------------------------------------------------ |\n\n​\t变化的原因：\n\n​\t\t1、提高内存的回收效率(方法区内存的回收效率远远低于堆内存，因为方法去中存储的都是类信息，静态变量...这些信息不能被轻易回收)\n\n​\t\t2、字符串常量池在方法区，那么很容易产生内存溢出(因为方法区的垃圾回收效率比较低);\n\n* 测试代码\n\n```java\n/**\n\tjdk1.8的元数据区可以使用参数-XX:MaxMetaspaceSzie设定大小\t\n * 演示元空间内存溢出\n * -XX:-UseCompressedClassPointers -XX:MaxMetaspaceSize=10m\n \tUseCompressedClassPointers使用指针压缩，如果不使用这个参数可能会出现: Compressed class space内存溢出\n */\npublic class MaxMetaspaceDemo extends ClassLoader {\t\t\t\t// 当前这个类就是一个类加载器\n    \n    public static void main(String[] args) {\n        \n        // 定义变量，记录程序产生类的个数\n        int j = 0;\n        \n        try {\n            \n            MaxMetaspaceDemo test = new MaxMetaspaceDemo();\n            \n            for (int i = 0; i < 10000; i++, j++) {\n                \n                // 字节码写入器\n                ClassWriter cw = new ClassWriter(0);\n                \n                // 定义一个类版本为Opcodes.V1_1，它的访问域为public，名称为Class{i},父类为java.lang.Object，不实现任何接口\n                cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, \"Class\" + i, null, \"java/lang/Object\", null);\n                byte[] code = cw.toByteArray();\n                \n                // 加载该类\n                test.defineClass(\"Class\" + i, code, 0, code.length);\n            }\n        } finally {\n            System.out.println(j);\n        }\n    }\n}\n```\n\n> ### 2、堆和栈的区别？(高频)\n\n① 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储\n\n在堆内存中。\n\n② 共享性不同：栈内存是线程私有的。堆内存是所有线程共有的。\n\n③ 异常错误不同：如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：\n\njava.lang.OutOfMemoryError。\n\n④ 空间大小：栈的空间大小远远小于堆的。\n\n> ### 3、怎么获取Java程序使用的内存？堆使用的百分比？\n\n可以通过java.lang.Runtime类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余\n\n空间。\n\n1、Runtime.freeMemory() 方法返回剩余空间的字节数\n\n2、Runtime.totalMemory()方法总内存的字节数\n\n> ### 4、栈帧都有哪些数据？\n\n栈帧包含：局部变量表、操作数栈、动态连接、返回值、返回地址等。\n\n> ### 5、如何启动系统的时候设置jvm的启动参数？\n\n其实都很简单，比如说采用\"java -jar\"的方式启动一个jar包里面的系统，那么就可以才用类似下面的格式：\n\n| ![image-20220205141640067](面试题库/image-20220205141640067.png) |\n| ------------------------------------------------------------ |\n\n# 2 垃圾回收\n\n> ### 6、如何判断一个对象是否为垃圾？(高频)\n\n两种算法：\n\n**① 引用计数法**：堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被\n\n赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，\n\n对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。\n\n特点：简单、无法解决循环引用问题\n\n定义学生类：\n\n```java\npublic class Student {\n\n    // 定义成员变量\n    public Object instance ;\n\n}\n```\n\n编写测试类：\n\n```java\n/*\n\tjvm参数：-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps\n\t-verbose:gc -XX:+PrintGCDetails：打印gc日志信息\n\t-XX:+PrintGCTimeStamps: 打印gc日志的时间戳\n*/\npublic class ReferenceCountGcDemo {\n\n    public static void main(String[] args) {\n\n        // 创建Student对象\n        Student a = new Student() ;\n        Student b = new Student() ;\n\n        // 进行循环引用\n        a.instance = b ;\n        b.instance = a ;\n\n        // 将a对象和b对象设置为null\n        a = null ;\n        b = null ;\n\n        // 调用System.gc进行垃圾回收\n        System.gc();                    // 如果没有触发垃圾回收说明Hotspot的jvm使用的就是引用计数法来判断对象是否为垃圾\n\n    }\n\n}\n```\n\n控制台输出gc日志:\n\n```java\n0.076: [GC (System.gc()) [PSYoungGen: 7802K->856K(151552K)] 7802K->864K(498688K), 0.0008493 secs] [Times: user=0.17 sys=0.02, real=0.00 secs] \n0.077: [Full GC (System.gc()) [PSYoungGen: 856K->0K(151552K)] [ParOldGen: 8K->620K(347136K)] 864K->620K(498688K), [Metaspace: 3356K->3356K(1056768K)], 0.0044768 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \nHeap\n PSYoungGen      total 151552K, used 3901K [0x0000000716c00000, 0x0000000721500000, 0x00000007c0000000)\n  eden space 130048K, 3% used [0x0000000716c00000,0x0000000716fcf748,0x000000071eb00000)\n  from space 21504K, 0% used [0x000000071eb00000,0x000000071eb00000,0x0000000720000000)\n  to   space 21504K, 0% used [0x0000000720000000,0x0000000720000000,0x0000000721500000)\n ParOldGen       total 347136K, used 620K [0x00000005c4400000, 0x00000005d9700000, 0x0000000716c00000)\n  object space 347136K, 0% used [0x00000005c4400000,0x00000005c449b318,0x00000005d9700000)\n Metaspace       used 3365K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 370K, capacity 388K, committed 512K, reserved 1048576K\n```\n\n\n\n```java\n① 0.076: 代表gc发生的时间，从jvm启动以来经过的秒数\n② [GC和[Full Gc: 说明这次垃圾收集器的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有\"Full\"，说明此次GC发生了stop-the-world。System.gc()是说明显示的调用了\t\t\t\t   System.gc方法进行垃圾回收\n③ [PSYoungGen：表示GC发生的区域, 不同的垃圾收集器展示的区域名称不一样，PSYoungGen表示的是新生代，这里默认使用的是Parallel Scavenge收集器 (-XX:+UseSerialGC)\n④ 7802K->856K(151552K)：GC前该区域已使用容量 -> GC后该区域已使用容量(该区域的总容量)\n⑤ 7802K->864K(498688K)：GC前Java堆已使用容量 -> GC后Java堆已使用容量(Java堆总容量)\n⑥ 0.0008493 secs：该区域GC所占用的时间\n⑦ [Times: user=0.17 sys=0.02, real=0.00 secs]: 分别表示用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间(墙钟时间包括非运算的等待耗时)。多线程操作会叠加这些CPU时间，所以user、sys时间超过real时间是完全正常的。  \n```\n\n**② 可达性分析算法 **： 可达性分析算法又叫做**跟搜索法**，就是通过一系列的称之为\"GC Roots\"的对象作为起始点，从这些节点开始向下搜索，搜索走过的\n\n路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。\n\n(类似于葡萄串)；\n\n| ![image-20220205142506230](面试题库/image-20220205142506230.png) |\n| ------------------------------------------------------------ |\n\n> ### 7、可达性算法中，哪些对象可作为GC Roots对象？(高频)\n\n可以作为GC ROOTS对象的情况：\n\n1、虚拟机栈中引用的对象\n\n2、方法区静态成员引用的对象\n\n3、方法区常量引用对象\n\n4、本地方法栈引用的对象\n\n> ### 8、Java中都有哪些引用类型？(高频)\n\n**① 强引用**\n\nJava中默认声明的就是强引用，比如：\n\n```java\nObject obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收\nobj = null;  //手动置null\n```\n\n只要**强引用存在，垃圾回收器将永远不会回收被引用的对象**，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引\n\n用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了\n\n示例：\n\n```java\n/**\n * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M\n */\npublic class StrongReferenceDemo01 {\n\n    private static List<Object> list = new ArrayList<Object>() ;\n\n    public static void main(String[] args) {\n\n        // 创建对象\n        for(int x = 0 ;  x < 10 ; x++) {\n            byte[] buff = new byte[1024 * 1024 * 1];\n            list.add(buff);\n        }\n\n\n    }\n\n}\n```\n\n**② 软引用**\n\n软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回**\n\n**收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常**。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。\n\n在 JDK1.2 之后，用java.lang.ref.**SoftReference**类来表示软引用。\n\n示例代码：\n\n```java\n/**\n * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M\n */\npublic class SoftReferenceDemo01 {\n\n    private static List<Object> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n\n        // 创建数组对象\n        for(int x = 0 ; x < 10 ; x++) {\n            SoftReference<byte[]> softReference = new SoftReference<byte[]>(new byte[1024 * 1024 * 1]) ;\n            list.add(softReference) ;\n        }\n\n        System.gc();  // 主动通知垃圾回收器进行垃圾回收\n        \n        for(int i=0; i < list.size(); i++){\n            Object obj = ((SoftReference) list.get(i)).get();\n            System.out.println(obj);\n        }\n        \n    }\n\n}\n```\n\n我们发现无论循环创建多少个软引用对象，打印结果总是有一些为null，这里就说明了在内存不足的情况下，软引用将会被自动回收。\n\n**③ 弱引用**\n\n弱引用的引用强度比软引用要更弱一些，**无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收**。在 JDK1.2之后,用\n\njava.lang.ref.WeakReference来表示弱引用。\n\n示例代码：\n\n```java\n/**\n * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M\n */\npublic class WeakReferenceDemo01 {\n\n    private static List<Object> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n\n        // 创建数组对象\n        for(int x = 0 ; x < 10 ; x++) {\n            WeakReference<byte[]> weakReference = new WeakReference<byte[]>(new byte[1024 * 1024 * 1]) ;\n            list.add(weakReference) ;\n        }\n\n        System.gc();  // 主动通知垃圾回收器进行垃圾回收\n\n        for(int i=0; i < list.size(); i++){\n            Object obj = ((WeakReference) list.get(i)).get();\n            System.out.println(obj);\n        }\n        \n    }\n\n}\n```\n\n**④ 虚引用**\n\n虚引用是最弱的一种引用关系，如果**一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收**，在 JDK1.2 之后，用 \n\nPhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是\n\n说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。\n\n```java\npublic class PhantomReference<T> extends Reference<T> {\n\n    /**\n     * Returns this reference object's referent.  Because the referent of a\n     * phantom reference is always inaccessible, this method always returns\n     * <code>null</code>.\n     *\n     * @return  <code>null</code>\n     */\n    public T get() {\n        return null;\n    }\n\n    /**\n     * Creates a new phantom reference that refers to the given object and\n     * is registered with the given queue.\n     *\n     * <p> It is possible to create a phantom reference with a <tt>null</tt>\n     * queue, but such a reference is completely useless: Its <tt>get</tt>\n     * method will always return null and, since it does not have a queue, it\n     * will never be enqueued.\n     *\n     * @param referent the object the new phantom reference will refer to\n     * @param q the queue with which the reference is to be registered,\n     *          or <tt>null</tt> if registration is not required\n     */\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n\n}\n```\n\n特点：\n\n1、每次垃圾回收时都会被回收，主要用于监测对象是否已经从内存中删除\n\n2、虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中\n\n3、程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那\n\n么就可以在所引用的对象的内存被回收之前采取必要的行动\n\n示例代码：\n\n```java\npublic class PhantomReferenceDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // 创建一个引用队列\n        ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();\n        \n        // 创建一个虚引用，指向一个Object对象\n        PhantomReference<Object> phantomReference = new PhantomReference<Object>(new Object(), referenceQueue);\n        \n        // 主动通知垃圾回收器进行垃圾回收\n        System.gc();\n        \n        // 从引用队列中获取元素, 该方法是阻塞方法\n        System.out.println(referenceQueue.remove()); \n\n    }\n}\n```\n\n> ### 9、常见的垃圾回收算法都有哪些？(高频)\n\n**① 标记清除**\n\n执行过程：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n\n| ![image-20220205143116277](面试题库/image-20220205143116277.png) |\n| ------------------------------------------------------------ |\n\n优点：速度比较快\n\n缺点：会产生内存碎片，碎片过多，仍会使得连续空间少\n\n**② 标记整理**\n\n执行过程：首先标记出所有需要回收的对象，在标记完成后统一进行整理，整理是指存活对象向一端移动来减少内存碎片，相对效率较低\n\n| ![image-20220205143213301](面试题库/image-20220205143213301.png) |\n| ------------------------------------------------------------ |\n\n优点：无内存碎片\n\n缺点：效率较低\n\n**③ 复制算法**\n\n执行过程：开辟两份大小相等空间，一份空间始终空着，垃圾回收时，将存活对象拷贝进入空闲空间；\n\n| ![image-20220205143344612](面试题库/image-20220205143344612.png) |\n| ------------------------------------------------------------ |\n\n优点：无内存碎片\n\n缺点：占用空间多\n\n注意：如果有很多对象的存活率较高，这时我们采用复制算法，那么效率就比较低；\n\n**④ 分代回收**\n\n概述：根据对象存活周期的不同，将对象划分为几块，比如Java的堆内存，分为新生代和老年代，然后根据各个年代的特点采用最合适的算法；\n\n新生代对象的存活的时间都比较短，因此使用的是【复制算法】；而老年代对象存活的时间比较长那么采用的就是【标记清除】或者【标记整理】；\n\n> ### 10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？\n\n在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下\n\n是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回\n\n收。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。\n\n# 3 对象分配\n\n> ### 11、对象在内存中是如何进行分配的？(高频)\n\n**① 对象优先在Eden分配**：对象优先在『伊甸园』分配，当『伊甸园』没有足够的空间时，触发 'Minor GC'(小范围的GC)\n\n情况一：伊甸园的内存空间足够，不会发生'Minor GC'\n\n<img src=\"面试题库/image-20211121234732699.png\" alt=\"image-20211121234732699\" style=\"zoom: 50%;\" /> \n\n情况二：伊甸园的空间不够了\n\n<img src=\"面试题库/image-20211121234819672.png\" alt=\"image-20211121234819672\" style=\"zoom: 50%;\" /> \n\n垃圾回收线程启动，进行垃圾回收，此时会触发\"stop the world\"(停止所有用户线程)，\n\n<img src=\"面试题库/image-20211121234902565.png\" alt=\"image-20211121234902565\" style=\"zoom:50%;\" /> \n\nEden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄最多到一定值(最大值是15，对\n\n象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁)(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有\n\n达到阈值的对象会被复制到“To”区域。\n\n<img src=\"面试题库/image-20211121235052820.png\" alt=\"image-20211121235052820\" style=\"zoom:50%;\" /> \n\n\"From\"和\"To\"会交换他们的角色,下一次垃圾回收的时候也是从Eden将存活的对象复制到TO区\n\n<img src=\"面试题库/image-20211121235346217.png\" alt=\"image-20211121235346217\" style=\"zoom:50%;\" /> \n\nMinor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。\n\n\n\n案例演示：\n\njvm参数设置：\n\n```sql\n-XX:+UseSerialGC -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:./gc.log -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8\n\n-XX:+UseSerialGC 是指使用 Serial + SerialOld 回收器组合\n-XX:+PrintGCDetails -verbose:gc 是指打印 GC 详细信息\n-XX:+PrintGCTimeStamps 打印gc日志的时间戳\n-Xloggc:./gc.log 将gc日志输出到一个日志文件中\n-Xms20M -Xmx20M -Xmn10M 是指分配给JVM的最小，最大以及新生代内存\n-XX:SurvivorRatio=8 是指『伊甸园』与『幸存区 From』和『幸存区 To』比例为 8:1:1\n```\n\n定义内存大小变量\n\n```java\nprivate static final int _512KB = 512 * 1024;\nprivate static final int _1MB = 1024 * 1024;\nprivate static final int _4MB = 4 * 1024 * 1024;\nprivate static final int _7MB = 7 * 1024 * 1024;\nprivate static final int _8MB = 8 * 1024 * 1024;\n```\n\n\n\n案例1：没有创建数组对象，看参数运行情况\n\n案例2：创建一个4M的数组，查看内存分配情况\n\n```java\n// 创建一个4M大小的数组\nbyte[] bytes = new byte[_4MB] ;\n```\n\n```java\nHeap\n def new generation   total 9216K, used 8192K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  eden space 8192K, 100% used [0x00000000fec00000, 0x00000000ff400000, 0x00000000ff400000)  // 在伊甸园中创建对象\n  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)\n  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)\n tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)\n Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n```\n\n没有触发GC操作，对象直接在Eden分配；\n\n\n\n案例3：创建一个7M的数组，查看内存分配情况\n\n```java\n// 创建一个7M大小的数组\nbyte[] bytes1 = new byte[_7MB] ;\n```\n\n```java\n-- 触发垃圾回收\n[GC (Allocation Failure) [DefNew: 2004K->647K(9216K), 0.0023439 secs] 2004K->647K(19456K), 0.0024142 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \nHeap\n def new generation   total 9216K, used 7897K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  eden space 8192K,  88% used [0x00000000fec00000, 0x00000000ff314930, 0x00000000ff400000)\n  from space 1024K,  63% used [0x00000000ff500000, 0x00000000ff5a1e58, 0x00000000ff600000)\n  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)\n tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)\n Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n```\n\n由于程序在启动的时候jdk内部还会存在一些对象的创建，因此当我们分配了一个7M的内存空间，eden内存不足，因此发生了一次Minor GC！并且将存\n\n活下的对象最终存储到from区中。\n\n\n\n案例4： 在案例3的基础上，在分配一个512KB的数组内存空间\n\n```java\nbyte[] bytes1 = new byte[_7MB] ;\nbyte[] bytes2 = new byte[_512KB] ;\n```\n\n```java\n[GC (Allocation Failure) [DefNew: 2005K->623K(9216K), 0.0015235 secs] 2005K->623K(19456K), 0.0015799 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \nHeap\n def new generation   total 9216K, used 8713K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  eden space 8192K,  98% used [0x00000000fec00000, 0x00000000ff3e6820, 0x00000000ff400000)\n  from space 1024K,  60% used [0x00000000ff500000, 0x00000000ff59bdb8, 0x00000000ff600000)\n  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)\n tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)\n Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n\n```\n\n触发一次GC操作！并且将存活下的对象最终存储到from区中，第二次分配_512KB大小的内存空间的时候，直接在伊甸园分配即可。\n\n\n\n案例5： 在4的基础上在分配一个512KB的数组内存空间\n\n```java\nbyte[] bytes1 = new byte[_7MB] ;\nbyte[] bytes2 = new byte[_512KB] ;\nbyte[] bytes3 = new byte[_512KB] ;\n```\n\n```java\n[GC (Allocation Failure) [DefNew: 2004K->620K(9216K), 0.0018706 secs] 2004K->620K(19456K), 0.0019275 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[GC (Allocation Failure) [DefNew: 8628K->539K(9216K), 0.0063389 secs] 8628K->8323K(19456K), 0.0063773 secs] [Times: user=0.00 sys=0.01, real=0.01 secs] \nHeap\n def new generation   total 9216K, used 1133K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  eden space 8192K,   7% used [0x00000000fec00000, 0x00000000fec94930, 0x00000000ff400000)\n  from space 1024K,  52% used [0x00000000ff400000, 0x00000000ff486de0, 0x00000000ff500000)\n  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)\n tenured generation   total 10240K, used 7784K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n   the space 10240K,  76% used [0x00000000ff600000, 0x00000000ffd9a040, 0x00000000ffd9a200, 0x0000000100000000)\n Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n```\n\n触发了2次垃圾回收！并且将from区中存活的对象存储到老年代！\n\n**② 大对象直接晋升至老年代**\n\n当对象太大，伊甸园包括幸存区都存放不下时，这时候老年代的连续空间足够，此对象会直接晋升至老年代，不会发生 GC\n\n<img src=\"面试题库/image-20211122221152776.png\" alt=\"image-20211122221152776\" style=\"zoom: 50%;\" /> \n\n结果\n\n<img src=\"面试题库/image-20211122221255321.png\" alt=\"image-20211122221255321\" style=\"zoom:50%;\" /> \n\n\n\n案例演示：\n\n案例1：直接分配一个8M的内存空间\n\n```java\nbyte[] bytes1 = new byte[_8MB] ;\n```\n\n伊甸园总大小只有 8 MB，但新分配的对象大小已经是 8MB，而幸存区都仅有 1MB，也无法容纳这个对象\n\n```java\nHeap\n def new generation   total 9216K, used 2169K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee1e560, 0x00000000ff400000)\n  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)\n  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)\n tenured generation   total 10240K, used 8192K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n   the space 10240K,  80% used [0x00000000ff600000, 0x00000000ffe00010, 0x00000000ffe00200, 0x0000000100000000)\n Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K\n```\n\n可以看到结果并没有发生 GC，大对象直接被放入了老年代「tenured generation   total 10240K, used 8192K」\n\n\n\n案例演示2：老年代连续空间不足，触发 Full GC\n\n```java\nbyte[] bytes1 = new byte[_8MB] ;\nbyte[] bytes2 = new byte[_8MB] ;\n```\n\n第一个 8MB 直接进入老年代，第二个 8MB 对象在分配时发现老年代空间不足，只好尝试先进行一次 Minor GC，结果发现新生代没有连续空间，只好\n\n触发一次 Full GC，最后发现老年代也没有连续空间，这时出现 OutOfMemoryError\n\n```java\n[GC (Allocation Failure) [DefNew: 2004K->647K(9216K), 0.0022693 secs][Tenured: 8192K->8838K(10240K), 0.0452151 secs] 10197K->8838K(19456K), [Metaspace: 3438K->3438K(1056768K)], 0.0504669 secs] [Times: user=0.00 sys=0.00, real=0.05 secs] \n[Full GC (Allocation Failure) [TenuredException in thread \"main\" : 8838K->8820K(10240K), 0.0027463 secs] 8838K->8820K(19456K), [Metaspace: 3438K->3438K(1056768K)], 0.0027877 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \njava.lang.OutOfMemoryError: Java heap space\n\tat com.itheima.jvm.gc.ObjectMemoryDemo.main(ObjectMemoryDemo.java:14)\nHeap\n def new generation   total 9216K, used 246K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  eden space 8192K,   3% used [0x00000000fec00000, 0x00000000fec3d890, 0x00000000ff400000)\n  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)\n  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)\n tenured generation   total 10240K, used 8820K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n   the space 10240K,  86% used [0x00000000ff600000, 0x00000000ffe9d220, 0x00000000ffe9d400, 0x0000000100000000)\n Metaspace       used 3470K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 379K, capacity 388K, committed 512K, reserved 1048576K\n```\n\n> ### 12、对象是怎么从年轻代进入老年代的？\n\n存在3种情况：\n\n1、如果对象够老，会通过提升（Promotion）进入老年代，这一般是根据对象的年龄进行判断的。\n\n2、动态对象年龄判定。有的垃圾回收算法，比如G1，并不要求age必须达到15才能晋升到老年代，它会使用一些动态的计算方法。\n\n3、超出某个大小的对象将直接在老年代分配。不过这个值默认为0，意思是全部首选Eden区进行分配。\n\n> ### 13、简单描述一下（分代）垃圾回收的过程？(高频)\n\n![image-20220205135024347](面试题库/image-20220205135024347.png) \n\n分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是2/3。\n\n新生代使用的是复制算法，新生代里有3个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：\n\n当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：\n\n1、在Eden区执行了第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称to）\n\n2、From区中的对象根据对象的年龄值决定去向，达到阈值15移动到老年代，没有达到复制到to区域(复制算法)\n\n3、在把Eden和to区中的对象清空掉\n\n> ### 14、JVM的永久代中会发生垃圾回收么？\n\n永久代会触发垃圾回收的，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。\n\n注：Java 8 中已经移除了永久代，新加了一个叫做元数据区(Metaspace)的内存区。\n\n# 4 垃圾收集器\n\n> ### 15、常见的垃圾收集器都有哪些？(高频)\n\n常见的垃圾收集器如下所示：\n\n<img src=\"面试题库/image-20211122221623386.png\" alt=\"image-20211122221623386\" style=\"zoom:50%;\" /> \n\n不同的垃圾收集器，作用的堆内存空间是不一样的；上面的  serial ， parnew ， Paraller Scavenge 是新生代的垃圾回收\n\n器；CMS ， Serial Old ， \n\nParalle Old是老年代的垃圾收集器 ， G1垃圾收集器可以作用于新生代和老年代； 连线表示垃圾收集器可以搭配使用；\n\n**① Serial**\n\n特点：\n\n1. Serial是一个单线程的垃圾收集器\n2. \"Stop The World\"，它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。在用户不可见的情况下把用户正常工作的线程全部停掉。\n\n<img src=\"面试题库/image-20211122221834107.png\" alt=\"image-20211122221834107\" style=\"zoom:50%;\" /> \n\n应用场景：\n\n1. 使用场景：多用于桌面应用，Client端的垃圾回收器\n2. 桌面应用内存小，进行垃圾回收的时间比较短，只要不频繁发生停顿就可以接受\n\nSerial Old收集器是Serial的老年代版本和Serial一样是单线程，使用的算法是\"标记-整理\"\n\n**② ParNew**\n\n概述: ParNew 收集器其实就是 Serial 收集器的多线程版本\n\n<img src=\"面试题库/image-20211122221953914.png\" alt=\"image-20211122221953914\" style=\"zoom:50%;\" /> \n\n特点：\n\n1、会触发stop the world\n\n2、多线程方式进行垃圾回收\n\n应用场景：它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器\n\n注意：如果是单核cpu即使使用该垃圾回收器也无法提高执行效率\n\n**③ Parallel Scavenge**\n\n概述：Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器\n\n特点：由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器\n\n所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即**吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）**，虚拟\n\n机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%  \n\n应用场景： 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n\n\n\nParallel old收集器Parallel Scavenge收集器的老年代版本，使用多线程+标记整理算法\n\n\n\n**④ CMS(重点)**\n\n概述：CMS  (Concurrent Mark Sweep）收集器是-种以获取最短回收停顿时间为目标的收集器。\n\n特点：\n\n1. CMS 收集器是基于“标记-清除”算法实现的\n\n2. 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上,这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好\n\n   的体验。\n\n<img src=\"面试题库/image-20211122222251802.png\" alt=\"image-20211122222251802\" style=\"zoom:50%;\" /> \n\n\n\n步骤流程：\n\n- 初始标记（CMS initial mark)  \t\t  -------- 标记一下 GC Roots 能直接关联到的对象，速度很快（stop the world）\n- 并发标记（CMS concurrent mark）  -------- 对初始标记标记过的对象，进行trace（进行追踪，得到所有关联的对象，进行标记）\n- 重新标记（CMS remark)                   -------- 为了修正并发标记期间因用户程序导致标记产生变动的标记记录（stop the world）\n- 并发清除（CMS concurrent sweep)  \n\n缺点：会产生垃圾碎片\n\n**⑤ G1**\n\n概述： G1是一个分代的，并行与并发的\"**标记-整理**\"垃圾回收器。 它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂\n\n停时间（pause time），同时兼顾良好的吞吐量。\n\n相比于CMS：\n\n1. G1垃圾回收器使用的是\"标记-整理\"，因此其回收得到的空间是连续的。\n\n2. G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内\n\n   存的回收是以region作为基本单位的；\n\n<img src=\"面试题库/image-20211122222552239.png\" alt=\"image-20211122222552239\" style=\"zoom:50%;\" /> \n\n> ### 16、你都用过G1垃圾回收器的哪几个重要参数？\n\n**① -XX:MaxGCPauseMillis**\n\n暂停时间，默认值200ms。这是一个软性目标，G1会尽量达成，如果达不成，会逐渐做自我调整。\n\n**② -XX:G1HeapRegionSize**\n\nRegion大小，若未指定则默认最多生成2048块，每块的大小需要为2的幂次方，如1,2,4,8,16,32，最大值为32M。\n\n**③ -XX:G1NewSizePercent 和 -XX:G1MaxNewSizePercent**\n\n新生代比例有两个数值指定，下限：-XX:G1NewSizePercent，默认值5%，上限：-XX:G1MaxNewSizePercent，默认值60%。\n\n> ### 17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？\n\n吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。 而串行收集器对大多数的小应用（在现代处理器上需要大概 \n\n100M 左右的内存）就足够了。\n\n> ### 18、生产上如何配置垃圾收集器的？\n\n| ![image-20220205181209799](images/image-20220205181209799.png) |\n| ------------------------------------------------------------ |\n\n1、首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的2/3（这是想\n\n给其他进程和操作系统预留一些时间），超过8GB的堆优先选用G1。\n\n2、接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。\n\n3、再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。我会通过记录\n\n详细的GC日志，来找到这个瓶颈点，借用**gceasy（重点）**https://gceasy.io/这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因\n\n为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。\n\n![image-20220216235212123](面试题库/image-20220216235212123.png) \n\n# 5 类加载器\n\n> ### 19、什么是类加载器，类加载器有哪些？(高频)\n\n类加载器的作用：负载将的class文件加载到java虚拟机中，并为之创建一个Class对象\n\n从Java虚拟机的角度来讲，只存在如下两种不同的类加载器：\n\n1.  启动类加载器（Bootstrap ClassLoader）, 这个类加载器使用C++语言实现，是虚拟机自身的一部分\n2.  其他类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类（java.lang.ClassLoader）\n\n从Java开发人员的角度来讲，类加载器还可以划分的更细致一下，绝大部分Java程序都会使用到以下3种系统提供的类加载器：\n\n1. 启动类加载器（Bootstrap class loader）：它是虚拟机的内置类加载器，通过表示为null\n\n2. 平台类加载器（Platform class loader）  ：它是平台类加载器； 负责加载JDK中一些特殊的模块；\n\n3. 系统类加载器（System class loader）    ：它也被称为应用程序类加载器， 它负责加载用户类路径上所指定的类库，一般情况下这个就是程序中默\n\n   认的类加载器\n\n> ### 20、Java的双亲委托机制是什么？(高频)\n\n**概述**\n\n我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自定义的类加载器。这些类加载器之间的层次关系一般会如下图所\n\n示：\n\n<img src=\"面试题库/1577331614462.png\" alt=\"1577331614462\" style=\"zoom:33%;\" />   \n\n上图所展示的类加载器之间的这种层次关系，就称之为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该\n\n有自己的父类加载器。这里的类加载器的父子关系不是真正物理意义上的继承，而是逻辑上的继承。\n\n**工作过程**\n\n双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个\n\n层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索\n\n返回中没有找到所需的类）时，子类加载器才会尝试自己去加载。\n\n# 6 性能调优\n\n> ### 21、调优命令有哪些？\n\n1、**jps**，JVM Process Status Tool显示指定系统内所有的HotSpot虚拟机进程。\n\n2、**jstat**，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运\n\n行数据。\n\n查询帮助文档：jstat -options\n\n| ![image-20220205192109645](面试题库/image-20220205192109645.png) |\n| ------------------------------------------------------------ |\n\n| ![image-20220205192221590](面试题库/image-20220205192221590.png) |\n| ------------------------------------------------------------ |\n\n3、**jmap**，JVM Memory Map命令用于查看**堆内存**的分配情况以及生成heap dump文件 \n\n查询帮助文档：jmap -h\n\n示例1：jmap -heap 33193 查询堆内存的分配情况\n\n示例2：jmap -dump:format=b,file=thread-cup.log 33193\n\n4、**jhat**，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的\n\n分析结果后，可以在浏览器中查看\n\n查询帮助文档：\n\njhat -h\n\n示例：jhat -J-Xmx512M thread-cup.log\n\n| ![image-20220205193256668](面试题库/image-20220205193256668.png) |\n| ------------------------------------------------------------ |\n\n5、**jstack**，用于生成java虚拟机当前时刻的线程快照。\n\n查看帮助文档：jstack -h\n\n示例：jstack -l 33193\n\n6、**jinfo**，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。\n\n查看帮助文档：jinfo -h\n\n示例：jinfo -flags 33193\n\n| ![image-20220205193604548](面试题库/image-20220205193604548.png) |\n| ------------------------------------------------------------ |\n\n> ### 22、你知道哪些JVM性能调优参数？(高频)\n\n1、设定堆内存大小：\n\n​\t-Xms\t设置最小堆内存大小(不能小于1024K); \t-Xms 堆内存初始大小，可以通过jmap工具进行查看\n\n​\t-Xmx\t设置最大堆内存大小(不能小于1024K);     -Xmx 堆内存最大值，可以通过jmap工具进行查看\n\n2、设定新生代大小：\n\n​\t-XX:NewSize：新生代大小\n\n​\t-XX:NewRatio 新生代和老生代占比\n\n3、-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比\n\n4、设定垃圾回收器\n\n​\t年轻代用 -XX:+UseParNewGC \n\n​\t年老代用-XX:+UseConcMarkSweepGC\n\n> ### 23、你用过哪些性能调优工具？(高频)\n\n常用调优工具分为两类\n\n1、jdk自带监控工具\n\n* jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类\n\n  等的监控\n\n* jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。\n\n2、第三方\n\n* MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和\n\n  减少内存消耗\n\n* GChisto，一款专业分析gc日志的工具\n\n> ### 24、你都有哪些手段用来排查内存溢出？(高频)\n\n内存溢出包含很多种情况，我在平常工作中遇到最多的就是堆溢出。有一次线上遇到故障，重新启动后，使用**jstat**命令，发现Old区在一直增长。我使用\n\n**jmap**命令，导出了一份线上堆栈，然后使用MAT进行分析。通过对GC Roots的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学做缓\n\n存用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 Guava Cache，并设置了弱引用，故障就消失了。\n\n"}]